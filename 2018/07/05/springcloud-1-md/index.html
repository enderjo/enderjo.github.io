<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="title: 授权认证服务date: 2018-07-05 16:56:44 tags:OAuth 2 Developers GuideIntroductionThis is the user guide for the support for OAuth 2.0. For OAuth 1.0, everything is different, so see its user guide. Th">
<meta property="og:type" content="article">
<meta property="og:title" content="CrazyAirhead">
<meta property="og:url" content="http://l4qiang.me/2018/07/05/springcloud-1-md/index.html">
<meta property="og:site_name" content="CrazyAirhead">
<meta property="og:description" content="title: 授权认证服务date: 2018-07-05 16:56:44 tags:OAuth 2 Developers GuideIntroductionThis is the user guide for the support for OAuth 2.0. For OAuth 1.0, everything is different, so see its user guide. Th">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-07-05T09:09:53.542Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CrazyAirhead">
<meta name="twitter:description" content="title: 授权认证服务date: 2018-07-05 16:56:44 tags:OAuth 2 Developers GuideIntroductionThis is the user guide for the support for OAuth 2.0. For OAuth 1.0, everything is different, so see its user guide. Th">






  <link rel="canonical" href="http://l4qiang.me/2018/07/05/springcloud-1-md/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title> | CrazyAirhead</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ed9d534576a67e94ff8be03a704994";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CrazyAirhead</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">疯狂的傻瓜，傻瓜也疯狂————傻方能执著，疯狂才专注!</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/07/05/springcloud-1-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-05 16:56:44 / 修改时间：17:09:53" itemprop="dateCreated datePublished" datetime="2018-07-05T16:56:44+08:00">2018-07-05</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p>title: 授权认证服务<br>date: 2018-07-05 16:56:44</p>
<h2 id="tags"><a href="/2018/07/05/springcloud-1-md/#tags" class="headerlink" title="tags:"></a>tags:</h2><p>OAuth 2 Developers Guide<br>Introduction<br>This is the user guide for the support for OAuth 2.0. For OAuth 1.0, everything is different, so see its user guide.</p>
<p>This user guide is divided into two parts, the first for the OAuth 2.0 provider, the second for the OAuth 2.0 client. For both the provider and the client, the best source of sample code is the integration tests and sample apps.</p>
<p>OAuth 2.0 Provider<br>The OAuth 2.0 provider mechanism is responsible for exposing OAuth 2.0 protected resources. The configuration involves establishing the OAuth 2.0 clients that can access its protected resources independently or on behalf of a user. The provider does this by managing and verifying the OAuth 2.0 tokens used to access the protected resources. Where applicable, the provider must also supply an interface for the user to confirm that a client can be granted access to the protected resources (i.e. a confirmation page).</p>
<p>OAuth 2.0 Provider Implementation<br>The provider role in OAuth 2.0 is actually split between Authorization Service and Resource Service, and while these sometimes reside in the same application, with Spring Security OAuth you have the option to split them across two applications, and also to have multiple Resource Services that share an Authorization Service. The requests for the tokens are handled by Spring MVC controller endpoints, and access to protected resources is handled by standard Spring Security request filters. The following endpoints are required in the Spring Security filter chain in order to implement OAuth 2.0 Authorization Server:</p>
<p>AuthorizationEndpoint is used to service requests for authorization. Default URL: /oauth/authorize.<br>TokenEndpoint is used to service requests for access tokens. Default URL: /oauth/token.<br>The following filter is required to implement an OAuth 2.0 Resource Server:</p>
<p>The OAuth2AuthenticationProcessingFilter is used to load the Authentication for the request given an authenticated access token.<br>For all the OAuth 2.0 provider features, configuration is simplified using special Spring OAuth @Configuration adapters. There is also an XML namespace for OAuth configuration, and the schema resides at <a href="http://www.springframework.org/schema/security/spring-security-oauth2.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/security/spring-security-oauth2.xsd</a>. The namespace is <a href="http://www.springframework.org/schema/security/oauth2" target="_blank" rel="noopener">http://www.springframework.org/schema/security/oauth2</a>.</p>
<p>Authorization Server Configuration<br>As you configure the Authorization Server, you have to consider the grant type that the client is to use to obtain an access token from the end-user (e.g. authorization code, user credentials, refresh token). The configuration of the server is used to provide implementations of the client details service and token services and to enable or disable certain aspects of the mechanism globally. Note, however, that each client can be configured specifically with permissions to be able to use certain authorization mechanisms and access grants. I.e. just because your provider is configured to support the “client credentials” grant type, doesn’t mean that a specific client is authorized to use that grant type.</p>
<p>The @EnableAuthorizationServer annotation is used to configure the OAuth 2.0 Authorization Server mechanism, together with any @Beans that implement AuthorizationServerConfigurer (there is a handy adapter implementation with empty methods). The following features are delegated to separate configurers that are created by Spring and passed into the AuthorizationServerConfigurer:</p>
<p>ClientDetailsServiceConfigurer: a configurer that defines the client details service. Client details can be initialized, or you can just refer to an existing store.<br>AuthorizationServerSecurityConfigurer: defines the security constraints on the token endpoint.<br>AuthorizationServerEndpointsConfigurer: defines the authorization and token endpoints and the token services.<br>An important aspect of the provider configuration is the way that an authorization code is supplied to an OAuth client (in the authorization code grant). A authorization code is obtained by the OAuth client by directing the end-user to an authorization page where the user can enter her credentials, resulting in a redirection from the provider authorization server back to the OAuth client with the authorization code. Examples of this are elaborated in the OAuth 2 specification.</p>
<p>In XML there is an <authorization-server> element that is used in a similar way to configure the OAuth 2.0 Authorization Server.</authorization-server></p>
<p>Configuring Client Details<br>The ClientDetailsServiceConfigurer (a callback from your AuthorizationServerConfigurer) can be used to define an in-memory or JDBC implementation of the client details service. Important attributes of a client are</p>
<p>clientId: (required) the client id.<br>secret: (required for trusted clients) the client secret, if any.<br>scope: The scope to which the client is limited. If scope is undefined or empty (the default) the client is not limited by scope.<br>authorizedGrantTypes: Grant types that are authorized for the client to use. Default value is empty.<br>authorities: Authorities that are granted to the client (regular Spring Security authorities).<br>Client details can be updated in a running application by access the underlying store directly (e.g. database tables in the case of JdbcClientDetailsService) or through the ClientDetailsManager interface (which both implementations of ClientDetailsService also implement).</p>
<p>NOTE: the schema for the JDBC service is not packaged with the library (because there are too many variations you might like to use in practice), but there is an example you can start from in the test code in github.</p>
<p>Managing Tokens<br>The AuthorizationServerTokenServices interface defines the operations that are necessary to manage OAuth 2.0 tokens. Note the following:</p>
<p>When an access token is created, the authentication must be stored so that resources accepting the access token can reference it later.<br>The access token is used to load the authentication that was used to authorize its creation.<br>When creating your AuthorizationServerTokenServices implementation, you may want to consider using the DefaultTokenServices which has many strategies that can be plugged in to change the format and storage of access tokens. By default it creates tokens via random value and handles everything except for the persistence of the tokens which it delegates to a TokenStore. The default store is an in-memory implementation, but there are some other implementations available. Here’s a description with some discussion of each of them</p>
<p>The default InMemoryTokenStore is perfectly fine for a single server (i.e. low traffic and no hot swap to a backup server in the case of failure). Most projects can start here, and maybe operate this way in development mode, to make it easy to start a server with no dependencies.</p>
<p>The JdbcTokenStore is the JDBC version of the same thing, which stores token data in a relational database. Use the JDBC version if you can share a database between servers, either scaled up instances of the same server if there is only one, or the Authorization and Resources Servers if there are multiple components. To use the JdbcTokenStore you need “spring-jdbc” on the classpath.</p>
<p>The JSON Web Token (JWT) version of the store encodes all the data about the grant into the token itself (so no back end store at all which is a significant advantage). One disadvantage is that you can’t easily revoke an access token, so they normally are granted with short expiry and the revocation is handled at the refresh token. Another disadvantage is that the tokens can get quite large if you are storing a lot of user credential information in them. The JwtTokenStore is not really a “store” in the sense that it doesn’t persist any data, but it plays the same role of translating betweeen token values and authentication information in the DefaultTokenServices.</p>
<p>NOTE: the schema for the JDBC service is not packaged with the library (because there are too many variations you might like to use in practice), but there is an example you can start from in the test code in github. Be sure to @EnableTransactionManagement to prevent clashes between client apps competing for the same rows when tokens are created. Note also that the sample schema has explicit PRIMARY KEY declarations - these are also necessary in a concurrent environment.</p>
<p>JWT Tokens<br>To use JWT tokens you need a JwtTokenStore in your Authorization Server. The Resource Server also needs to be able to decode the tokens so the JwtTokenStore has a dependency on a JwtAccessTokenConverter, and the same implementation is needed by both the Authorization Server and the Resource Server. The tokens are signed by default, and the Resource Server also has to be able to verify the signature, so it either needs the same symmetric (signing) key as the Authorization Server (shared secret, or symmetric key), or it needs the public key (verifier key) that matches the private key (signing key) in the Authorization Server (public-private or asymmetric key). The public key (if available) is exposed by the Authorization Server on the /oauth/token_key endpoint, which is secure by default with access rule “denyAll()”. You can open it up by injecting a standard SpEL expression into the AuthorizationServerSecurityConfigurer (e.g. “permitAll()” is probably adequate since it is a public key).</p>
<p>To use the JwtTokenStore you need “spring-security-jwt” on your classpath (you can find it in the same github repository as Spring OAuth but with a different release cycle).</p>
<p>Grant Types<br>The grant types supported by the AuthorizationEndpoint can be configured via the AuthorizationServerEndpointsConfigurer. By default all grant types are supported except password (see below for details of how to switch it on). The following properties affect grant types:</p>
<p>authenticationManager: password grants are switched on by injecting an AuthenticationManager.<br>userDetailsService: if you inject a UserDetailsService or if one is configured globally anyway (e.g. in a GlobalAuthenticationManagerConfigurer) then a refresh token grant will contain a check on the user details, to ensure that the account is still active<br>authorizationCodeServices: defines the authorization code services (instance of AuthorizationCodeServices) for the auth code grant.<br>implicitGrantService: manages state during the imlpicit grant.<br>tokenGranter: the TokenGranter (taking full control of the granting and ignoring the other properties above)<br>In XML grant types are included as child elements of the authorization-server.</p>
<p>Configuring the Endpoint URLs<br>The AuthorizationServerEndpointsConfigurer has a pathMapping() method. It takes two arguments:</p>
<p>The default (framework implementation) URL path for the endpoint<br>The custom path required (starting with a “/“)<br>The URL paths provided by the framework are /oauth/authorize (the authorization endpoint), /oauth/token (the token endpoint), /oauth/confirm_access (user posts approval for grants here), /oauth/error (used to render errors in the authorization server), /oauth/check_token (used by Resource Servers to decode access tokens), and /oauth/token_key (exposes public key for token verification if using JWT tokens).</p>
<p>N.B. the Authorization endpoint /oauth/authorize (or its mapped alternative) should be protected using Spring Security so that it is only accessible to authenticated users. For instance using a standard Spring Security WebSecurityConfigurer:</p>
<p>   @Override<br>    protected void configure(HttpSecurity http) throws Exception {<br>        http<br>            .authorizeRequests().antMatchers(“/login”).permitAll().and()<br>        // default protection for all resources (including /oauth/authorize)<br>            .authorizeRequests()<br>                .anyRequest().hasRole(“USER”)<br>        // … more configuration, e.g. for form login<br>    }<br>Note: if your Authorization Server is also a Resource Server then there is another security filter chain with lower priority controlling the API resources. Fo those requests to be protected by access tokens you need their paths not to be matched by the ones in the main user-facing filter chain, so be sure to include a request matcher that picks out only non-API resources in the WebSecurityConfigurer above.</p>
<p>The token endpoint is protected for you by default by Spring OAuth in the @Configuration support using HTTP Basic authentication of the client secret. This is not the case in XML (so it should be protected explicitly).</p>
<p>In XML the <authorization-server> element has some attributes that can be used to change the default endpoint URLs in a similar way. The /check_token endpoint has to be explicitly enabled (with the check-token-enabled attribute).</authorization-server></p>
<p>Customizing the UI<br>Most of the Authorization Server endpoints are used primarily by machines, but there are a couple of resource that need a UI and those are the GET for /oauth/confirm_access and the HTML response from /oauth/error. They are provided using whitelabel implementations in the framework, so most real-world instances of the Authorization Server will want to provide their own so they can control the styling and content. All you need to do is provide a Spring MVC controller with @RequestMappings for those endpoints, and the framework defaults will take a lower priority in the dispatcher. In the /oauth/confirm_access endpoint you can expect an AuthorizationRequest bound to the session carrying all the data needed to seek approval from the user (the default implementation is WhitelabelApprovalEndpoint so look there for a starting point to copy). You can grab all the data from that request and render it however you like, and then all the user needs to do is POST back to /oauth/authorize with information about approving or denying the grant. The request parameters are passed directly to a UserApprovalHandler in the AuthorizationEndpoint so you can interpret the data more or less as you please. The default UserApprovalHandler depends on whether or not you have supplied an ApprovalStore in your AuthorizationServerEndpointsConfigurer (in which case it is an ApprovalStoreUserApprovalHandler) or not (in which case it is a TokenStoreUserApprovalHandler). The standard approval handlers accept the following:</p>
<p>TokenStoreUserApprovalHandler: a simple yes/no decision via user_oauth_approval equals to “true” or “false”.</p>
<p>ApprovalStoreUserApprovalHandler: a set of scope.<em> parameter keys with “</em>“ equal to the scopes being requested. The value of the parameter can be “true” or “approved” (if the user approved the grant) else the user is deemed to have rejected that scope. A grant is successful if at least one scope is approved.</p>
<p>NOTE: don’t forget to include CSRF protection in your form that you render for the user. Spring Security is expecting a request parameter called “_csrf” by default (and it provides the value in a request attribute). See the Spring Security user guide for more information on that, or look at the whitelabel implementation for guidance.</p>
<p>Enforcing SSL<br>Plain HTTP is fine for testing but an Authorization Server should only be used over SSL in production. You can run the app in a secure container or behind a proxy and it should work fine if you set the proxy and the container up correctly (which is nothing to do with OAuth2). You might also want to secure the endpoints using Spring Security requiresChannel() constraints. For the /authorize endpoint is up to you to do that as part of your normal application security. For the /token endpoint there is a flag in the AuthorizationServerEndpointsConfigurer that you can set using the sslOnly() method. In both cases the secure channel setting is optional but will cause Spring Security to redirect to what it thinks is a secure channel if it detects a request on an insecure channel.</p>
<p>Customizing the Error Handling<br>Error handling in an Authorization Server uses standard Spring MVC features, namely @ExceptionHandler methods in the endpoints themselves. Users can also provide a WebResponseExceptionTranslator to the endpoints themselves which is the best way to change the content of the responses as opposed to the way they are rendered. The rendering of exceptions delegates to HttpMesssageConverters (which can be added to the MVC configuration) in the case of token endpoint and to the OAuth error view (/oauth/error) in the case of teh authorization endpoint. The whitelabel error endpoint is provided for HTML responses, but users probably need to provide a custom implementation (e.g. just add a @Controller with @RequestMapping(“/oauth/error”)).</p>
<p>Mapping User Roles to Scopes<br>It is sometimes useful to limit the scope of tokens not only by the scopes assigned to the client, but also according to the user’s own permissions. If you use a DefaultOAuth2RequestFactory in your AuthorizationEndpoint you can set a flag checkUserScopes=true to restrict permitted scopes to only those that match the user’s roles. You can also inject an OAuth2RequestFactory into the TokenEndpoint but that only works (i.e. with password grants) if you also install a TokenEndpointAuthenticationFilter - you just need to add that filter after the HTTP BasicAuthenticationFilter. Of course, you can also implement your own rules for mapping scopes to roles and install your own version of the OAuth2RequestFactory. The AuthorizationServerEndpointsConfigurer allows you to inject a custom OAuth2RequestFactory so you can use that feature to set up a factory if you use @EnableAuthorizationServer.</p>
<p>Resource Server Configuration<br>A Resource Server (can be the same as the Authorization Server or a separate application) serves resources that are protected by the OAuth2 token. Spring OAuth provides a Spring Security authentication filter that implements this protection. You can switch it on with @EnableResourceServer on an @Configuration class, and configure it (as necessary) using a ResourceServerConfigurer. The following features can be configured:</p>
<p>tokenServices: the bean that defines the token services (instance of ResourceServerTokenServices).<br>resourceId: the id for the resource (optional, but recommended and will be validated by the auth server if present).<br>other extension points for the resourecs server (e.g. tokenExtractor for extracting the tokens from incoming requests)<br>request matchers for protected resources (defaults to all)<br>access rules for protected resources (defaults to plain “authenticated”)<br>other customizations for the protected resources permitted by the HttpSecurity configurer in Spring Security<br>The @EnableResourceServer annotation adds a filter of type OAuth2AuthenticationProcessingFilter automatically to the Spring Security filter chain.</p>
<p>In XML there is a <resource-server> element with an id attribute - this is the bean id for a servlet Filter that can then be added manually to the standard Spring Security chain.</resource-server></p>
<p>Your ResourceServerTokenServices is the other half of a contract with the Authorization Server. If the Resource Server and Authorization Server are in the same application and you use DefaultTokenServices then you don’t have to think too hard about this because it implements all the necessary interfaces so it is automatically consistent. If your Resource Server is a separate application then you have to make sure you match the capabilities of the Authorization Server and provide a ResourceServerTokenServices that knows how to decode the tokens correctly. As with the Authorization Server, you can often use the DefaultTokenServices and the choices are mostly expressed through the TokenStore (backend storage or local encoding). An alternative is the RemoteTokenServices which is a Spring OAuth features (not part of the spec) allowing Resource Servers to decode tokens through an HTTP resource on the Authorization Server (/oauth/check_token). RemoteTokenServices are convenient if there is not a huge volume of traffic in the Resource Servers (every request has to be verified with the Authorization Server), or if you can afford to cache the results. To use the /oauth/check_token endpoint you need to expose it by changing its access rule (default is “denyAll()”) in the AuthorizationServerSecurityConfigurer, e.g.</p>
<pre><code>@Override
public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {
    oauthServer.tokenKeyAccess(&quot;isAnonymous() || hasAuthority(&apos;ROLE_TRUSTED_CLIENT&apos;)&quot;).checkTokenAccess(
            &quot;hasAuthority(&apos;ROLE_TRUSTED_CLIENT&apos;)&quot;);
}
</code></pre><p>In this example we are configuring both the /oauth/check_token endpoint and the /oauth/token_key endpoint (so trusted resources can obtain the public key for JWT verification). These two endpoints are protected by HTTP Basic authentication using client credentials.</p>
<p>Configuring An OAuth-Aware Expression Handler<br>You may want to take advantage of Spring Security’s expression-based access control. An expression handler will be registered by default in the @EnableResourceServer setup. The expressions include #oauth2.clientHasRole, #oauth2.clientHasAnyRole, and #oath2.denyClient which can be used to provide access based on the role of the oauth client (see OAuth2SecurityExpressionMethods for a comprehensive list). In XML you can register a oauth-aware expression handler with the expression-handler element of the regular <http> security configuration.</http></p>
<p>OAuth 2.0 Client<br>The OAuth 2.0 client mechanism is responsible for access the OAuth 2.0 protected resources of other servers. The configuration involves establishing the relevant protected resources to which users might have access. The client may also need to be supplied with mechanisms for storing authorization codes and access tokens for users.</p>
<p>Protected Resource Configuration<br>Protected resources (or “remote resources”) can be defined using bean definitions of type OAuth2ProtectedResourceDetails. A protected resource has the following properties:</p>
<p>id: The id of the resource. The id is only used by the client to lookup the resource; it’s never used in the OAuth protocol. It’s also used as the id of the bean.<br>clientId: The OAuth client id. This is the id by which the OAuth provider identifies your client.<br>clientSecret: The secret associated with the resource. By default, no secret is empty.<br>accessTokenUri: The URI of the provider OAuth endpoint that provides the access token.<br>scope: Comma-separted list of strings specifying the scope of the access to the resource. By default, no scope will be specified.<br>clientAuthenticationScheme: The scheme used by your client to authenticate to the access token endpoint. Suggested values: “http_basic” and “form”. Default: “http_basic”. See section 2.1 of the OAuth 2 spec.<br>Different grant types have different concrete implementations of OAuth2ProtectedResourceDetails (e.g. ClientCredentialsResource for “client_credentials” grant type). For grant types that require user authorization there is a further property:</p>
<p>userAuthorizationUri: The uri to which the user will be redirected if the user is ever needed to authorize access to the resource. Note that this is not always required, depending on which OAuth 2 profiles are supported.<br>In XML there is a <resource> element that can be used to create a bean of type OAuth2ProtectedResourceDetails. It has attributes matching all the properties above.</resource></p>
<p>Client Configuration<br>For the OAuth 2.0 client, configuration is simplified using @EnableOAuth2Client. This does 2 things:</p>
<p>Creates a filter bean (with ID oauth2ClientContextFilter) to store the current request and context. In the case of needing to authenticate during a request it manages the redirection to and from the OAuth authentication uri.</p>
<p>Creates a bean of type AccessTokenRequest in request scope. This can be used by authorization code (or implicit) grant clients to keep state related to individual users from colliding.</p>
<p>The filter has to be wired into the application (e.g. using a Servlet initializer or web.xml configuration for a DelegatingFilterProxy with the same name).</p>
<p>The AccessTokenRequest can be used in an OAuth2RestTemplate like this:</p>
<p>@Autowired<br>private OAuth2ClientContext oauth2Context;</p>
<p>@Bean<br>public OAuth2RestTemplate sparklrRestTemplate() {<br>    return new OAuth2RestTemplate(sparklr(), oauth2Context);<br>}<br>The OAuth2ClientContext is placed (for you) in session scope to keep the state for different users separate. Without that you would have to manage the equivalent data structure yourself on the server, mapping incoming requests to users, and associating each user with a separate instance of the OAuth2ClientContext.</p>
<p>In XML there is a <client> element with an id attribute - this is the bean id for a servlet Filter that must be mapped as in the @Configuration case to a DelegatingFilterProxy (with the same name).</client></p>
<p>Accessing Protected Resources<br>Once you’ve supplied all the configuration for the resources, you can now access those resources. The suggested method for accessing those resources is by using the RestTemplate introduced in Spring 3. OAuth for Spring Security has provided an extension of RestTemplate that only needs to be supplied an instance of OAuth2ProtectedResourceDetails. To use it with user-tokens (authorization code grants) you should consider using the @EnableOAuth2Client configuration (or the XML equivalent <oauth:rest-template>) which creates some request and session scoped context objects so that requests for different users do not collide at runtime.</oauth:rest-template></p>
<p>As a general rule, a web application should not use password grants, so avoid using ResourceOwnerPasswordResourceDetails if you can in favour of AuthorizationCodeResourceDetails. If you desparately need password grants to work from a Java client, then use the same mechanism to configure your OAuth2RestTemplate and add the credentials to the AccessTokenRequest (which is a Map and is ephemeral) not the ResourceOwnerPasswordResourceDetails (which is shared between all access tokens).</p>
<p>Persisting Tokens in a Client<br>A client does not need to persist tokens, but it can be nice for users to not be required to approve a new token grant every time the client app is restarted. The ClientTokenServices interface defines the operations that are necessary to persist OAuth 2.0 tokens for specific users. There is a JDBC implementation provided, but you can if you prefer implement your own service for storing the access tokens and associated authentication instances in a persistent database. If you want to use this feature you need provide a specially configured TokenProvider to the OAuth2RestTemplate e.g.</p>
<p>@Bean<br>@Scope(value = “session”, proxyMode = ScopedProxyMode.INTERFACES)<br>public OAuth2RestOperations restTemplate() {<br>    OAuth2RestTemplate template = new OAuth2RestTemplate(resource(), new DefaultOAuth2ClientContext(accessTokenRequest));<br>    AccessTokenProviderChain provider = new AccessTokenProviderChain(Arrays.asList(new AuthorizationCodeAccessTokenProvider()));<br>    provider.setClientTokenServices(clientTokenServices());<br>    return template;<br>}<br>Customizations for Clients of External OAuth2 Providers<br>Some external OAuth2 providers (e.g. Facebook) do not quite implement the specification correctly, or else they are just stuck on an older version of the spec than Spring Security OAuth. To use those providers in your client application you might need to adapt various parts of the client-side infrastructure.</p>
<p>To use Facebook as an example, there is a Facebook feature in the tonr2 application (you need to change the configuration to add your own, valid, client id and secret - they are easy to generate on the Facebook website).</p>
<p>Facebook token responses also contain a non-compliant JSON entry for the expiry time of the token (they use expires instead of expires_in), so if you want to use the expiry time in your application you will have to decode it manually using a custom OAuth2SerializationService.</p>
<link href="/css/prism.css" rel="stylesheet">
      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="L4qiang 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/03/ipfs-white-paper/" rel="next" title="IPFS——内容寻址，版本化，对等的文件系统">
                <i class="fa fa-chevron-left"></i> IPFS——内容寻址，版本化，对等的文件系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/03/idea/" rel="prev" title="IntelliJ IDEA授权">
                IntelliJ IDEA授权 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">L4qiang</p>
              <p class="site-description motion-element" itemprop="description">记录点滴，注重积累。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/enderjo" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          <section>
<div>友情链接</div>
<a href="http://tech.youxiangfang.shop/">ionlyleaf前端随笔</a>
</section>
<section>
<div>
<div>-------------------------------</div>
<iframe width="240px" height="275px" src="http://rec.g.163.com/kaolaad/api/smartad/reco.s?site=cps&amp;affiliate=homepage&amp;cat=homepage&amp;location=1&amp;type=240x275&amp;uid=&amp;trackingCode=&amp;promoteId=&amp;promoteType=&amp;unionId=999684145298" frameborder="no" border="0" marginwidth="0" marginheight="0" allowtransparency="yes" scrolling="NO"></iframe>
</div>
</section>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tags"><span class="nav-number">1.</span> <span class="nav-text"><a href="/2018/07/05/springcloud-1-md/#tags" class="headerlink" title="tags:"></a>tags:</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">L4qiang</span>

  

  
</div>


  



  <div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动 v3.4.3</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
