<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"l4qiang.me","root":"/","scheme":"Gemini","version":"8.0.0-rc.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录点滴，注重积累。">
<meta property="og:type" content="website">
<meta property="og:title" content="CrazyAirhead">
<meta property="og:url" content="http://l4qiang.me/page/17/index.html">
<meta property="og:site_name" content="CrazyAirhead">
<meta property="og:description" content="记录点滴，注重积累。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="L4qiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://l4qiang.me/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CrazyAirhead</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ed9d534576a67e94ff8be03a704994";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CrazyAirhead</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">疯狂的傻瓜，傻瓜也疯狂——傻方能执著，疯狂才专注!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/crazy-airhead" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/hbase/hbase-indexer/getting-start-demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/hbase/hbase-indexer/getting-start-demo/" class="post-title-link" itemprop="url">Hbase Indexer - 例子</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-12-05 12:34:00 / 修改时间：16:13:56" itemprop="dateCreated datePublished" datetime="2018-12-05T12:34:00+08:00">2018-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>361</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>If you want to test the HBase Indexer with a higher throughput than the manual puts explained in the <a href="https://github.com/NGDATA/hbase-indexer/wiki/Tutorial" target="_blank" rel="noopener">Tutorial</a>, but don’t want to bother setting up your own schema &amp; application, you will find the demo ingester tools useful.</p>
<p>如果你想测试HBase Indexer在高吞吐面而不是像<a href="">教程</a>所描述的那样手工输入，也不想设置一个自己的脚本和应用，你可以用demo提取工具。</p>
<p>For more information on them, please see demo/README.md in the binary distribution.</p>
<p>更为详细的信息，可以查看发布包中的<code>demo/README.md</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/hbase/hbase-indexer/indexer-configuration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/hbase/hbase-indexer/indexer-configuration/" class="post-title-link" itemprop="url">Hbase Indexer - 索引器配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-12-05 12:34:00 / 修改时间：18:11:38" itemprop="dateCreated datePublished" datetime="2018-12-05T12:34:00+08:00">2018-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>The most basic indexer configuration only requires a table name and a single field. However, there are many configuration settings that can be used in an indexer configuration file to customize behavior.</p>
<p>最基础索引器配置只需要一个表名和一个字段名就可以。但是，有很多配置可以用于配置可以自定义解析器的行为。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">indexer</span> <span class="attr">table</span>=<span class="string">"mytable"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"fieldname"</span> <span class="attr">value</span>=<span class="string">"columnfamily:qualifier"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="全局索引器属性（Global-indexer-attributes）"><a href="#全局索引器属性（Global-indexer-attributes）" class="headerlink" title="全局索引器属性（Global indexer attributes）"></a>全局索引器属性（Global indexer attributes）</h2><p>The following is a list of attributes that can be set on the top-level <indexer> element in an indexer configuration.</p>
<p>以下列出的属性可以在顶层<code>&lt;indexer&gt;</code>节点中配置。</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>The table attribute specifies the name of the HBase table to be indexed by the indexer. It is the only mandatory attribute in the indexer element.</p>
<p>table属性用于指定HBase需要索引器索引的表名。这个indexer节点中强制要求的属性。</p>
<h3 id="mapping-type"><a href="#mapping-type" class="headerlink" title="mapping-type"></a>mapping-type</h3><p>The mapping-type attribute has two possible values: row, or column. This attribute specifies whether row-based or column-based indexing is to be performed.</p>
<p>mapping-type属性有两种值：row和column。这个属性用于指定是基于行还是基于列的索引方式。</p>
<p>Row-based indexing treats all data within a single HBase row as input for a single document in Solr. This is the kind of indexing that would be used for an HBase table that contains a separate entity in each row, e.g. a table containing users.</p>
<p>基于行索引方式把Hbase一行当中的所有数据当成Solr的一个文档输入。这种方式用于索引一行就表示一个独立的实体的Hbase表，比如包含用户的表。</p>
<p>Column-based indexing treats each HBase cell as input for a single document in Solr. This approach could be used for example in a messaging platform where a single user’s messages are all stored in a single row, with each message being stored in a separate cell.</p>
<p>基于列索引方式把Hbase的一个列当作Solr的一个文档输入。这种处理可以用于消息平台，一个用户的所有消息存在同一行中，而每条消息存在一个单独的列上。</p>
<p>The default mapping-type value is row.</p>
<p>默认的mapping-type是row。</p>
<h3 id="read-row"><a href="#read-row" class="headerlink" title="read-row"></a>read-row</h3><p>The read-row attribute has two possible values: dynamic, or never.</p>
<p>read-row属性有两种值：dyamic和never。</p>
<p>This attribute is only important when using row-based indexing. It specifies whether or not the indexer should re-read data from HBase in order to perform indexing.</p>
<p>这个属性中对基于行索引的方式才是重要的。它指定索引器为了进行索引是否需要从Hbase重新读取数据。</p>
<p>When set to “dynamic”, the indexer will read the necessary data from a row if a partial update to the row is performed in HBase. In dynamic mode, the row will not be re-read if all data needed to perform indexing is included in the row update.</p>
<p>当被设置为“dynamic”时，如果HBase是一行数据的部分数据更新时，索引器会读取这一行中需要的数据。dynamic模式下，如果是一行的全部数据的更新，索引器不会重新读取Hbase的数据。</p>
<p>If this attribute is set to never, a row will never be re-read by the indexer.</p>
<p>如果这个属性被设置为never，索引器不会重读行数据。</p>
<p>The default setting is “dynamic”.</p>
<p>默认的设置是“dynamic”。</p>
<h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><p>The mapper attribute allows the user to specify a custom mapper class that will create a Solr document from a HBase Result object. The mapper class must implement the com.ngdata.hbaseindexer.parse.ResultToSolrMapper interface.</p>
<p>mapper属性允许用户指定一个自定义的类通过Hbase结果对象来创建Solr文档。但这个mapper类必需实现<code>com.ngdata.hbaseindexer.parse.ResultToSolrMapper</code>接口。</p>
<p>By default, the built-in com.ngdata.hbaseindexer.parse.DefaultResultToSolrMapper is used.</p>
<p>默认情况，使用的是内署的<code>com.ngdata.hbaseindexer.parse.DefaultResultToSolrMapper</code>。</p>
<h3 id="unique-key-formatter"><a href="#unique-key-formatter" class="headerlink" title="unique-key-formatter"></a>unique-key-formatter</h3><p>The unique-key-formatter attribute specifies the name of the class used to format HBase row keys (as well as column families and column qualifiers) as text. A textual representation of these pieces of information is needed for indexing in Solr, as all data in Solr is textual, but row keys, column families, and column qualifiers are byte arrays.</p>
<p>unique-key-formatter指定了用于格式化Hbase rowkeys（列簇和列限定符也一样）为文本的类名。在Solr中索引需要这些信息的文本表示，因为Solr中的所有数据都是文本数据，但是行键、列族和列限定符是字节数组。</p>
<p>A unique-key-formatter class must implement the com.ngdata.hbaseindexer.uniquekey.UniqueKeyFormatter interface.</p>
<p>一个unique-key-formatter类必须实现<code>com.ngdata.hbaseindexer.uniquekey.UniqueKeyFormatter</code>接口。</p>
<p>The default value of this attribute is com.ngdata.hbaseindexer.uniquekey.StringUniqueKeyFormatter. The StringUniqueKey formatter simply treats row keys and other byte arrays as strings.</p>
<p>这个属性的默认值是<code>com.ngdata.hbaseindexer.uniquekey.StringUniqueKeyFormatter</code>。StringUniqueKeyFormatter只是简单的把rowkey或者其他字节数据当成字符串。</p>
<p>If your row keys, column families, or qualifiers can’t simply be used as strings, consider using the com.ngdata.hbaseindexer.uniquekey.HexUniqueKeyFormatter.</p>
<p>如果你的rowkey，列簇，或者限定符不能简单的用字符串表示，就你需要考虑使用<code>com.ngdata.hbaseindexer.uniquekey.HexUniqueKeyFormatter</code>。</p>
<h3 id="unique-key-field"><a href="#unique-key-field" class="headerlink" title="unique-key-field"></a>unique-key-field</h3><p>This attribute specifies the name of the document identifier field used in Solr.</p>
<p>这个属性指定Solr中文档的标识字段。</p>
<p>The default value for this field is “id”.</p>
<p>默认值是“id”。</p>
<h3 id="row-field"><a href="#row-field" class="headerlink" title="row-field"></a>row-field</h3><p>The row-field attribute specifies the name of the Solr field to be used for storing an HBase row key.</p>
<p>row-field属性指定了Solr中用于存储Hbase rowkey的安段名。</p>
<p>This field is only important when doing column-based indexing. In order for the indexer to be able to delete all documents for a single row from the index, it needs to be able to find all documents for the row in Solr. When this attribute is populated in the indexer definition, it’s value is used as the name of a field in Solr to store the encoded row key.</p>
<p>这个字段对于基于列索引方式才很重要。索引器为了能够从索引中删除一行的所有文档，它一个字段能在Solr中找到该行的所有文档。在索引器定义中设置这个属性时，它的值将用作Solr中字段的名称，以存储编码的行键。</p>
<p>By default, this attribute is empty, meaning that the row key is not stored in Solr. The consequence of this is that deleting a complete row or complete column family in HBase will not delete the indexed documents in Solr.</p>
<p>默认情况，这个属性为空，这意味着rowkey不会被存储在Solr里面。这样的结果就是在Hbase中删除一个完整的行或者列并不删除Solr中的已经索引的文档。</p>
<h3 id="column-family-field"><a href="#column-family-field" class="headerlink" title="column-family-field"></a>column-family-field</h3><p>The column-family-field specifies the name of the Solr field to be used for storing the HBase column family name.</p>
<p>column-family-field指定Solr中用于存储HBase列簇名的字段名。</p>
<p>See the description of the row-field attribute for more information.</p>
<p>查看row-field属性查看更多的信息。</p>
<p>By default, this attribute is empty, so the column-family name is not saved in Solr.</p>
<p>默认情况，这个属性为空，也就是说，列簇不会被Solr存储。</p>
<h3 id="table-name-field"><a href="#table-name-field" class="headerlink" title="table-name-field"></a>table-name-field</h3><p>The table-name-field specifies the name of the Solr field to be used for storing the name of the HBase table where a record is stored.</p>
<p>table-name-field指定Solr中用于存储Hbase表名的字段名。</p>
<p>By default, this attribute is empty, so the name of the HBase table is not stored unless this setting is explicitly set in the indexer config.</p>
<p>默认情况，这个属性是空，也就是说Hbase的表名不会被存储除非在indexer节点中明确指定。</p>
<h2 id="indxer内定义的节点（Elements-within-the-indexer-definition）"><a href="#indxer内定义的节点（Elements-within-the-indexer-definition）" class="headerlink" title="indxer内定义的节点（Elements within the indexer definition）"></a>indxer内定义的节点（Elements within the indexer definition）</h2><p>There are three types of elements that can be used within an indexer configuration: <field>, <extract>, and <param>.</p>
<p>在indexer节点有三种类型的节点：<field>, <extract>和<param></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><field></h3><p>The field element defines a single field to be indexed in Solr, as well as where its contents are to be taken from and interpreted from HBase. There are typically one or more fields listed in an indexer configuration – one for each Solr field to be stored.</p>
<p>field节点定义了要在Solr中索引的单个字段，以及要从Hbase获取和解析的内容。索引器配置中通常列出一个或多个字段——每个Solr字段都要存储一个字段。</p>
<p>The field attribute has four attributes, listed below.</p>
<p>field有如下的四个属性。</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>The name attribute specifies the name of a Solr field in which to store data. A field with a matching name should be defined in the Solr schema.</p>
<p>name属性指定了Solr的中存储数据的字段名。这个字段需要在Solr的Schema中有匹配的字段名。</p>
<p>The name attribute is mandatory.</p>
<p>name属性是必须的。</p>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>The value attribute specifies the data to be used from HBase for populating the field in Solr. It takes the form of a column family name and qualifier, separated by a colon.</p>
<p>value属性指定了Hase用于填充Solr字段的数据。它采用列族名和限定符的形式，用冒号分隔。</p>
<p>The qualifier portion can end in an asterisk, which is interpreted as a wildcard. In this case, all matching column-family and qualifier expressions will be used.</p>
<p>限定符部分可以星号结尾，该星号被解释为通配符。在这种情况下，将使用所有匹配的列族表达式和限定符表达式。</p>
<p>The following are examples of valid value attributes:</p>
<p>以下是有效值属性的示例：</p>
<ul>
<li>mycolumnfamily:myqualifier</li>
<li>mycolumnfamily:my*</li>
<li>mycolumnfamily:*</li>
</ul>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>The source attribute determines what portion of an HBase KeyValue will be used as indexing content.</p>
<p>Source属性确定HBASE KeyValue的哪个部分将用作索引内容。</p>
<p>It has two possible values: value and qualifier.、</p>
<p>它有两个可能的值：value和qualifier。</p>
<p>When value is specified (which is the case by default), then the cell value is used as input for indexing.</p>
<p>当指定值时(默认情况下是这种情况)，则使用单元格值作为索引的输入。</p>
<p>When qualifier is specified, then the column qualifier is used as input for indexing.</p>
<p>当指定限定符时，列限定符将用作索引的输入。</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>The type attribute defines the datatype of the content in HBase.</p>
<p>type属性定义HBASE中内容的数据类型。</p>
<p>Because all data is stored in HBase as byte arrays, but all content in Solr is indexed as text, a method for converting from byte arrays to the actual datatype is needed.</p>
<p>因为所有数据都以字节数组的形式存储在HBASE中，但是Solr中的所有内容都被索引为文本，所以需要一个方法将字节数组转换为实际的数据类型。</p>
<p>The value of this field can be one of any of the datatypes supported by the HBase Bytes class: int, long, string, boolean, float, double, short, or bigdecimal.</p>
<p>该字段的值可以是HBASE Bytes类支持的任何数据类型之一：int、long、string、boole、Float、Double、Short或Big十进制。</p>
<p>If the Bytes-based representation has not been used for storing data in HBase, the name of a custom class can be specified for this attribute. The custom class must implement the com.ngdata.hbaseindexer.parse.ByteArrayValueMapper interface.</p>
<p>如果没有使用基于Bytes的表示形式在HBASE中存储数据，则可以为该属性指定自定义类的名称。自定义类必须实现com.ngdata.hbaseindexer.parse.ByteArrayValueMapper接口。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><param></h3><p>The <param> element defines a key-value pair that will be supplied to custom classes that implement the com.ngdata.hbaseindexer.Configurable interface.</p>
<param>节点定义了一个键值对，它将提供给实现com.ngdata.hbase indexer.Configable接口的自定义类。

<param> elements can also be nested in a <field> element.

<param>元素也可以嵌套在<field>元素中。

<p>The element has two attributes: name and value. Both are mandatory.</p>
<p>访节点有两个属性：name和value。两者都是必须的。</p>
<h2 id="配置样例（Example-configuration）"><a href="#配置样例（Example-configuration）" class="headerlink" title="配置样例（Example configuration）"></a>配置样例（Example configuration）</h2><p>The example configuration below demonstrates all elements and attributes that can be used to configure an indexer.</p>
<p>下面的示例配置演示了可用于配置索引器的所有元素和属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   Do row-based indexing on table "table1", never re-reading updated content.</span></span><br><span class="line"><span class="comment">   Store the unique document id in Solr field called "custom-id".</span></span><br><span class="line"><span class="comment">   Additionally store the row key in a Solr field called "custom-row", and store the </span></span><br><span class="line"><span class="comment">   column family in a Solr field called "custom-family".</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">   Perform conversion of byte array keys using the class "com.mycompany.MyKeyFormatter".</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">indexer</span></span></span><br><span class="line"><span class="tag">    <span class="attr">table</span>=<span class="string">"table1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">mapping-type</span>=<span class="string">"row"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">read-row</span>=<span class="string">"never"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">unique-key-field</span>=<span class="string">"custom-id"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">row-field</span>=<span class="string">"custom-row"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">column-family-field</span>=<span class="string">"custom-family"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">table-name-field</span>=<span class="string">"custom-table"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">unique-key-formatter</span>=<span class="string">"com.mycompany.MyKeyFormatter"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- A float-based field taken from any qualifier in the column family "colfam" --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"field1"</span> <span class="attr">value</span>=<span class="string">"colfam:*"</span> <span class="attr">source</span>=<span class="string">"qualifier"</span> <span class="attr">type</span>=<span class="string">"float"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"globalKeyA"</span> <span class="attr">value</span>=<span class="string">"globalValueA"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"globalKeyB"</span> <span class="attr">value</span>=<span class="string">"globalValueB"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://cloudera.github.io/cdk/docs/0.8.0/cdk-morphlines/index.html" target="_blank" rel="noopener">morphlines</a><br><img src="http://cloudera.github.io/cdk/docs/0.8.0/cdk-morphlines/images/morphlines-architecture.jpg" alt="morphlines-architecture"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/hbase/hbase-indexer/getting-start-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/hbase/hbase-indexer/getting-start-tutorial/" class="post-title-link" itemprop="url">Hbase Indexer - 教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-12-05 12:33:00 / 修改时间：16:05:24" itemprop="dateCreated datePublished" datetime="2018-12-05T12:33:00+08:00">2018-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>This page explains how to start doing basic indexing in HBase. Before following this tutorial, make sure that the HBase Indexer and other required software is installed and running as explained in the <a href="https://github.com/NGDATA/hbase-indexer/wiki/Installation" target="_blank" rel="noopener">installation instructions</a>.</p>
<p>这篇解释如何在Hbase中开始基础索引。在开始教程之前，请确保Hbase Indexer和其他需要的软件已经<a href="">安装</a>和运行。</p>
<p>At this point, HBase and Solr (in cloud mode) should be running, and the HBase Indexer should be unpacked in a directory (which we’ll call $INDEXER_HOME). For this tutorial, it is assumed that the default example index schema is being used by Solr (as explained on the <a href="https://github.com/NGDATA/hbase-indexer/wiki/Installation" target="_blank" rel="noopener">installation page</a>).</p>
<p>此时，Hbasa和Solr（云模式）已经行行，并且Hbase Indexer已经解压到一个目录中（这是我们称为<code>$INDEXER_HOME</code>）。在这个教程中，我们假设用的是Solr的默认example索引（就像<a href="https://github.com/NGDATA/hbase-indexer/wiki/Installation" target="_blank" rel="noopener">安装</a>中说的那样）。</p>
<h2 id="启动Hbase-Indexer（Start-the-HBase-Indexer-daemon）"><a href="#启动Hbase-Indexer（Start-the-HBase-Indexer-daemon）" class="headerlink" title="启动Hbase Indexer（Start the HBase Indexer daemon）"></a>启动Hbase Indexer（Start the HBase Indexer daemon）</h2><p>In a terminal, execute the following (assuming $INDEXER_HOME points to the directory where the hbase-indexer tar.gz distribution was unpacked).</p>
<p>在终端中，运行如下命令（假定<code>$INDEXER_HOME</code>指向hbase-indexer tar.gz解压的目录）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $INDEXER_HOME</span><br><span class="line">.&#x2F;bin&#x2F;hbase-indexer server</span><br></pre></td></tr></table></figure>

<h2 id="创建需要索引的表（Create-a-table-to-be-indexed-in-HBase）"><a href="#创建需要索引的表（Create-a-table-to-be-indexed-in-HBase）" class="headerlink" title="创建需要索引的表（Create a table to be indexed in HBase）"></a>创建需要索引的表（Create a table to be indexed in HBase）</h2><p>In the HBase shell, create a table. For this tutorial, we’ll create a table named “indexdemo-user”, with a single column family named “info”. Note that the <code>REPLICATION_SCOPE</code> of the column family of the table must be set to 1.</p>
<p>在Hbase shell，创建一个表。在这里，我们创建一个“indexdemo-user”的表，有一个“info”的列簇。注意列簇的<code>REPLICATION_SCOPE</code>必须设置成1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hbase shell</span><br><span class="line">hbase&gt; create &#39;indexdemo-user&#39;, &#123; NAME &#x3D;&gt; &#39;info&#39;, REPLICATION_SCOPE &#x3D;&gt; &#39;1&#39; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加索引器（Add-an-indexer）"><a href="#添加索引器（Add-an-indexer）" class="headerlink" title="添加索引器（Add an indexer）"></a>添加索引器（Add an indexer）</h2><p>Now we’ll create an indexer that will index the the indexdemo-user table as its contents are updated.</p>
<p>现在我们创建一个索引器，在indexdemo-user表的内容被更新是他会进行索引。</p>
<p>In your favourite text editor, create a new xml file called indexdemo-indexer.xml, with the following content:</p>
<p>用你喜欢的编辑器，创建一个新的xml文件，命名为<code>indexdemo-indexer.xml</code>，添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">indexer</span> <span class="attr">table</span>=<span class="string">"indexdemo-user"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"firstname_s"</span> <span class="attr">value</span>=<span class="string">"info:firstname"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"lastname_s"</span> <span class="attr">value</span>=<span class="string">"info:lastname"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"age_i"</span> <span class="attr">value</span>=<span class="string">"info:age"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>The above file defines three pieces of information that will be used for indexing, how to interpret them, and how they will be stored in Solr.</p>
<p>上面的文件定义了三个索引字段的信息，如何解析，如何在Solr中存储。</p>
<p>Next, create an indexer based on the created indexer xml file.</p>
<p>接下来，基于xml文件创建一个索引器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;hbase-indexer add-indexer -n myindexer -c indexdemo-indexer.xml \</span><br><span class="line">        -cp solr.zk&#x3D;localhost:2181&#x2F;solr -cp solr.collection&#x3D;collection1</span><br></pre></td></tr></table></figure>

<p>Note that the above command assumes that ZooKeeper is running on localhost on port 2181, and that there is a Solr Core called “collection1” configured. If you are doing this tutorial on an existing HBase/Solr environment, you may need to use different settings.</p>
<p>注意上面的命令假设，ZooKeeper运行要本机的2181端口上，并且Solr Core已经创建了一个名为“collection1”的索引。如果你在一个现有的Hbase/Solr环境运行本教程，你需要修改配置。</p>
<h2 id="更新表内容（Update-the-table-content）"><a href="#更新表内容（Update-the-table-content）" class="headerlink" title="更新表内容（Update the table content）"></a>更新表内容（Update the table content）</h2><p>In the HBase shell, try adding some data to the indexdemo-user table<br>在Hbase shell中，尝试给<code>indexdemo-user</code>添加一些数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; put &#39;indexdemo-user&#39;, &#39;row1&#39;, &#39;info:firstname&#39;, &#39;John&#39;</span><br><span class="line">hbase&gt; put &#39;indexdemo-user&#39;, &#39;row1&#39;, &#39;info:lastname&#39;, &#39;Smith&#39;</span><br></pre></td></tr></table></figure>
<p>After adding this data, take a look in Solr (i.e. <a href="http://localhost:8983/solr/#/collection1/query" target="_blank" rel="noopener">http://localhost:8983/solr/#/collection1/query</a>). You should see a single document in Solr that has the firstname_s field set to “John”, and the lastname_s field set to “Smith”.</p>
<p>添加数据之后，来看一下Solr（i.e. <a href="http://localhost:8983/solr/#/collection1/quer），你应该能看到一个文档，这个文档的firstname_s字段值为“John”，同时lastname_s字段值为“Smith”。" target="_blank" rel="noopener">http://localhost:8983/solr/#/collection1/quer），你应该能看到一个文档，这个文档的firstname_s字段值为“John”，同时lastname_s字段值为“Smith”。</a></p>
<p>Note If you don’t have autoCommit enabled in Solr, you won’t be able to see the updated contents immediately in Solr. The demo environment has autoCommit enabled for a commit every second.</p>
<p><strong>注意</strong>如果没有开启<code>autoCommit</code>，你不会马上在Solr看到更新的内容。这例子的环境<code>autoCommit</code>已经开启并设置为每秒自动提交1次。</p>
<p>Now try updating the data you’ve just added</p>
<p>现在尝试更新你刚才添加的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; put &#39;indexdemo-user&#39;, &#39;row1&#39;, &#39;info:firstname&#39;, &#39;Jim&#39;</span><br></pre></td></tr></table></figure>
<p>And now check the content in Solr. The document’s firstname_s field now contains the string “Jim”.</p>
<p>然后在Solr有检查内容。看下文档的firstname_s是不是变成了“Jim”</p>
<p>Finally, delete the row from HBase.</p>
<p>最后，删除Hbase的这条记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; deleteall &#39;indexdemo-user&#39;, &#39;row1&#39;</span><br></pre></td></tr></table></figure>

<p>You can now verify that the data has been deleted from Solr.</p>
<p>你可以验证下Solr中的数据是不是已经删除了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/hbase/hbase-indexer/getting-start-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/hbase/hbase-indexer/getting-start-install/" class="post-title-link" itemprop="url">Hbase Indexer - 安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-12-05 12:32:00 / 修改时间：14:27:17" itemprop="dateCreated datePublished" datetime="2018-12-05T12:32:00+08:00">2018-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>This page explains how to do a basic installation of the HBase Indexer on a single machine.</p>
<p>这篇会讲解如何在单机中进行Hbase Indexer的基础安装。</p>
<p>Before you start, make sure that you have the <a href="https://github.com/NGDATA/hbase-indexer/wiki/Requirements" target="_blank" rel="noopener">required software</a> installed (they can all be running on single machine).</p>
<p>在开始之前，请确认你已经安装了所有需要的软件（他们可以都可以在单机运行）。</p>
<h2 id="获取Hbase-Indexer（Get-the-HBase-Indexer）"><a href="#获取Hbase-Indexer（Get-the-HBase-Indexer）" class="headerlink" title="获取Hbase Indexer（Get the HBase Indexer）"></a>获取Hbase Indexer（Get the HBase Indexer）</h2><p>Check out the code and build the tar.gz distribution.</p>
<p>签出代码并生成tar.gz的发布包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;NGDATA&#x2F;hbase-indexer.git</span><br><span class="line">mvn clean package -Pdist -DskipTests</span><br></pre></td></tr></table></figure>

<p>Next, unpackage the tar.gz distribution (in the example below it is unpacked under your $HOME directory).</p>
<p>接下来，解压tar.gz发布包（这个例子中，他被解压到<code>$HOME</code>目录）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf hbase-indexer-dist&#x2F;target&#x2F;hbase-indexer-1.0-SNAPSHOT.tar.gz -C ~</span><br><span class="line">cd ~&#x2F;hbase-indexer-1.0-SNAPSHOT</span><br></pre></td></tr></table></figure>

<h2 id="配置Hbase-Indexer（Configure-HBase-Indexer）"><a href="#配置Hbase-Indexer（Configure-HBase-Indexer）" class="headerlink" title="配置Hbase Indexer（Configure HBase Indexer）"></a>配置Hbase Indexer（Configure HBase Indexer）</h2><p>In the hbase-indexer directory, edit the file <code>conf/hbase-indexer-site.xml</code> and configure the ZooKeeper connection string (twice, once for hbase-indexer, and once for hbase, alternatively you can copy your <code>hbase-site.xml</code>to the conf directory).</p>
<p>在<code>hbase-indexer</code>目录，编辑<code>conf/hbase-indexer-site.xml</code> 文件并配置ZooKeeper的连接串（两次，一次用于hbase-indexer,一次用于Hbase，或者你可以拷贝你的<code>hbase-site.xml</code>到你的<code>conf</code>目录）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbaseindexer.zookeeper.connectstring<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>zookeeperhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>zookeeperhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>If you have not defined <code>JAVA_HOME</code> globally, and the <code>bin/hbase-indexer</code> script would complain it doesn’t find you Java, you can set the JAVA_HOME in the script <code>conf/hbase-indexer-env.sh</code>.</p>
<p>如果你没有定义全局的<code>JAVA_HOME</code>，<code>bin/hbase-indexer</code>脚本会报没有找到Java，你可以通过运行<code>conf/hbase-indexer-env.sh</code>来设置<code>JAVA_HOME</code>。</p>
<h2 id="配置Hbase（Configure-HBase）"><a href="#配置Hbase（Configure-HBase）" class="headerlink" title="配置Hbase（Configure HBase）"></a>配置Hbase（Configure HBase）</h2><p>In order to use the HBase Indexer, <a href="http://hbase.apache.org/replication.html" target="_blank" rel="noopener">replication</a> must be enabled in HBase. There are also a number of other HBase settings that can be set to optimize the working of the HBase indexer.</p>
<p>为了运行Hbase Indexer，<a href="http://hbase.apache.org/replication.html" target="_blank" rel="noopener">复制集</a>必须开启。同时还有一些HBase的设置需要配置以便优代Hbase Indexer的运行。</p>
<p>Add the settings below to your hbase-site.xml configuration on all HBase region servers, and restart HBase.<br>所有的分区服务上的<code>hbase-site.xml</code>添加如下配置，然后重启Hbase。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SEP is basically replication, so enable it --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Source ratio of 100% makes sure that each SEP consumer is actually</span></span><br><span class="line"><span class="comment">       used (otherwise, some can sit idle, especially with small clusters) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>replication.source.ratio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Maximum number of hlog entries to replicate in one go. If this is</span></span><br><span class="line"><span class="comment">       large, and a consumer takes a while to process the events, the</span></span><br><span class="line"><span class="comment">       HBase rpc call will time out. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>replication.source.nb.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- A custom replication source that fixes a few things and adds</span></span><br><span class="line"><span class="comment">       some functionality (doesn't interfere with normal replication</span></span><br><span class="line"><span class="comment">       usage). --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>replication.replicationsource.implementation<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.ngdata.sep.impl.SepReplicationSource<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加Indexer-jar到HBase（Add-indexer-jars-to-HBase）"><a href="#添加Indexer-jar到HBase（Add-indexer-jars-to-HBase）" class="headerlink" title="添加Indexer jar到HBase（Add indexer jars to HBase）"></a>添加Indexer jar到HBase（Add indexer jars to HBase）</h2><p>The HBase Indexer includes two jar files that need to be in the classpath of HBase. Copy these from the lib directory of the unpacked hbase-indexer installation into the lib directory of HBase for each region server.</p>
<p>Hbase Indexer包含两个jar文件需要在Hbase的类目录下。将解压目录hbase-indexer下的lib中的这些文件拷贝到所有Hbase分区服务器的lib目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp lib&#x2F;hbase-sep-* $HBASE_HOME&#x2F;lib</span><br></pre></td></tr></table></figure>
<h2 id="启动Solr（Start-Solr）"><a href="#启动Solr（Start-Solr）" class="headerlink" title="启动Solr（Start Solr）"></a>启动Solr（Start Solr）</h2><p>Ensure that Solr is running. In general, it’s easiest to have Solr use the same ZooKeeper instance as HBase.</p>
<p>确保Solr已经运行。通常，很容易让Hbase和Solr共用相同的ZooKeeper。</p>
<p>Assuming that you’ve downloaded Solr 4.2.0 and you’re running ZooKeeper on the current machine, you can start up the base Solr in cloud mode using the example schema as follows:</p>
<p>假设你已经下载了Solr 4.2.0并且ZooKeeper运行在当前机器，你可能通过下列脚本在云模式运行Solr。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $SOLR_HOME&#x2F;example</span><br><span class="line">java -Dbootstrap_confdir&#x3D;.&#x2F;solr&#x2F;collection1&#x2F;conf -Dcollection.configName&#x3D;myconf -DzkHost&#x3D;localhost:2181&#x2F;solr  -jar start.jar</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/hbase/hbase-indexer/getting-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/hbase/hbase-indexer/getting-start/" class="post-title-link" itemprop="url">Hbase Indexer - 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-12-05 12:31:00 / 修改时间：15:38:41" itemprop="dateCreated datePublished" datetime="2018-12-05T12:31:00+08:00">2018-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="构建（Building-the-binary-distribution）"><a href="#构建（Building-the-binary-distribution）" class="headerlink" title="构建（Building the binary distribution）"></a>构建（Building the binary distribution）</h2><p>Use the following command to build the binary distribution (.tar.gz &amp; rpm):</p>
<p>使用如下命令构建生成二进制发布包（.tar.gz &amp; rpm）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -DskipTests -Pdist install</span><br></pre></td></tr></table></figure>

<h2 id="测试（Testing）"><a href="#测试（Testing）" class="headerlink" title="测试（Testing）"></a>测试（Testing）</h2><p>These steps assume a running HBase 0.94.x installation (preferably CDH 4.2), as well as a running Solr installation. For this example, the configured Solr schema will need to have a multi-valued field called “data”, as well as a unique key field called “id”.</p>
<p>以下这此步骤假定已经安装了Hbase 0.94.x(最好是CDH 4.2)和Solr。在这个例子中，Solr的映射，需要配置多值字段“data”和唯一键字段“id”。</p>
<ol>
<li><p>Enable replication and other settings that are outlined in the <a href="https://github.com/NGDATA/hbase-indexer/blob/master/hbase-sep/hbase-sep-demo/README.md" target="_blank" rel="noopener">hbase-sep demo instructions</a></p>
</li>
<li><p>按<a href="https://github.com/NGDATA/hbase-indexer/blob/master/hbase-sep/hbase-sep-demo/README.md" target="_blank" rel="noopener">hbase-sep demo instructions</a>的配置复制集和其他设置。</p>
</li>
<li><p>Unzip the binary distribution (instructions for creating the binary distribution are listed above).</p>
</li>
<li><p>解压发布包（生成发布包的方式已经在上文列出）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf hbase_indexer.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>Copy the hbase-sep jar files from the lib directory of the binary distribution into the lib directory of HBase.</p>
</li>
<li><p>将发布包下的lib目录的hbase-sep jar文件拷贝到Hbase的lib目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd hbase_indexer</span><br><span class="line">$ sudo cp lib&#x2F;hbase-sep-* &#x2F;usr&#x2F;lib&#x2F;hbase&#x2F;lib</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create a table in HBase that has replication enabled. For this example, we’ll create a table called “record” with a single column family called ‘data’.</p>
</li>
<li><p>创建一个开启复制集功能的表。这个例子中，我们会创建“record”表，有一个列簇“data”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; create &#39;record&#39;, &#123;NAME &#x3D;&gt; &#39;data&#39;, REPLICATION_SCOPE &#x3D;&gt; 1&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Start the hbase-indexer server</p>
</li>
<li><p>启动hbase-indexer服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;bin&#x2F;hbase-indexer server</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create an indexer definition. For this example, we’ll just index anything in the data column family into the “data” field in Solr. Save the below contents in a file called ‘sample.xml’.</p>
</li>
<li><p>创建索引器定义。在这个例子中，我们只是把data列簇中所有内容都放到Solr的“data”字段中进行索引。将以下内容保存为”sample.xml”。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">indexer</span> <span class="attr">table</span>=<span class="string">"record"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"data"</span> <span class="attr">value</span>=<span class="string">"data:*"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Add the indexer definition to the indexer server. The following command assumes that the Solr ZooKeeper is running on the current host, and the name of the collection to be used for indexing is “core0”.</p>
</li>
<li><p>把索引定义添加到inderxer服务中。下面的命令假设Solr ZooKeeper运行在当前的主机中，并且用于索引的集合名为“core0”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;bin&#x2F;hbase-indexer add-indexer  -n sampleindex -c sample.xml --cp solr.collection&#x3D;core0</span><br></pre></td></tr></table></figure></li>
<li><p>Add some data to the record table in HBase. The data added to the data column family in the record table should show up in the Solr index.</p>
</li>
<li><p>向Hbase的recode表添加一些数据。添加到record表中的数据应该会出现在Solr的索引中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; put &#39;record&#39;, &#39;row1&#39;, &#39;data:value&#39;, &#39;Test of HBase Indexer&#39;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/hbase/hbase-indexer/requirements/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/hbase/hbase-indexer/requirements/" class="post-title-link" itemprop="url">Hbase Indexer - 要求</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-12-05 12:30:00 / 修改时间：11:50:08" itemprop="dateCreated datePublished" datetime="2018-12-05T12:30:00+08:00">2018-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>The following software is required for running the HBase Indexer:</p>
<p>运行Hbase Indexer需要下面的这些软件:</p>
<ul>
<li>HBase 0.94.x</li>
<li>Solr 4.x in cloud mode</li>
<li>ZooKeeper 3.x (required by the two above packages)</li>
</ul>
<p>All components can be run on a single machine, or they can be run on multiple machines on a cluster.</p>
<p>所有的组件可以运行在单机，也可运行在多台机器的集群上。</p>
<h2 id="详情（Details）"><a href="#详情（Details）" class="headerlink" title="详情（Details）"></a>详情（Details）</h2><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase 0.94.x is the supported version of HBase for the HBase Indexer. It is recommended to use the version of HBase 0.94.2 that is bundled with Cloudera CDH 4.2. However, other versions of HBase 0.94.x may also work. CDH 4.2 is currently used for testing.</p>
<p>Hbase 0.94.x是Hbase Indexer支持的版本。推荐使用Cloudera CDH 4.2附带的HBase 0.94.2版本。尽管，其他的0.94.x版本也能正常工作，但CDH 4.2被用于当前的测试。</p>
<p>HBase should be configured to use HDFS as its filesystem – HBase Indexer is not fully functional if the local filesystem implementation is used instead of HDFS.</p>
<p>Hbase要配置HDFS做为它的文件系统，如果使用本地文件系统而不是HDFS，HBase Indexer就不行完全运行了。</p>
<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p>Solr 4.x is required for the HBase Indexer, and it must be configured to run in cloud mode. Solr 4.2.0 is currently used for development testing.</p>
<p>Hbase Indexer 需要Solr 4.x版本，并且要求配置在云模式下运行。Solr 4.2.0是当并开发测试的版本。</p>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>It is recommended that the version of ZooKeeper that is bundled in CDH 4.2 is used.</p>
<p>推荐使用和CDH4.2附带的ZooKeeper版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/hbase/hbase-indexer/home/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/hbase/hbase-indexer/home/" class="post-title-link" itemprop="url">Hbase Index - 首页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-12-05 12:20:00 / 修改时间：11:50:45" itemprop="dateCreated datePublished" datetime="2018-12-05T12:20:00+08:00">2018-12-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介（Introduction）"><a href="#简介（Introduction）" class="headerlink" title="简介（Introduction）"></a>简介（Introduction）</h2><p>The HBase Indexer project provides indexing (via <a href="http://lucene.apache.org/solr/" target="_blank" rel="noopener">Solr</a>) for content stored in <a href="http://hbase.apache.org/" target="_blank" rel="noopener">HBase</a>. It provides a flexible and extensible way of defining indexing rules, and is designed to scale.</p>
<p>Hbase Indexer项目可以为存储在HBase中的内容提供<a href="http://lucene.apache.org/solr/" target="_blank" rel="noopener">Solr</a>索引。它提供灵活的可扩展的方式来定义索引规则，且为大规模而生。</p>
<p>Indexing is performed asynchronously, so it does not impact write throughput on HBase. SolrCloud is used for storing the actual index in order to ensure scalability of the indexing.</p>
<p>索引是异步的，所以不会影响Hbase的写入吞吐量。SolrCloud用于存储实际的索引，以确保索引的可伸缩性。</p>
<h2 id="开始使用Hbase-Indexer（Getting-started-with-the-HBase-Indexer）"><a href="#开始使用Hbase-Indexer（Getting-started-with-the-HBase-Indexer）" class="headerlink" title="开始使用Hbase Indexer（Getting started with the HBase Indexer）"></a>开始使用Hbase Indexer（Getting started with the HBase Indexer）</h2><ol>
<li><p>Make sure you’ve got the required software installed, as detailed on the <a href="https://github.com/NGDATA/hbase-indexer/wiki/Requirements" target="_blank" rel="noopener">Requirements</a> page.</p>
</li>
<li><p>Follow the Tutorial to get a feel for how to use the HBase Indexer.</p>
</li>
<li><p>Customize your indexing setup as needed using the other reference documentation provided here.</p>
</li>
<li><p>确认所有要求的软件已经安装，具体内容在[要求]页。</p>
</li>
<li><p>按照教程来体验下如何使用Hbase Indexer。</p>
</li>
<li><p>通过提供的文档来调整索引的配置。</p>
</li>
</ol>
<h2 id="工作原理（How-it-works）"><a href="#工作原理（How-it-works）" class="headerlink" title="工作原理（How it works）"></a>工作原理（How it works）</h2><p>The HBase Indexer works by acting as an HBase replication sink. As updates are written to HBase region servers, they are “replicated” asynchronously to the HBase Indexer processes.</p>
<p>Hbase Indxer扮演了Hbase复制集的角色。当数据写入Hbase的分区时，数据被异步的“复制”给Hbase Indexer处理器。</p>
<p>The indexer analyzes incoming HBase mutation events, and where applicable it creates Solr documents and pushes them to SolrCloud servers.</p>
<p>Hbase Indexer分析从Hbase发送过来的变化事件，当合适的时候创建Solr文档并发送给SolrCloud服务器。</p>
<p>The indexed documents in Solr contain enough information to uniquely identify the HBase row that they are based on, allowing you to use Solr to search for content that is stored in HBase.</p>
<p>Solr文档维护了足够多的信息用于唯一标识一条Hbase记录，这样允许你可能通过Solr来检索Hbase内容。</p>
<p>HBase replication is based on reading the HBase log files, which are the precise source of truth of the what is stored in HBase: there are no missing or no extra events. In various cases, the log also contains all the information needed to index, so that no expensive random-read on HBase is necessary (see the <code>read-row</code>attribute in the <a href="https://github.com/NGDATA/hbase-indexer/wiki/Indexer-configuration" target="_blank" rel="noopener">Indexer Configuration</a>).</p>
<p>HBase复制集是通过读取Hbase的日志文件，这些日志文件是HBASE中存储内容的精确来源：没有遗漏也没有额外的事件。在大多数情况下，日志含了索引需要的全部信息，因此不需要对Hbase进行昂贵的随机读取。（在[Indexer配置]中可查看<code>read-row</code>属性）。</p>
<p>HBase replication delivers (small) batches of events. HBase-indexer exploits this by avoiding double-indexing of the same row if it would have been updated twice in a short time frame, and as well will batch/buffer the updates towards Solr, which gives important performance gains. The updates are applied to Solr before confirming the processing of the events to HBase, so that no event loss is possible.</p>
<p>Hbase复制集（小规模）批量分发事件。Hbase indexer利用这一特性用于避免在一个很小的时间窗口期一条记录被更新两次而引起重复索引，也通过批量/缓存的方式来更新Solr，这样可以获得更好的性能。所有的更新会在Hbase处理确认之前更新到Solr中，因此不会出现丢失数据的情况。</p>
<h2 id="横向扩展（Horizontal-scalability）"><a href="#横向扩展（Horizontal-scalability）" class="headerlink" title="横向扩展（Horizontal scalability）"></a>横向扩展（Horizontal scalability）</h2><p>All information about indexers is stored in ZooKeeper. New indexer hosts can always be added to a cluster, in the same way that HBase regionservers can be added to to an HBase cluster.</p>
<p>所有的索引信息都是保存在ZooKeeper中的。新的Indexer主机可以被添加为一个集群中，就像Hbase的分区服务器被添加到Hbase集群一样。</p>
<p>All indexing work for a single configured indexer is shared over all machines in the cluster. In this way, adding additional indexer nodes allows horizontal scaling.</p>
<p>同一索引配置的所有索引工作被分配给集群中的所有机器。这样说来，添加额外的索引节点就可以横向扩展。</p>
<h2 id="自动的错误处理（Automatic-failure-handling）"><a href="#自动的错误处理（Automatic-failure-handling）" class="headerlink" title="自动的错误处理（Automatic failure handling）"></a>自动的错误处理（Automatic failure handling）</h2><p>The HBase replication system upon which the HBase Indexer is based is designed to handle hardware failures. Because the HBase Indexer is based on this system, it also benefits from the same ability to handle failures.</p>
<p>Hbase复制集系统为硬件错误处理做了设计。Hbase Indexer其于此系统，因此也从中获得了错误处理的能力。</p>
<p>In general, indexing nodes going down or Solr nodes going down will not result in any lost data in the HBase Indexer.</p>
<p>通常情况，索引节点或者Solr宕机不会导致Hbase Indexer中的数据丢失。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/29/hbase/hbase-indexer/loss-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/29/hbase/hbase-indexer/loss-data/" class="post-title-link" itemprop="url">Hbase同步Solr数据缺失问题验证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-11-29 13:30:00 / 修改时间：13:57:47" itemprop="dateCreated datePublished" datetime="2018-11-29T13:30:00+08:00">2018-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司使用Hbase indexer做二级索引，最近在做数据统计时发现，数据存在有缺失的情况。在网上查找时发现可能是Hbase Indexer的一个BUG，详情看<a href="https://www.cnblogs.com/kekukekro/p/6340922.htm" target="_blank" rel="noopener">这里</a>。大意是说修改read-row=”never”或者修改源码。我们使用的组件不是完全开源的Hbase Indexer，有被提供商做了部分调整，为了保险起见，自己还是做了一次测试。同时也是进一步了解Hbase和Habse Indexer的机会。</p>
<h1 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h1><ol>
<li>把ES的qc索引做为数据来源，数据量比较大</li>
<li>写测试程序从ES拉数据，100万条。</li>
<li>调整不同的read-row方式</li>
<li>修改程序验证部分更新。<h1 id="验证准备"><a href="#验证准备" class="headerlink" title="验证准备"></a>验证准备</h1><h2 id="创建Hbase表"><a href="#创建Hbase表" class="headerlink" title="创建Hbase表"></a>创建Hbase表</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create <span class="string">'qc'</span>,&#123;NAME =&gt;<span class="string">'d'</span>, REPLICATION_SCOPE =&gt;1&#125;</span><br></pre></td></tr></table></figure>
此处需要，注意设置REPLICATION_SCOPE为1，第一次验证时未开启。如果未开启的情况，可以进行如下操作：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> <span class="string">'qc'</span></span><br><span class="line">alter <span class="string">'qc'</span>,&#123;NAME =&gt;<span class="string">'d'</span>, REPLICATION_SCOPE =&gt;1&#125;</span><br><span class="line"><span class="built_in">enable</span> <span class="string">'qc'</span></span><br></pre></td></tr></table></figure>
<h2 id="配置Hbase-Indexer"><a href="#配置Hbase-Indexer" class="headerlink" title="配置Hbase Indexer"></a>配置Hbase Indexer</h2>之前已经有配置，拷贝一份及可<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /opt/morphline_config</span><br><span class="line">cp -a xyz.xml qc.xml</span><br><span class="line">cp -a xyz.conf qc.conf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="修改qc-xml"><a href="#修改qc-xml" class="headerlink" title="修改qc.xml"></a>修改qc.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">indexer</span> <span class="attr">table</span>=<span class="string">"qc"</span> <span class="attr">unique-key-field</span>=<span class="string">"rowkey"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">unique-key-formatter</span>=<span class="string">"com.ngdata.hbaseindexer.uniquekey.StringUniqueKeyFormatter"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">mapper</span>=<span class="string">"com.ngdata.hbaseindexer.morphline.MorphlineResultToSolrMapper"</span> <span class="attr">read-row</span>=<span class="string">"never"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"morphlineFile"</span> <span class="attr">value</span>=<span class="string">"/opt/morphline_config/qc.conf"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="修改qc-conf"><a href="#修改qc-conf" class="headerlink" title="修改qc.conf"></a>修改qc.conf</h3><p>可以把文件下载回来修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz qc.conf</span><br></pre></td></tr></table></figure>
<p>通过’rz’可以上传修改后的配置文件。</p>
<h4 id="调整后的qc-conf"><a href="#调整后的qc-conf" class="headerlink" title="调整后的qc.conf"></a>调整后的qc.conf</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">morphlines : [</span><br><span class="line">  &#123;</span><br><span class="line">    id : morphline1</span><br><span class="line">    importCommands : ["org.kitesdk.morphline.**", "com.ngdata.**"]</span><br><span class="line"></span><br><span class="line">    commands : [</span><br><span class="line">        &#123;</span><br><span class="line">                extractHBaseCells &#123;</span><br><span class="line">                  mappings : [</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:_id"</span><br><span class="line">                                outputField : "_id"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:code"</span><br><span class="line">                                outputField : "code"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:errorCode"</span><br><span class="line">                                outputField : "errorCode"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:errorMsg"</span><br><span class="line">                                outputField : "errorMsg"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:eventNo"</span><br><span class="line">                                outputField : "eventNo"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:eventTime"</span><br><span class="line">                                outputField : "eventTime"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:orgCode"</span><br><span class="line">                                outputField : "orgCode"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:patientId"</span><br><span class="line">                                outputField : "patientId"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:receiveTime"</span><br><span class="line">                                outputField : "receiveTime"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:rowKey"</span><br><span class="line">                                outputField : "rowKey"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:table"</span><br><span class="line">                                outputField : "table"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:value"</span><br><span class="line">                                outputField : "value"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : "d:version"</span><br><span class="line">                                outputField : "version"</span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : true</span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;                                          </span><br><span class="line">                        ]		</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123; logTrace &#123; format : "output record: &#123;&#125;", args : ["@&#123;&#125;"] &#125; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="添加映射"><a href="#添加映射" class="headerlink" title="添加映射"></a>添加映射</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase-indexer add-indexer -c qc.xml -n qc -z node1,node3,node2  -cp solr.zk=node1:2181,node3:2181,node2:2181/solr -cp solr.collection=qc</span><br></pre></td></tr></table></figure>
<h3 id="检查配置是否生效"><a href="#检查配置是否生效" class="headerlink" title="检查配置是否生效"></a>检查配置是否生效</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase-indexer list-indexers -dump</span><br></pre></td></tr></table></figure>
<h3 id="删除映射"><a href="#删除映射" class="headerlink" title="删除映射"></a>删除映射</h3><p>如果配置没有生效的情况，最好先删掉映射后重新添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase-indexer delete-indexer --name &#39;qc&#39;</span><br></pre></td></tr></table></figure>

<h3 id="重新拉取Hbase数据"><a href="#重新拉取Hbase数据" class="headerlink" title="重新拉取Hbase数据"></a>重新拉取Hbase数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup hadoop jar &#x2F;opt&#x2F;hbase-indexer&#x2F;latest&#x2F;tools&#x2F;hbase-indexer-mr-1.6-ngdata-job.jar  --conf &#x2F;etc&#x2F;hbase&#x2F;conf&#x2F;hbase-site.xml -D &#39;mapred.child.java.opts&#x3D;-Xmx500m&#39; --hbase-indexer-file &#x2F;opt&#x2F;morphline_config&#x2F;qc.xml --zk-host node1&#x2F;solr --collection qc  --reduce 0 &amp;</span><br></pre></td></tr></table></figure>
<h2 id="配置Solr"><a href="#配置Solr" class="headerlink" title="配置Solr"></a>配置Solr</h2><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>之前有配置的，可直接拷贝一份开始配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;root</span><br><span class="line">cp -a xyz qc</span><br></pre></td></tr></table></figure>
<h4 id="修改后的scheme-xml"><a href="#修改后的scheme-xml" class="headerlink" title="修改后的scheme.xml"></a>修改后的scheme.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion="1.0"encoding="UTF-8"standalone="no"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schemaname="qc"version="1.5"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"_version_"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"long"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span><span class="attr">name</span>=<span class="string">"_root_"</span><span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span><span class="attr">multiValued</span>=<span class="string">"false"</span><span class="attr">name</span>=<span class="string">"_id"</span><span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"false"</span> <span class="attr">name</span>=<span class="string">"rowkey"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"code"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"errorCode"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"errorMsg"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"eventNo"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"eventTime"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"orgCode"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"patientId"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"receiveTime"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"rowKey"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"table"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"value"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"version"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uniqueKey</span>&gt;</span>rowkey<span class="tag">&lt;/<span class="name">uniqueKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此处注意配置rowkey字段，之前一就因为rowkey没有导致创建索引失败</p>
<h2 id="上传配置"><a href="#上传配置" class="headerlink" title="上传配置"></a>上传配置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/solr/latest/server/scripts/cloud-scripts/zkcli.sh -zkhost node1:2181/solr -cmd upconfig --confdir /root/qc/conf/ --confname qc</span><br></pre></td></tr></table></figure>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/solr/latest/bin/solr create_collection -c qc -d /root/qc/conf/ -n qc</span><br></pre></td></tr></table></figure>
<h2 id="修改ES配置"><a href="#修改ES配置" class="headerlink" title="修改ES配置"></a>修改ES配置</h2><p>拉取测试数据时，提示只有10000的窗口数据，需要设计max_result_window，修改方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &#39;http:&#x2F;&#x2F;xx:9200&#x2F;qc&#x2F;_close&#39;</span><br><span class="line">curl -XPUT &#39;http:&#x2F;&#x2F;xx:9200&#x2F;qc&#x2F;_settings?preserve_existing&#x3D;true&#39; -d &#39;&#123;&quot;max_result_window&quot; : &quot;1000000&quot;&#125;&#39;</span><br><span class="line">curl -XGET &#39;http:&#x2F;&#x2F;xx:9200&#x2F;qc&#x2F;_settings?preserve_existing&#x3D;true&#39;</span><br><span class="line">curl -XPOST &#39;http:&#x2F;&#x2F;xx:9200&#x2F;qc&#x2F;_open&#39;</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="read-row为never"><a href="#read-row为never" class="headerlink" title="read-row为never"></a>read-row为never</h2><ol>
<li>测试数据为100万条，全量数据更新。<br>数据测试，导入数据时出现服务连接问题，中间出现Hbase Indexer异常停止，重启后，数据能对上。</li>
<li>测试数据为100万条，部分数据更新。<br>数据字段出现丢失情况，</li>
<li>验证配置字段顺序问题。<h2 id="清理Hbase数据"><a href="#清理Hbase数据" class="headerlink" title="清理Hbase数据"></a>清理Hbase数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate &#39;qc&#39;</span><br></pre></td></tr></table></figure>
<h2 id="清理Solr数据"><a href="#清理Solr数据" class="headerlink" title="清理Solr数据"></a>清理Solr数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -rm -r &#x2F;solr&#x2F;qc</span><br><span class="line">hdfs dfs -ls &#x2F;solr</span><br></pre></td></tr></table></figure>
验证的情况，与配置文件的顺序无关</li>
</ol>
<h2 id="验证重跑MapRedurce"><a href="#验证重跑MapRedurce" class="headerlink" title="验证重跑MapRedurce"></a>验证重跑MapRedurce</h2><h3 id="删除solr中qc的记录"><a href="#删除solr中qc的记录" class="headerlink" title="删除solr中qc的记录"></a>删除solr中qc的记录</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span>&gt;</span><span class="tag">&lt;<span class="name">query</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">query</span>&gt;</span><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commit</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="重跑"><a href="#重跑" class="headerlink" title="重跑"></a>重跑</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup hadoop jar /opt/hbase-indexer/latest/tools/hbase-indexer-mr-1.6-ngdata-job.jar  --conf /etc/hbase/conf/hbase-site.xml -D <span class="string">'mapred.child.java.opts=-Xmx500m'</span> --hbase-indexer-file /opt/morphline_config/qc.xml --zk-host node1/solr --collection qc  --reduce 0 &amp;</span><br></pre></td></tr></table></figure>
<p>测试时发现可以正常拉取数据，正式线发现不能拉取到之前遗漏的数据。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li>修改read-row为never</li>
<li>重新检查写入Hbase相关代码，确保数据是整条记录更新（即需要合并旧数据的方式进行更新）</li>
</ol>
<p><strong>注意事项</strong>，采用read-row为never时，只会从WAL中获取数据去更新Solr，也就是说如果，数据只更新部分，Solr也只会有最后更新的那部分数据。<br>3. 通过写程序将缺失数据提取出来重新更新Hbase，该工作已让郑维协助处理，保持跟进。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/kekukekro/p/6340922.html" target="_blank" rel="noopener">Lily HBase Indexer同步HBase二级索引到Solr丢失数据的问题分析</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/27/misc/notepad-plus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/27/misc/notepad-plus/" class="post-title-link" itemprop="url">notepad++添加插件管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-11-27 15:07:40 / 修改时间：15:24:47" itemprop="dateCreated datePublished" datetime="2018-11-27T15:07:40+08:00">2018-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/misc/" itemprop="url" rel="index"><span itemprop="name">misc</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>424</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用Notepad++有挺长一段时间了。因为打开速度快，经常会用它来编绎有一些小文本，或者文件的格式化。在一次升级后发现Json Viwer插件不见了。<br>当时也没太在意，换了一台电脑用了。最近因为查问题需要格式化的JSON也多了起来，就想查查到底是怎么回事，顺便记录下处理方式。</p>
<p>网上一搜还有不少碰到这个问题的人<a href="https://www.cnblogs.com/holab/p/8593359.html" target="_blank" rel="noopener">notepad++64位添加Plugin Manager</a>。大意是64位已经不提供plugin manager了。可以通过<a href="https://github.com/bruderstein/nppPluginManager/releases" target="_blank" rel="noopener">https://github.com/bruderstein/nppPluginManager/releases</a>下载Plugin Manager。下载之后，用覆盖的方式粘贴plugins和updater文件夹，重新启动就可以。</p>
<p>启动之后提示，32位Notepad++不能运行64位插件。索性重新下载了个新版本的Notepad++64位，plugin manager已经改名为Plugin Admin了。下载我自己需要的插件，一切正常。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-6/" class="post-title-link" itemprop="url">Go Little Book - 第六章 - 并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:45:44" itemprop="dateCreated datePublished" datetime="2018-11-22T10:45:44+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:45" itemprop="dateModified" datetime="2018-12-05T10:40:45+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第六章-并发-Chapter-6-Concurrency"><a href="#第六章-并发-Chapter-6-Concurrency" class="headerlink" title="第六章 - 并发(Chapter 6 - Concurrency)"></a>第六章 - 并发(Chapter 6 - Concurrency)</h1><p>Go is often described as a concurrent-friendly language. The reason for this is that it provides a simple syntax over two powerful mechanisms: goroutines and channels.</p>
<p>Go常被描述为是一种适用于并发的语言。是因为它在两个强大的机制提供了简法的语法支持：<code>go协程</code>和<code>通道</code>。</p>
<h2 id="Go协程-Goroutines"><a href="#Go协程-Goroutines" class="headerlink" title="Go协程(Goroutines)"></a>Go协程(Goroutines)</h2><p>A goroutine is similar to a thread, but it is scheduled by Go, not the OS. Code that runs in a goroutine can run concurrently with other code. Let’s look at an example:</p>
<p>一个Go协程和一个线程类似，只不这它是由Go,而不是系统来调度的。在协程中的代码可以和其他代码并发执行。让我们看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"start"</span>)</span><br><span class="line">  <span class="keyword">go</span> process()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// this is bad, don't do this! 这样不好，不能这么做！</span></span><br><span class="line">  fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"processing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are a few interesting things going on here, but the most important is how we start a goroutine. We simply use the <code>go</code> keyword followed by the function we want to execute. If we just want to run a bit of code, such as the above, we can use an anonymous function. Do note that anonymous functions aren’t only used with goroutines, however.</p>
<p>这里有几个有趣的地方，但最重要的是我们如何开启一个Go协程。我们只是简单的使用了<code>go</code>关键字后紧跟我们需的执行的函数。如果我们只是要运行一小段代码，比如上面的例子，我们可以使用匿名函数。但是记住，匿名函数不只适用于Go协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"processing"</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>Goroutines are easy to create and have little overhead. Multiple goroutines will end up running on the same underlying OS thread. This is often called an M:N threading model because we have M application threads (goroutines) running on N OS threads. The result is that a goroutine has a fraction of overhead (a few KB) than OS threads. On modern hardware, it’s possible to have millions of goroutines.</p>
<p>Go协程创建简单和开销小。多个Go协程最终会运行在一个系统线程中。这通常称为<code>M:N</code>线程模型，因为我们有<code>M</code>个应用线程（Go协程）运行在<code>N</code>个系统线程上。结果就是，一个Go协程的开销比系统线程小（一般都是几KB）。在现代的硬件上，有可能创建成千上万个Go协程。</p>
<p>Furthermore, the complexity of mapping and scheduling is hidden. We just say <em>this code should run concurrently</em> and let Go worry about making it happen.</p>
<p>此外，因为隐藏了映射和调度的复杂性。我们只需要说<em>这段代码需要并发执行</em>，然后让Go自己来运行它。</p>
<p>If we go back to our example, you’ll notice that we had to <code>Sleep</code> for a few milliseconds. That’s because the main process exits before the goroutine gets a chance to execute (the process doesn’t wait until all goroutines are finished before exiting). To solve this, we need to coordinate our code.</p>
<p>回到我们的例子中，你将会注意到我们使用了<code>Sleep</code>让程序等待了几毫秒。这是让主进程在退出前有机会去执行协程（主进程退出时不会等待所有协程都执行结束）。为了解决这个问题，我们必须让代码协同。</p>
<h2 id="同步-Synchronization"><a href="#同步-Synchronization" class="headerlink" title="同步(Synchronization)"></a>同步(Synchronization)</h2><p>Creating goroutines is trivial, and they are so cheap that we can start many; however, concurrent code needs to be coordinated. To help with this problem, Go provides <code>channels</code>. Before we look at <code>channels</code>, I think it’s important to understand a little bit about the basics of concurrent programming.</p>
<p>创建Go协程是容易的，而且他们的开销很小，所以我们可以开启很多Go协程；但是并发代码需要协同。为了帮助我们解决这个问题，Go提供了<code>通道</code>。在我们继续<code>通道</code>之前，我觉得有必要先了解一些并发编程的基础知识。</p>
<p>Writing concurrent code requires that you pay specific attention to where and how you read and write values. In some ways, it’s like programming without a garbage collector – it requires that you think about your data from a new angle, always watchful for possible danger. Consider:</p>
<p>在编写并发执行的代码时，你需要特别的注意在哪里和如何读写一个值。出于某些原因，例如没有垃圾回收的语言，需要你从一个新的角度去考虑你的数据，总是警惕着可能存在的危险。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> incr()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">  counter++</span><br><span class="line">  fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What do you think the output will be?</p>
<p>你觉得输出的会是什么呢？</p>
<p>If you think the output is <code>1, 2</code> you’re both right and wrong. It’s true that if you run the above code, you’ll very likely get that output. However, the reality is that the behavior is undefined. Why? Because we potentially have multiple (two in this case) goroutines writing to the same variable, <code>counter</code>, at the same time. Or, just as bad, one goroutine would be reading <code>counter</code> while another writes to it.</p>
<p>如果你觉得输出是<code>1</code>和<code>2</code>，不能说你对或者错。如果你运行上面的代码，你很有可能得到那样的输出。但是，实际上这个输出是不确定的。为什么？因为我们可能有多个（这里是2个）Go协程同时写同一个变量<code>counter</code>。或者更糟的情况是一个协程正在读<code>counter</code>，而另一个协程正在写<code>counter</code>。</p>
<p>Is that really a danger? Yes, absolutely. <code>counter++</code> might seem like a simple line of code, but it actually gets broken down into multiple assembly statements – the exact nature is dependent on the platform that you’re running. It’s true that, in this example, the most likely case is things will run just fine. However, another possible outcome would be that they both see <code>counter</code> when its equal to <code>0</code> and you get an output of <code>1, 1</code>. There are worse possibilities, such as system crashes or accessing an arbitrary piece of data and incrementing it!</p>
<p>这很危险吗？是的，绝对的。<code>counter++</code>似乎看起来只是一行简单的代码，但是实际上它被拆分为很多汇编指令————具体依赖于你运行的软件和硬件平台。是的，在上面的例子中，确实在大多数情况下运行良好。但是，其他一些平台可能的输出结果是<code>1, 1</code>，因为两个协程看到的<code>counter</code>都是<code>0</code>。还有更糟的情况是，比如系统崩溃或者访问到一个随机值并递增它。</p>
<p>The only concurrent thing you can safely do to a variable is to read from it. You can have as many readers as you want, but writes need to be synchronized. There are various ways to do this, including using some truly atomic operations that rely on special CPU instructions. However, the most common approach is to use a mutex:</p>
<p>在并发编程中维一安全的事情就是读一个变量。无论你想读多少次都可以，但是写变量时必须是同步的。有几种方式来实现，包括一些在特定CPU架构上真正的原子操作。但是，最常见的方式就是用互斥锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  counter = <span class="number">0</span></span><br><span class="line">  lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> incr()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">  counter++</span><br><span class="line">  fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A mutex serializes access to the code under lock. The reason we simply define our lock as <code>lock sync.Mutex</code> is because the default value of a <code>sync.Mutex</code> is unlocked.</p>
<p>互斥锁会顺序化有锁的代码的访问。因为<code>sync.Mutex</code>默认值是未锁状态，所以我们简单的定义了一个锁<code>lock sync.Mutex</code>。</p>
<p>Seems simple enough? The example above is deceptive. There’s a whole class of serious bugs that can arise when doing concurrent programming. First of all, it isn’t always so obvious what code needs to be protected. While it might be tempting to use coarse locks (locks that cover a large amount of code), that undermines the very reason we’re doing concurrent programming in the first place. We generally want fine locks; else, we end up with a ten-lane highway that suddenly turns into a one-lane road.</p>
<p>看起来足够简单？上面的例子有欺骗性。在并发编程时，会碰到一系列很严重的bug。首先，那些需要被保护代码通常都不是这么明显。虽然它可能是想使用一个粗锁（涵盖了大量代码的锁），但这破坏了并发编程首要原则。我们需要适度的锁，或者说，我们最终由一个10快车道的突然转变成一个单车道。</p>
<p>The other problem has to do with deadlocks. With a single lock, this isn’t a problem, but if you’re using two or more locks around the same code, it’s dangerously easy to have situations where goroutineA holds lockA but needs access to lockB, while goroutineB holds lockB but needs access to lockA.</p>
<p>另一个问题是如何处理死锁。只有一个锁的时候，这不是问题，但是如果你在相同的代码中使用2个或者更多的锁，就很容易出现一种危险的情况，即协程A拥有锁<code>lockA</code>，想去访问锁<code>lockB</code>，同时协程B拥有<code>lockB</code>并需要访问锁<code>lockA</code>。</p>
<p>It actually <em>is</em> possible to deadlock with a single lock, if we forget to release it. This isn’t as dangerous as a multi-lock deadlock (because those are <em>really</em> tough to spot), but just so you can see what happens, try running:</p>
<p>实际上使用一个锁<em>也有</em>可能发生死锁，如果我们忘记释放它时。但是这和多个锁引起的死锁为比起来，危害性不大（因为这<em>真的</em>很少出现），但只是想让你看会发生什么，试试下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; lock.Lock() &#125;()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">  lock.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s more to concurrent programming than what we’ve seen so far. For one thing, there’s another common mutex called a read-write mutex. This exposes two locking functions: one to lock for reading and one to lock for writing. This distinction allows multiple simultaneous readers while ensuring that writing is exclusive. In Go, <code>sync.RWMutex</code> is such a lock. In addition to the <code>Lock</code> and <code>Unlock</code> methods of a <code>sync.Mutex</code>, it also exposes <code>RLock</code> and <code>RUnlock</code> methods; where <code>R</code> stands for <em>Read</em>. While read-write mutexes are commonly used, they place an additional burden on developers: we must now pay attention to not only when we’re accessing data, but also how.</p>
<p>接下来我们会介绍更多的并发编程。一方面，另一个常见的互斥锁叫读写互斥锁。它主要提供2中锁功能：一个读锁定和一个写锁定。在Go中，<code>sync.RWMutex</code>就是这种锁。另外<code>sync.Mutex</code>结构不但提供了<code>Lock</code>和<code>Unlock</code>方法，也提供了<code>RLock</code>和<code>RLock</code>方法，这里的<code>R</code>代表<em>读</em>。虽然读写锁很常用，但是他们也给开发者带来一些额外的负担：我们不但要关注我们何时访问数据，而且也要关注如何访问。</p>
<p>Furthermore, part of concurrent programming isn’t so much about serializing access across the narrowest possible piece of code; it’s also about coordinating multiple goroutines. For example, sleeping for 10 milliseconds isn’t a particularly elegant solution. What if a goroutine takes more than 10 milliseconds? What if it takes less and we’re just wasting cycles? Also, what if instead of just waiting for goroutines to finish, we want to tell one <em>hey, I have new data for you to process!</em>?</p>
<p>此外，部分并发编程不只是通过为数不多代码按顺序的访问变量，也需要协调多个go协程。例如，休眠10毫秒不是一种优雅的方法。如果一个Go协程运行的时间超过10毫秒呢？如果Go协程运行时间少于10毫秒，我们只是浪费了cpu？又或者可以等待Go协程运行完毕，我们告诉另外一个Go协程<em>嗨，我有一些新数据给你处理？</em></p>
<p>These are all things that are doable without <code>channels</code>. Certainly for simpler cases, I believe you <strong>should</strong> use primitives such as <code>sync.Mutex</code> and <code>sync.RWMutex</code>, but as we’ll see in the next section, <code>channels</code> aim at making concurrent programming cleaner and less error-prone.</p>
<p>所有的这些事在不使用通道的情况下也都是可以实现的。当然，对于更简单的例子，我认为你应该使用基本的功能例如<code>sync.Mutex</code>和<code>sync.RWMutex</code>，但是在下一节我们将看到，通道的目的是为了使并发编程更清晰和不易出错。</p>
<h2 id="通道-Channels"><a href="#通道-Channels" class="headerlink" title="通道(Channels)"></a>通道(Channels)</h2><p>The challenge with concurrent programming stems from sharing data. If your goroutines share no data, you needn’t worry about synchronizing them. That isn’t an option for all systems, however. In fact, many systems are built with the exact opposite goal in mind: to share data across multiple requests. An in-memory cache or a database, are good examples of this. This is becoming an increasingly common reality.</p>
<p>并发编程的最在挑战来自共享数据。如果你的Go协程没有共享数据，你不需要担心他们之间的同步。但是这不是所有系统的选择。事实上，许多系统的构建就是为了：在多个请求中共享数据。内存缓存或者数据库，都是很好的例子。这也成为越来越普遍的事实。</p>
<p>Channels help make concurrent programming saner by taking shared data out of the picture. A channel is a communication pipe between goroutines which is used to pass data. In other words, a goroutine that has data can pass it to another goroutine via a channel. The result is that, at any point in time, only one goroutine has access to the data.</p>
<p>通过共享数据规划，通道使并发编程更清晰。一个通道是一个通信管道用于Go协程之间的数据传递。换一句话来说。一个Go协程可以通过通道来把数据传递给另一个Go协程。这样做的结果就是，无论什么时间节点，都只有一个Go协程可以访问共享数据。</p>
<p>A channel, like everything else, has a type. This is the type of data that we’ll be passing through our channel. For example, to create a channel which can be used to pass an integer around, we’d do:</p>
<p>通道和其他类型一样有类型。这个类型就是我们将在通道中传递的数据类型。例如，创建一个用来传递整数的通道，我们这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>The type of this channel is <code>chan int</code>. Therefore, to pass this channel to a function, our signature looks like:</p>
<p>这个通道的类型是<code>chan int</code>。因此，将这个通道传递给一个函数是，可以这样声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Channels support two operations: receiving and sending. We send to a channel by doing:</p>
<p>通道支持2种操作：接收和发送。我们可以使用下面方式往通道发送数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL &lt;- DATA</span><br></pre></td></tr></table></figure>

<p>and receive from one by doing</p>
<p>然后可以使用下面方式从通道接收数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VAR :&#x3D; &lt;-CHANNEL</span><br></pre></td></tr></table></figure>

<p>The arrow points in the direction that data flows. When sending, the data flows into the channel. When receiving, the data flows out of the channel.</p>
<p>箭头的方向就是数据的流动方向。当发送数据时，数据流入通道。当发送数据时，数据是流出通道。</p>
<p>The final thing to know before we look at our first example is that receiving and sending to and from a channel is blocking. That is, when we receive from a channel, execution of the goroutine won’t continue until data is available. Similarly, when we send to a channel, execution won’t continue until the data is received.</p>
<p>最后，在看我们的第一个例子之前，从一个通道接收或者发送数据时会阻塞。也就是说，当我们从一个通道接收数据时，直到数据可用Go协程才会继续执行。类似的，往一个通道发送数据时，在数据被接收之前Go协程也不会继续执行。</p>
<p>Consider a system with incoming data that we want to handle in separate goroutines. This is a common requirement. If we did our data-intensive processing on the goroutine which accepts the incoming data, we’d risk timing out clients. First, we’ll write our worker. This could be a simple function, but I’ll make it part of a structure since we haven’t seen goroutines used like this before:</p>
<p>假设这样的一个系统，我们想通过不同的协程来处理输入数据。这是一个常见的需求。如果通过Go协程接收输入的数据并进行数据密集型处理，那么在客户端会有超时风险。首先，我们将写出我们的处理器。这是一个简单的函数，但是我会让它变成一个结构体的部分，因为我们之前从来没有这样使用过Go协程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">process</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    data := &lt;-c</span><br><span class="line">    fmt.Printf(<span class="string">"worker %d got %d\n"</span>, w.id, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our worker is simple. It waits until data is available then “processes” it. Dutifully, it does this in a loop, forever waiting for more data to process.</p>
<p>我们的处理器很简单。它会一直等待直到数据可用并“处理”它。它通过一个循环来实现，永久等待更多的数据来处理。</p>
<p>To use this, the first thing we’d do is start some workers:</p>
<p>为了使用上面的代码，我们首先要做的是启动一些处理器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">  worker := Worker&#123;id: i&#125;</span><br><span class="line">  <span class="keyword">go</span> worker.process(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then we can give them some work:</p>
<p>然后我们可以给他们一些工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  c &lt;- rand.Int()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here’s the complete code to make it run:</p>
<p>下面是完整的可执行代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">  <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    worker := &amp;Worker&#123;id: i&#125;</span><br><span class="line">    <span class="keyword">go</span> worker.process(c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    c &lt;- rand.Int()</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">process</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    data := &lt;-c</span><br><span class="line">    fmt.Printf(<span class="string">"worker %d got %d\n"</span>, w.id, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We don’t know which worker is going to get what data. What we do know, what Go guarantees, is that the data we send to a channel will only be received by a single receiver.</p>
<p>我们不知道哪个处理器将获得数据。我们所知道的是，Go确保了往一个通道发送数据时，仅有一个单独的接收器可以接受。</p>
<p>Notice that the only shared state is the channel, which we can safely receive from and send to concurrently. Channels provide all of the synchronization code we need and also ensure that, at any given time, only one goroutine has access to a specific piece of data.</p>
<p>需要指出的是通道是唯一的共享方式，通过通道我们可以并发安全的发送和接收数据。通道提供了我们需要的所有同步代码，并且也确保在任意的特定时刻只有一个Go协程可以访问一个特定的数据。</p>
<h3 id="带缓存的通道-Buffered-Channels"><a href="#带缓存的通道-Buffered-Channels" class="headerlink" title="带缓存的通道(Buffered Channels)"></a>带缓存的通道(Buffered Channels)</h3><p>Given the above code, what happens if we have more data coming in than we can handle? You can simulate this by changing the worker to sleep after it has received data:</p>
<p>在上面的代码中，如果输入的数据超过我们可以处理的数据会发生什么？你可以模拟这种场景，在处理器收到数据后执行<code>time.Sleep</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  data := &lt;-c</span><br><span class="line">  fmt.Printf(<span class="string">"worker %d got %d\n"</span>, w.id, data)</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What’s happening is that our main code, the one that accepts the user’s incoming data (which we just simulated with a random number generator) is blocking as it sends to the channel because no receiver is available.</p>
<p>在<code>main</code>函数中会发什么呢？接收用户的输入数据（这里通过一个随机的数字生成器模拟）会被阻塞，因为往通道发送数据时没有可用的接收者。</p>
<p>In cases where you need high guarantees that the data is being processed, you probably will want to start blocking the client. In other cases, you might be willing to loosen those guarantees. There are a few popular strategies to do this. The first is to buffer the data. If no worker is available, we want to temporarily store the data in some sort of queue. Channels have this buffering capability built-in. When we created our channel with <code>make</code>, we can give our channel a length:</p>
<p>在这种情况下，你需要确保数据被处理，你可能想要让客户端阻塞。在其他情况下，你可能愿意不确保数据被处理。这里有一些流行的策略能完成此事。首先是将数据缓存起来。如果没有处理器可用，我们想将数据暂时存放在一个有序的队列中。通道内置缓存能力。当我们使用<code>make</code>创建一个通道时，我们可以指定通道的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>You can make this change, but you’ll notice that the processing is still choppy. Buffered channels don’t add more capacity; they merely provide a queue for pending work and a good way to deal with a sudden spike. In our example, we’re continuously pushing more data than our workers can handle.</p>
<p>你可以做这样的修改，但是你将注意到处理过程仍然震荡。缓冲通道没有增加处理能力，他们只是为挂起的工作提供了一个队列和应对突发尖峰的好方法。在我们示例中，我们持续不断的发送超出我们处理器可以处理的数据。</p>
<p>Nevertheless, we can get a sense that the buffered channel is, in fact, buffering by looking at the channel’s <code>len</code>:</p>
<p>尽管如此，事实上，我们可以查看通道的<code>len</code>,来了解到带缓存的通道的缓冲情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  c &lt;- rand.Int()</span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(c))</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can see that it grows and grows until it fills up, at which point sending to our channel start to block again.</p>
<p>你可以看到它的长度在不断增大，直到装满为止，此时，往通道发送的数据又开始被阻塞。</p>
<h3 id="选择-Select"><a href="#选择-Select" class="headerlink" title="选择(Select)"></a>选择(Select)</h3><p>Even with buffering, there comes a point where we need to start dropping messages. We can’t use up an infinite amount of memory hoping a worker frees up. For this, we use Go’s <code>select</code>.</p>
<p>即使借助缓存，有一点需要指出的是，我们需要开始丢弃一些消息，我们不能使用一个无限大的内存，并指望人工的释放它。所以我们使用Go的<code>select</code>。</p>
<p>Syntactically, <code>select</code> looks a bit like a switch. With it, we can provide code for when the channel isn’t available to send to. First, let’s remove our channel’s buffering so that we can clearly see how <code>select</code> works:</p>
<p>在语法结构上，<code>select</code>看起来有点类似<code>switch</code>。通过<code>select</code>，我们能写出一些针对通道不可写情况下的代码。首先，让我们去掉我们通道的缓存，这样可以更清晰的看到<code>select</code>是如何工作的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>Next, we change our <code>for</code> loop:</p>
<p>接下来，我们修改<code>for</code>循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> c &lt;- rand.Int():</span><br><span class="line">    <span class="comment">//optional code here</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//this can be left empty to silently drop the data</span></span><br><span class="line">    fmt.Println(<span class="string">"dropped"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re pushing out 20 messages per second, but our workers can only handle 10 per second; thus, half the messages get dropped.</p>
<p>我们每秒往通道中发送20个信息，但是我们的处理器每秒只能处理10个信息；因此，有一半的信息被丢弃。</p>
<p>This is only the start of what we can accomplish with <code>select</code>. A main purpose of select is to manage multiple channels. Given multiple channels, <code>select</code> will block until the first one becomes available. If no channel is available, <code>default</code> is executed if one is provided. A channel is randomly picked when multiple are available.</p>
<p>这仅仅只是我们使用<code>select</code>完成一些事的开始。使用<code>select</code>的最主要目的是通过它管理多个通道。给定多个通道，<code>select</code>将阻塞直到有一个通道可用。如果没有可用的通道，当提供了<code>default</code>语句时，执行该分支。当多个通道都可用时，选择其中的一个通道是随机的。</p>
<p>It’s hard to come up with a simple example that demonstrates this behavior as it’s a fairly advanced feature. The next section might help illustrate this though.</p>
<p>很难想出一个简单的例子来证明这种行为，因为这是一种高级特性。在下一小节可能有助于说明这个问题。</p>
<h3 id="超时-Timeout"><a href="#超时-Timeout" class="headerlink" title="超时(Timeout)"></a>超时(Timeout)</h3><p>We’ve looked at buffering messages as well as simply dropping them. Another popular option is to timeout. We’re willing to block for some time, but not forever. This is also something easy to achieve in Go. Admittedly, the syntax might be hard to follow but it’s such a neat and useful feature that I couldn’t leave it out.</p>
<p>我们已经学习了缓存消息和简单丢弃消息。另外一种比较流行的做法是使用超时。我们将阻塞一段时间，但不是一直阻塞。在Go中这很容易实现。老实说，这个语法有点难于接受，但是它是比较灵活和有用的特性，我基本不能没有它。</p>
<p>To block for a maximum amount of time, we can use the <code>time.After</code> function. Let’s look at it then try to peek beyond the magic. To use this, our sender becomes:</p>
<p>为了达到阻塞的最大时限，我们可以使用<code>time.After</code>函数。让我们看看它，并试着看出其中的魔法。为了使用这种方式，我们的发送器需要修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> c &lt;- rand.Int():</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">    fmt.Println(<span class="string">"timed out"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>time.After</code> returns a channel, so we can <code>select</code> from it. The channel is written to after the specified time expires. That’s it. There’s nothing more magical than that. If you’re curious, here’s what an implementation of <code>after</code> could look like:</p>
<p><code>time.After</code>返回一个通道，所以我们可以对它使用<code>select</code>语法。当指定的时间到期时这个通道被写入。就是如此。没有其他更多的魔法了。如果你还是好奇，这里有一个<code>after</code>的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">after</span><span class="params">(d time.Duration)</span> <span class="title">chan</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(d)</span><br><span class="line">    c &lt;- <span class="literal">true</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Back to our <code>select</code>, there are a couple of things to play with. First, what happens if you add the <code>default</code> case back? Can you guess? Try it. If you aren’t sure what’s going on, remember that <code>default</code> fires immediately if no channel is available.</p>
<p>回到我们的<code>select</code>中来，还一些内容可以研究。首先，如果添加了<code>default</code>条件会发生会什么呢？你可以猜猜？试试。如果你不确定会发生什么，记住如果没有可用的通道<code>default</code>会立即被触发。</p>
<p>Also, <code>time.After</code> is a channel of type <code>chan time.Time</code>. In the above example, we simply discard the value that was sent to the channel. If you want though, you can receive it:</p>
<p>同时，<code>time.After</code>的通道类型是<code>chan time.Time</code>。上面的例子中，我们简单的丢弃了发送给通道的值。如果你相要，你可以这样接收它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> t := &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">  fmt.Println(<span class="string">"timed out at"</span>, t)</span><br></pre></td></tr></table></figure>

<p>Pay close attention to our <code>select</code>. Notice that we’re sending to <code>c</code> but receiving from <code>time.After</code>. <code>select</code> works the same regardless of whether we’re receiving from, sending to, or any combination of channels:</p>
<p>更近一步的看我们的<code>select</code>。注意我们向<code>c</code>发送数据，但是从<code>time.After</code>接收数据。<code>select</code>对无论是接收数据，发送数据，还是其他通道的组合，都是一样对待的：</p>
<ul>
<li><p>The first available channel is chosen.</p>
</li>
<li><p>If multiple channels are available, one is randomly picked.</p>
</li>
<li><p>If no channel is available, the default case is executed.</p>
</li>
<li><p>If there’s no default, select blocks.</p>
</li>
<li><p>第一个可用的通道被选择。</p>
</li>
<li><p>如果有多个通道可用，随机选择一个。</p>
</li>
<li><p>如果没有通道可用，默认条件被执行。</p>
</li>
<li><p>如果没有默认条件，选择阻塞。</p>
</li>
</ul>
<p>Finally, it’s common to see a <code>select</code> inside a <code>for</code>. Consider:</p>
<p>最后，<code>select</code>通常在<code>for</code>循环中使用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> data := &lt;-c:</span><br><span class="line">    fmt.Printf(<span class="string">"worker %d got %d\n"</span>, w.id, data)</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">10</span>):</span><br><span class="line">    fmt.Println(<span class="string">"Break time"</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继续之前-Before-You-Continue"><a href="#继续之前-Before-You-Continue" class="headerlink" title="继续之前(Before You Continue)"></a>继续之前(Before You Continue)</h2><p>If you’re new to the world of concurrent programming, it might all seem rather overwhelming. It categorically demands considerably more attention and care. Go aims to make it easier.</p>
<p>如果你是并发编程的新手，它可能显得相当庞大。它绝对是需要相当多的重视和关注。 Go的目标就是使其更容易。</p>
<p>Goroutines effectively abstract what’s needed to run concurrent code. Channels help eliminate some serious bugs that can happen when data is shared by eliminating the sharing of data. This doesn’t just eliminate bugs, but it changes how one approaches concurrent programming. You start to think about concurrency with respect to message passing, rather than dangerous areas of code.</p>
<p>Go协程有效的抽象了需要并发执行的代码。通道协助消除了可能在数据共享时的严重Bug。这不只是消除了Bug,更是改变了并发编程的开发方式。你开始使用消息传递的方式来考虑并发，而不是危险的共享代码。</p>
<p>Having said that, I still make extensive use of the various synchronization primitives found in the <code>sync</code> and <code>sync/atomic</code> packages. I think it’s important to be comfortable with both. I encourage you to first focus on channels, but when you see a simple example that needs a short-lived lock, consider using a mutex or read-write mutex.</p>
<p>虽然这么说，我仍然广泛使用的各种同步原语中发现的<code>sync</code>和<code>sync/atomic</code>包。我觉得这两种情况都要适应是很重要的。我鼓励你先聚焦在通道上，但是如果你碰到只是需要短暂的多锁，建议你使用互斥锁或者读写互斥锁。</p>
<h1 id="结论-Conclusion"><a href="#结论-Conclusion" class="headerlink" title="结论(Conclusion)"></a>结论(Conclusion)</h1><p>I recently heard Go described as a <em>boring</em> language. Boring because it’s easy to learn, easy to write and, most importantly, easy to read. Perhaps, I did this reality a disservice. We <em>did</em> spend three chapters talking about types and how to declare variables after all.</p>
<p>我最近听说Go被描述为一门<em>单调的</em>语言。单调是因为它很容易学习，很容易编写，最为重要的是，很容易读。也许，我这是在帮倒忙，我确实花了三个章节来介绍类型和如何申请变量。</p>
<p>If you have a background in a statically typed language, much of what we saw was probably, at best, a refresher. That Go makes pointers visible and that slices are thin wrappers around arrays probably isn’t overwhelming to seasoned Java or C# developers.</p>
<p>如果你在静态类型语言的背景，大多数我们看到的，充其量只是复习。同时Go的指针可见性和切片的轻量封装对经验丰富的Java的C＃开发人员来说不算什么。</p>
<p>If you’ve mostly been making use of dynamic languages, you might feel a little different. It <em>is</em> a fair bit to learn. Not least of which is the various syntax around declaration and initialization. Despite being a fan of Go, I find that for all the progress towards simplicity, there’s something less than simple about it. Still, it comes down to some basic rules (like you can only declare variable once and <code>:=</code> does declare the variable) and fundamental understanding (like <code>new(X)</code> or <code>&amp;X{}</code> only allocate memory, but slices, maps and channels require more initialization and thus, <code>make</code>).</p>
<p>如果你更多的是使用动态语言，你可能会觉得有点不同。这<em>是</em>一点公平的学习。不过其中最重要的是各种声明和初始化的语法。虽然是一个Go粉，我发现所有的努力都是为了简单，还有一些致简的东西。仍然，它也有一些基本的规则（比如变量申明一次和<code>:=</code>已经申明了变量）和基本的了解（比如<code>new(X)</code> 或 <code>&amp;X{}</code>只是分配了内存，但切片，字典和通道就需要使用<code>make</code>来分配内存和初始化）。</p>
<p>Beyond this, Go gives us a simple but effective way to organize our code. Interfaces, return-based error handling, <code>defer</code> for resource management and a simple way to achieve composition.</p>
<p>除此之外，Go提供了一个简洁但又高效的方式来组织我们的代码。接口，基于返回值的错误处理，用于资源管理的<code>defer</code>和简单的实现组合。</p>
<p>Last but not least is the built-in support for concurrency. There’s little to say about goroutines other than they’re effective and simple (simple to use anyway). It’s a good abstraction. Channels are more complicated. I always think it’s important to understand basics before using high-level wrappers. I <em>do</em> think learning about concurrent programming without channels is useful. Still, channels are implemented in a way that, to me, doesn’t feel quite like a simple abstraction. They are almost their own fundamental building block. I say this because they change how you write and think about concurrent programming. Given how hard concurrent programming can be, that is definitely a good thing.</p>
<p>最后但是最重要的是它内置了对并发的支持。还有一点关于Go协程的要说就是它们高效和简单（反正使用简单）。这是很好的抽象。通道会更复杂一点。我一直认为在学习高级封装之前要掌握好基础。我<em>确认</em>认为不使用通道来进行并发编程是有益的。但是，通道的实现方式，对我来说，不太像是一个简单的抽象。它们有自己的基础构建。我这么说是因为它们改变了你对并发编程的思考和书写方式。鉴于并发编程的难度，这绝对是一个好事。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">L4qiang</p>
  <div class="site-description" itemprop="description">记录点滴，注重积累。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/enderjo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;enderjo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:L4qiang@gmail.com" title="E-Mail → mailto:L4qiang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">L4qiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">390k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:54</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
      <div class="footer-inner">
        <a href="https://ri.cms.firesbox.com" target="_blank" rel="noopener">践行群官方情报站</a>
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>
</html>
