<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"l4qiang.me","root":"/","scheme":"Gemini","version":"8.0.0-rc.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录点滴，注重积累。">
<meta property="og:type" content="website">
<meta property="og:title" content="CrazyAirhead">
<meta property="og:url" content="http://l4qiang.me/page/18/index.html">
<meta property="og:site_name" content="CrazyAirhead">
<meta property="og:description" content="记录点滴，注重积累。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="L4qiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://l4qiang.me/page/18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CrazyAirhead</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ed9d534576a67e94ff8be03a704994";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CrazyAirhead</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">疯狂的傻瓜，傻瓜也疯狂——傻方能执著，疯狂才专注!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/crazy-airhead" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-2/" class="post-title-link" itemprop="url">Go Little Book - 第二章 - 结构体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:26:07" itemprop="dateCreated datePublished" datetime="2018-11-22T10:26:07+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:51" itemprop="dateModified" datetime="2018-12-05T10:40:51+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二章-结构体（Chapter-2-Structures）"><a href="#第二章-结构体（Chapter-2-Structures）" class="headerlink" title="第二章 - 结构体（Chapter 2 - Structures）"></a>第二章 - 结构体（Chapter 2 - Structures）</h1><p>Go isn’t an object-oriented (OO) language like C++, Java, Ruby and C#. It doesn’t have objects nor inheritance and thus, doesn’t have the many concepts associated with OO such as polymorphism and overloading.</p>
<p>和C++, Java, Ruby以及C#不一样，Go并不是面向对象的语言。它没有对象、继承和其他一些和面向对象相关的概念，比各多态和重载。</p>
<p>What Go does have are structures, which can be associated with methods. Go also supports a simple but effective form of composition. Overall, it results in simpler code, but there’ll be occasions where you’ll miss some of what OO has to offer. (It’s worth pointing out that <em>composition over inheritance</em> is an old battle cry and Go is the first language I’ve used that takes a firm stand on the issue.)</p>
<p>Go有的就是结构体，可以直接绑定方法。Go支持简单便高效的组合。总的来说，它带来更简洁的代码，但在一些场合中失去OO的一些特性。（有必要指出 <em>组合优于继承</em> 是一个老早的争议，但Go是我用过的这么多语言中第一个立场这么坚定的。）</p>
<p>Although Go doesn’t do OO like you may be used to, you’ll notice a lot of similarities between the definition of a structure and that of a class. A simple example is the following <code>Saiyan</code> structure:</p>
<p>虽然Go确实不是你用过的OO样，但是你会发现结构体和类之间的很多相似之处。来看一个简单的例子，结构体<code>Saiyan</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll soon see how to add a method to this structure, much like you’d have methods as part of a class. Before we do that, we have to dive back into declarations.<br>很快我们就会看到怎么往这个结构体中添加方法，就像你要类中添加方法一样。在那之前，我们先细看下结构体的声明.</p>
<h2 id="声明和初始化（Declarations-and-Initializations）"><a href="#声明和初始化（Declarations-and-Initializations）" class="headerlink" title="声明和初始化（Declarations and Initializations）"></a>声明和初始化（Declarations and Initializations）</h2><p>When we first looked at variables and declarations, we looked only at built-in types, like integers and strings. Now that we’re talking about structures, we need to expand that conversation to include pointers.</p>
<p>我们最初学习变量和声明的时候，我们只用到内建类型，比如整形和字符串。现在我们讲的是结构体，我们要深入这个话题，包括指针。</p>
<p>The simplest way to create a value of our structure is:<br>创建一个结构体的值最简单的方式是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;</span><br><span class="line">  Name: <span class="string">"Goku"</span>,</span><br><span class="line">  Power: <span class="number">9000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Note:</em> The trailing <code>,</code> in the above structure is required. Without it, the compiler will give an error. You’ll appreciate the required consistency, especially if you’ve used a language or format that enforces the opposite.</p>
<p><em>注意：</em>结构体中最后一个<code>,</code>是必需的。没有的话，编译器会报错。你会喜欢这种一致性要求，特别是如果你使用了强制性相反的语言或格式</p>
<p>We don’t have to set all or even any of the fields. Both of these are valid:<br>我们可以不给所有或者任何一个字段赋值。下面两种方式都是正确的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">goku := Saiyan&#123;Name: <span class="string">"Goku"</span>&#125;</span><br><span class="line">goku.Power = <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>Just like unassigned variables have a zero value, so do fields.</p>
<p>和没有赋值的变量一样，没有赋值的字段默认为0值。</p>
<p>Furthermore, you can skip the field name and rely on the order of the field declarations (though for the sake of clarity, you should only do this for structures with few fields):</p>
<p>再者，你也可以省略字段的名字，按字段的顺序进行声明（尽管为了简洁起见，你尽量在结构体只有少量字段时才使用这种方式）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br></pre></td></tr></table></figure>

<p>What all of the above examples do is declare a variable <code>goku</code> and assign a value to it.</p>
<p>上面所有的例子所做的事件就是声明一个变量<code>goku</code>并给它赋一个值。</p>
<p>Many times though, we don’t want a variable that is directly associated with our value but rather a variable that has a pointer to our value. A pointer is a memory address; it’s the location of where to find the actual value. It’s a level of indirection. Loosely, it’s the difference between being at a house and having directions to the house.</p>
<p>很多时候，我们不想变量直接相关的值，而是一个指向指针的变量。指针是内存地址，它可以定位实际的值有哪里。这是一种间接层。简单点说，这好比是在房子里还是有房子地址的区别。</p>
<p>Why do we want a pointer to the value, rather than the actual value? It comes down to the way Go passes arguments to a function: as copies. Knowing this, what does the following print?</p>
<p>为什么我们确实需要指针，而不是实际的值？这是因为Go在函数中参数的传递方式是：值。了解了这个，下面的程序会打出来什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s Saiyan)</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The answer is 9000, not 19000. Why? Because <code>Super</code> made changes to a copy of our original <code>goku</code> value and thus, changes made in <code>Super</code> weren’t reflected in the caller. To make this work as you probably expect, we need to pass a pointer to our value:</p>
<p>答案是9000，而示是19000。为什么呢？因为<code>Super</code>改变的是<code>goku</code>的一个拷贝的值，<code>Super</code>中的改变不会在调用者中显示出来。要如你期望的方式运行，我们需要传入一个指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := &amp;Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s *Saiyan)</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We made two changes. The first is the use of the <code>&amp;</code> operator to get the address of our value (it’s called the <em>address of</em> operator). Next, we changed the type of parameter <code>Super</code> expects. It used to expect a value of type <code>Saiyan</code> but now expects an address of type <code>*Saiyan</code>, where <code>*X</code> means <em>pointer to value of type X</em>. There’s obviously some relation between the types <code>Saiyan</code> and <code>*Saiyan</code>, but they are two distinct types.</p>
<p>我们做了两处修改。第一处是使用了<code>&amp;</code>操作符来获取值的地址（它被称为 <em>取址</em>操作符）。接下来，我们修改<code>Super</code>期望的参数类型。原来它期望的是<code>Saiyan</code>值类型，而现在期望的是<code>*Saiyan</code>的地址类型，此处<code>*X</code>是指 <em>指向X类型的指针</em>。<code>Saiyan</code>和 <code>*Saiyan</code>的类型有一些明显的关联，但是它们两是不同的类型。</p>
<p>Note that we’re still passing a copy of <code>goku&#39;s</code> value to <code>Super</code> it just so happens that <code>goku&#39;s</code> value has become an address. That copy is the same address as the original, which is what that indirection buys us. Think of it as copying the directions to a restaurant. What you have is a copy, but it still points to the same restaurant as the original.</p>
<p>需要指出的是，我们现在传递给<code>Super</code>参数的仍然是<code>goku</code>的值拷贝。只是现在<code>goku</code>的值变成了一个地址。这个地址拷贝和源地址相同。可以认为它类似一个指向餐厅方向的拷贝，这就间接服务于我们。虽然是一个拷贝，但是和源地址一样，也指向同一个餐厅。</p>
<p>We can prove that it’s a copy by trying to change where it points to (not something you’d likely want to actually do):</p>
<p>我们可以通过改变它的指向来证明这是个拷贝（虽然不是你想要的）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := &amp;Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s *Saiyan)</span></span> &#123;</span><br><span class="line">  s = &amp;Saiyan&#123;<span class="string">"Gohan"</span>, <span class="number">1000</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above, once again, prints 9000. This is how many languages behave, including Ruby, Python, Java and C#. Go, and to some degree C#, simply make the fact visible.</p>
<p>上例，依然，打印9000。这和很多语言的行为是一样的，包括Ruby，Python，Java和C#。Go和C#一定程度是要样的，让这个更显而易见。</p>
<p>It should also be obvious that copying a pointer is going to be cheaper than copying a complex structure. On a 64-bit machine, a pointer is 64 bits large. If we have a structure with many fields, creating copies can be expensive. The real value of pointers though is that they let you share values. Do we want <code>Super</code> to alter a copy of <code>goku</code> or alter the shared <code>goku</code> value itself?</p>
<p>很明显拷贝一个指针比拷贝一个复杂的结构体开销小多了。在64位的机器上，一个指针是64位的大小。如果我们有一个有很多字段的结构体，创建一份拷贝开销是比较大的。指针的真正价值是通过它可以共享值。我们想通过<code>Super</code>去改变<code>goku</code>的拷贝或者改变共享的<code>goku</code>值本身？</p>
<p>All this isn’t to say that you’ll always want a pointer. At the end of this chapter, after we’ve seen a bit more of what we can do with structures, we’ll re-examine the pointer-versus-value question.</p>
<p>所有这些不是说你一直要用指针。本章末尾，当我们学到更多结构体的内容后，我们会重新审视指针和值类型的问题。</p>
<h2 id="结构体上的函数（结构体的方法）（Functions-on-Structures）"><a href="#结构体上的函数（结构体的方法）（Functions-on-Structures）" class="headerlink" title="结构体上的函数（结构体的方法）（Functions on Structures）"></a>结构体上的函数（结构体的方法）（Functions on Structures）</h2><p>We can associate a method with a structure:<br>我们可以为结构体关联一个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Saiyan)</span> <span class="title">Super</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above code, we say that the type <code>*Saiyan</code> is the <strong>receiver</strong> of the <code>Super</code> method. We call <code>Super</code> like so:</p>
<p>上面的代码，我们说<code>*Saiyan</code>是<code>Super</code>方法的 <strong>接收器</strong> 。我们能过这样的方式调用<code>Super</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">goku.Super()</span><br><span class="line">fmt.Println(goku.Power) <span class="comment">// will print 19001</span></span><br></pre></td></tr></table></figure>

<h2 id="构造器（Constructors）"><a href="#构造器（Constructors）" class="headerlink" title="构造器（Constructors）"></a>构造器（Constructors）</h2><p>Structures don’t have constructors. Instead, you create a function that returns an instance of the desired type (like a factory):</p>
<p>结构体没有构造器。你可创建一个函数来返回一个期望类型的实例来替代（像工厂一样）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSaiyan</span><span class="params">(name <span class="keyword">string</span>, power <span class="keyword">int</span>)</span> *<span class="title">Saiyan</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Saiyan&#123;</span><br><span class="line">    Name: name,</span><br><span class="line">    Power: power,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This pattern rubs a lot of developers the wrong way. On the one hand, it’s a pretty slight syntactical change; on the other, it does feel a little less compartmentalized.</p>
<p>这种方式导致很多开发者犯错。一方面，它有一些轻微的语法变化；另一方面，它有一点让人感觉不好区分。 </p>
<p>Our factory doesn’t have to return a pointer; this is absolutely valid:</p>
<p>我们的工厂没有必要返回指针；下面的代码完全正确：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSaiyan</span><span class="params">(name <span class="keyword">string</span>, power <span class="keyword">int</span>)</span> <span class="title">Saiyan</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Saiyan&#123;</span><br><span class="line">    Name: name,</span><br><span class="line">    Power: power,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建（New）"><a href="#创建（New）" class="headerlink" title="创建（New）"></a>创建（New）</h2><p>Despite the lack of constructors, Go does have a built-in <code>new</code> function which is used to allocate the memory required by a type. The result of <code>new(X)</code> is the same as <code>&amp;X{}</code>:</p>
<p>尽管没有构造器，但是Go有内置的<code>new</code>函数可以用来分配一下指定类弄的内存。<code>new(X)</code>和<code>&amp;X{}</code>的效果是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goku := <span class="built_in">new</span>(Saiyan)</span><br><span class="line"><span class="comment">// same as</span></span><br><span class="line">goku := &amp;Saiyan&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Which you use is up to you, but you’ll find that most people prefer the latter whenever they have fields to initialize, since it tends to be easier to read:</p>
<p>使有哪种方式看你自己的喜好，但是你会发现当字段需要初始化时，大多数人喜欢使用后一种方式，因为这样更易读：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">goku := <span class="built_in">new</span>(Saiyan)</span><br><span class="line">goku.name = <span class="string">"goku"</span></span><br><span class="line">goku.power = <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vs</span></span><br><span class="line"></span><br><span class="line">goku := &amp;Saiyan &#123;</span><br><span class="line">  name: <span class="string">"goku"</span>,</span><br><span class="line">  power: <span class="number">9000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Whichever approach you choose, if you follow the factory pattern above, you can shield the rest of your code from knowing and worrying about any of the allocation details.</p>
<p>无论你使用哪种方式，如果你使用上面的工厂模式，接下来的代码中你可以不要了解和担心任何分配的细节。</p>
<h2 id="结构体字段（Fields-of-a-Structure）"><a href="#结构体字段（Fields-of-a-Structure）" class="headerlink" title="结构体字段（Fields of a Structure）"></a>结构体字段（Fields of a Structure）</h2><p>In the example that we’ve seen so far, <code>Saiyan</code> has two fields <code>Name</code> and <code>Power</code> of types <code>string</code> and <code>int</code>, respectively. Fields can be of any type – including other structures and types that we haven’t explored yet such as arrays, maps, interfaces and functions.</p>
<p>目前为止我们看到的例子中，<code>Saiyan</code>有两个字段，一个<code>字符串</code>类型的<code>Name</code>和一个<code>整型</code>的<code>Power</code>。字段可以是任何类型————包括其他的结构体和暂时我们没有讲到的类型，例如数组、字典、接口和函数。</p>
<p>For example, we could expand our definition of <code>Saiyan</code>:</p>
<p>例如，我们可以这样扩展<code>Saiyan</code>的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">  Father *Saiyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which we’d initialize via:</p>
<p>我们可以通过下面的方式初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gohan := &amp;Saiyan&#123;</span><br><span class="line">  Name: <span class="string">"Gohan"</span>,</span><br><span class="line">  Power: <span class="number">1000</span>,</span><br><span class="line">  Father: &amp;Saiyan &#123;</span><br><span class="line">    Name: <span class="string">"Goku"</span>,</span><br><span class="line">    Power: <span class="number">9001</span>,</span><br><span class="line">    Father: <span class="literal">nil</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>Go supports composition, which is the act of including one structure into another. In some languages, this is called a trait or a mixin. Languages that don’t have an explicit composition mechanism can always do it the long way. In Java:</p>
<p>Go支持组合，就是将一个结构体包含在另一个之中。在一些语言中，这被叫特性或混入。没有明确的组合机制的语言，要实现这个特性就比较繁杂。在Java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saiyan</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Saiyan is said to have a person</span></span><br><span class="line">  <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we forward the call to person</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This can get pretty tedious. Every method of <code>Person</code> needs to be duplicated in <code>Saiyan</code>. Go avoids this tediousness:</p>
<p>这样会相当的冗长。每个<code>Person</code>的方法都需要在<code>Saiyan</code>中复制一遍。Go可以避免这种冗长：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Introduce</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hi, I'm %s\n"</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  *Person</span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and to use it:</span></span><br><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Person: &amp;Person&#123;<span class="string">"Goku"</span>&#125;,</span><br><span class="line">  Power: <span class="number">9001</span>,</span><br><span class="line">&#125;</span><br><span class="line">goku.Introduce()</span><br></pre></td></tr></table></figure>

<p>The <code>Saiyan</code> structure has a field of type <code>*Person</code>. Because we didn’t give it an explicit field name,<br>we can implicitly access the fields and functions of the composed type.<br>However, the Go compiler <em>did</em> give it a field name, consider the perfectly valid:</p>
<p><code>Saiyan</code>结构体中有一个<code>*Person</code>类型的字段。因为我们没有给他一个显示的字段名，我们可以隐示的访问组合类型的所有字段和函数。<br>但出于完全有效的考虑，Go编辑器<em>确实</em>有给它分配一个字段名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Person: &amp;Person&#123;<span class="string">"Goku"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(goku.Name)</span><br><span class="line">fmt.Println(goku.Person.Name)</span><br></pre></td></tr></table></figure>

<p>Both of the above will print “Goku”.</p>
<p>上面的两个输出都是”Goku”。</p>
<p>Is composition better than inheritance? Many people think that it’s a more robust way to share code.<br>When using inheritance, your class is tightly coupled to your superclass and you end up focusing on hierarchy rather than behavior.<br>组合是不优于继承？很多人认为这是一种更健壮的共享代码的方式。当使用继承时，你的类和超类捆绑在一起，你最终关注继承而不是行为。</p>
<h3 id="重载（Overloading）"><a href="#重载（Overloading）" class="headerlink" title="重载（Overloading）"></a>重载（Overloading）</h3><p>While overloading isn’t specific to structures, it’s worth addressing. Simply, Go doesn’t support overloading.<br>For this reason, you’ll see (and write) a lot of functions that look like <code>Load</code>, <code>LoadById</code>, <code>LoadByName</code> and so on.</p>
<p>值得指出的是，结构体没有重载。简而言之，Go不支持重载。因为这个原因，你会看到（和写）很多像 <code>Load</code>, <code>LoadById</code>, <code>LoadByName</code>这样的函数。</p>
<p>However, because implicit composition is really just a compiler trick, we can “overwrite” the functions of a composed type.<br>For example, our <code>Saiyan</code> structure can have its own <code>Introduce</code> function:<br>但是，因为非显示的组合是一个编辑器技巧，我们可以“重写”组合类型的函数。比如， 我们的<code>Saiyan</code>结构体可以有自己的<code>Introduce</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Saiyan)</span> <span class="title">Introduce</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hi, I'm %s. Ya!\n"</span>, s.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The composed version is always available via <code>s.Person.Introduce()</code>.</p>
<p>组合版本中使用<code>s.Person.Introduce()</code>也是一样的。</p>
<h2 id="指针和值（Pointers-versus-Values）"><a href="#指针和值（Pointers-versus-Values）" class="headerlink" title="指针和值（Pointers versus Values）"></a>指针和值（Pointers versus Values）</h2><p>As you write Go code, it’s natural to ask yourself <em>should this be a value, or a pointer to a value?</em> There are two pieces of good news.<br>First, the answer is the same regardless of which of the following we’re talking about:</p>
<p>当你写Go代码的时候，你很自然的就会问你自己<em>这应该是要用值还是要用指针?</em>下面是两个好消息。首先，下面讨论的这些话题是没有什么差别的：</p>
<ul>
<li><p>A local variable assignment</p>
</li>
<li><p>Field in a structure</p>
</li>
<li><p>Return value from a function</p>
</li>
<li><p>Parameters to a function</p>
</li>
<li><p>The receiver of a method</p>
</li>
<li><p>局部变量赋值</p>
</li>
<li><p>结构体中的字段</p>
</li>
<li><p>函数的返回值</p>
</li>
<li><p>函数的参数</p>
</li>
<li><p>方法的接收者</p>
</li>
</ul>
<p>Secondly, if you aren’t sure, use a pointer.<br>其次，如果你不确定，就用指针好了。</p>
<p>As we already saw, passing values is a great way to make data immutable<br>(changes that a function makes to it won’t be reflected in the calling code).<br>Sometimes, this is the behavior that you’ll want but more often, it won’t be.</p>
<p>就如我们看到的那样，传值是一个让值不可变的好方法（函数内的改变不会影响调用代码中的值）。有些时候，我们却时希望如此，可常常不是这样的。<br>Even if you don’t intend to change the data, consider the cost of creating a copy of large structures.<br>Conversely, you might have small structures, say:</p>
<p>就算你不想改变值，想一下创建一个大结构体拷贝的开销。相反地，你可能有一个小结构体，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">  X <span class="keyword">int</span></span><br><span class="line">  Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In such cases, the cost of copying the structure is probably offset by being able to access <code>X</code> and <code>Y</code> directly, without any indirection.</p>
<p>在这种情况下，拷贝结构体的开销可以通过偏移量来直接访问<code>X</code>和<code>Y</code>，而不是间接访问。<br>Again, these are all pretty subtle cases. Unless you’re iterating over thousands or possibly tens of thousands of such points, you wouldn’t notice a difference.</p>
<p>再次指出，这些只是非常微妙的情况。除非你要访问成千上百个这样的点，否则你不会察觉有任何的不同。</p>
<h2 id="继续之前（Before-You-Continue）"><a href="#继续之前（Before-You-Continue）" class="headerlink" title="继续之前（Before You Continue）"></a>继续之前（Before You Continue）</h2><p>From a practical point of view, this chapter introduced structures, how to make an instance of a structure a receiver of a function, and added pointers to our existing knowledge of Go’s type system. The following chapters will build on what we know about structures as well as the inner workings that we’ve explored.</p>
<p>本章从实践的角度来看，介绍了结构体，以及如何创建方法接收器的结构体实例，并在我们现有的Go知识体系中引入了指针。<br>下面的章节将基于我们所知道的结构体知识来探讨其内部运行机制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-1/" class="post-title-link" itemprop="url">Go Little Book - 第一章 - 基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:03:33" itemprop="dateCreated datePublished" datetime="2018-11-22T10:03:33+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:55" itemprop="dateModified" datetime="2018-12-05T10:40:55+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-基础（Chapter-1-The-Basics）"><a href="#第一章-基础（Chapter-1-The-Basics）" class="headerlink" title="第一章 - 基础（Chapter 1 - The Basics）"></a>第一章 - 基础（Chapter 1 - The Basics）</h1><p>Go is a compiled, statically typed language with a C-like syntax and garbage collection. What does that mean?</p>
<p>Go是一门静态类型、编译型语言，有类C风格的语法和垃圾回收机制。这意味着什么呢？</p>
<h2 id="编译（Compilation）"><a href="#编译（Compilation）" class="headerlink" title="编译（Compilation）"></a>编译（Compilation）</h2><p>Compilation is the process of translating the source code that you write into a lower level language – either assembly (as is the case with Go), or some other intermediary language (as with Java and C#).</p>
<p>编译将你写的源代码转换成一种更低级的语言————可能是汇编（如Go就是这样），或者其他中间语言（如Java和C#）的过程。</p>
<p>Compiled languages can be unpleasant to work with because compilation can be slow. It’s hard to iterate quickly if you have to spend minutes or hours waiting for code to compile. Compilation speed is one of the major design goals of Go. This is good news for people working on large projects as well as those of us used to a quick feedback cycle offered by interpreted languages.</p>
<p>因为编译可能很慢，使用编译型语言可能不是个令人愉快的事情。很难实现快速迭代因为你不得不花几分钟甚至几个小时的时间来等待编绎完成。编译速度是Go设计时的一个主要目标。这对于大项目的开发人员来说是个好消息，就像我们可以使用解释语言提供的快速反馈周期。</p>
<p>Compiled languages tend to run faster and the executable can be run without additional dependencies (at least, that’s true for languages like C, C++ and Go which compile directly to assembly).</p>
<p>编译型语言往往运行得更快，不需要额外的依赖也可以正常运行（至少，像C、C++和Go这样直接编译成汇编的语言来说，就是如此。）</p>
<h2 id="静态类型（Static-Typing）"><a href="#静态类型（Static-Typing）" class="headerlink" title="静态类型（Static Typing）"></a>静态类型（Static Typing）</h2><p>Being statically typed means that variables must be of a specific type (int, string, bool, []byte, etc.). This is either achieved by specifying the type when the variable is declared or, in many cases, letting the compiler infer the type (we’ll look at examples shortly).</p>
<p>静态类型是指变量必须指定一个类型（整型、字符串、布尔、字节数组等等）。可以在申明变量的时候指定数据类型，也可以,大多数情况是让编译器来推断类型（我们将会在接下来的例子中看到）。</p>
<p>There’s a lot more that can be said about static typing, but I believe it’s something better understood by looking at code. If you’re used to dynamically typed languages, you might find this cumbersome. You’re not wrong, but there are advantages, especially when you pair static typing with compilation. The two are often conflated. It’s true that when you have one, you normally have the other but it isn’t a hard rule. With a rigid type system, a compiler is able to detect problems beyond mere syntactical mistakes as well as make further optimizations.</p>
<p>关于静态类型还有很多可以介绍，但我相信理解它更好的方式是阅读代码。如果你习惯于动态语言，你可能觉得这比较麻烦。没错，不过静态类型也有优势，尤其是和编译相结合的时候。静态类型和编译这两者经常被混为一谈。虽然这不是硬性的规定，但通常情况下，有其一就必有其二。在严格类型系统中，编译器除了能够检测出单纯的语法错误问题还能做出进一步的优化。</p>
<h2 id="类C语法（C-Like-Syntax）"><a href="#类C语法（C-Like-Syntax）" class="headerlink" title="类C语法（C-Like Syntax）"></a>类C语法（C-Like Syntax）</h2><p>Saying that a language has a C-like syntax means that if you’re used to any other C-like languages such as C, C++, Java, JavaScript and C#, then you’re going to find Go familiar – superficially, at least. For example, it means <code>&amp;&amp;</code> is used as a boolean AND, <code>==</code> is used to compare equality, <code>{</code> and <code>}</code> start and end a scope, and array indexes start at 0.</p>
<p>说一门语言有一个类C的语法意味着，如果你使用的任何其他类似C语言，如C，C ++，Java，JavaScript以及C＃，那么你会发现Go的相似之处————至少从表面上看。比如，<code>&amp;&amp;</code>表示逻辑与,<code>==</code>表示相等判断，<code>{}</code>和<code>}</code>是作用域的开始和结束，以及数组从0开始索引。</p>
<p>C-like syntax also tends to mean semi-colon terminated lines and parentheses around conditions. Go does away with both of these, though parentheses are still used to control precedence. For example, an <code>if</code> statement looks like this:</p>
<p>类C语法也往往使用分号结束行和条件表达式用括号括起来。Go没用使用这两种方式，尽管依然使用括号来控制优先权。比如，一个<code>if</code>表达式看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">"Leto"</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"the spice must flow"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And in more complicated cases, parentheses are still useful:</p>
<p>在更复杂的情况下，括号依然有用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name == <span class="string">"Goku"</span> &amp;&amp; power &gt; <span class="number">9000</span>) || (name == <span class="string">"gohan"</span> &amp;&amp; power &lt; <span class="number">4000</span>)  &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"super Saiyan"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Beyond this, Go is much closer to C than C# or Java - not only in terms of syntax, but in terms of purpose. That’s reflected in the terseness and simplicity of the language which will hopefully start to become obvious as you learn it.</p>
<p>除此之外，Go比C#或者Java更接近C，不仅在语法方面，还在用途方面。这体现在语言风格的简洁和简单，随着不断深入学习，你会越来越明显的体会到这种特性。</p>
<h2 id="垃圾回收机制（Garbage-Collected）"><a href="#垃圾回收机制（Garbage-Collected）" class="headerlink" title="垃圾回收机制（Garbage Collected）"></a>垃圾回收机制（Garbage Collected）</h2><p>Some variables, when created, have an easy-to-define life. A variable local to a function, for example, disappears when the function exits. In other cases, it isn’t so obvious – at least to a compiler. For example, the lifetime of a variable returned by a function or referenced by other variables and objects can be tricky to determine. Without garbage collection, it’s up to developers to free the memory associated with such variables at a point where the developer knows the variable isn’t needed. How? In C, you’d literally <code>free(str);</code> the variable.</p>
<p>一些变量，在创建时就有明确的生命周期。如函数内的局部变量，当函数结束时就消失了。在另一些情况下，就没有这么明显了，起码对编译器来说是这样。比如函数中返回的变量，变量的引用和对象的引用的生命周期就很难判断了。没有垃圾回收机制的情况下，这依赖于开发人员在不需要这些变量时进行内存的释放。怎么实现？例如在c中，你需要正确的去释放一个变量的内存<code>free(str);</code>。</p>
<p>Languages with garbage collectors (e.g., Ruby, Python, Java, JavaScript, C#, Go) are able to keep track of these and free them when they’re no longer used. Garbage collection adds overhead, but it also eliminates a number of devastating bugs.</p>
<p>有垃圾回收机制的语言（如Ruby、Python、Java、JavaScript、C#、Go）能记录变量并在不使用时进行释放。垃圾回收机制增加了开销，但也杜绝了一些破坏性的bug。</p>
<h2 id="运行Go代码（Running-Go-Code）"><a href="#运行Go代码（Running-Go-Code）" class="headerlink" title="运行Go代码（Running Go Code）"></a>运行Go代码（Running Go Code）</h2><p>Let’s start our journey by creating a simple program and learning how to compile and execute it. Open your favorite text editor and write the following code:</p>
<p>让我们创建一个简单的例子来学习如何编译和运行它，来开始我们的Go学习之旅。打开你最喜欢的文本编辑器，输入如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"it's over 9000!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Save the file as <code>main.go</code>. For now, you can save it anywhere you want; we don’t need to live inside Go’s workspace for trivial examples.</p>
<p>将文件保存为<code>main.go</code>。开始，你可以将它保存在任何你想要的地方；作为简单的例子，我们还不需要深入理解Go的工作区。</p>
<p>Next, open a shell/command prompt and change the directory to where you saved the file. For me, that means typing <code>cd ~/code</code>.</p>
<p>接下来，打开一个shell/命令行，然后将目录切换到你保存文件的位置。对我来，输入<code>cd ~/code</code>就可以了。</p>
<p>Finally, run the program by entering:</p>
<p>最后，能过输入如下命令来运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure>

<p>If everything worked, you should see <em>it’s over 9000!</em>.</p>
<p>如果一切正常，你会看到 <em>it’s over 9000!</em>。</p>
<p>But wait, what about the compilation step? <code>go run</code> is a handy command that compiles <em>and</em> runs your code. It uses a temporary directory to build the program, executes it and then cleans itself up. You can see the location of the temporary file by running:</p>
<p>等等，那编译过程呢？<code>go run</code>是一个方便的编译和执行代码的命令。它使用临时目录来生成程序和运行，然后清理。通过下面的代码你可以查看临时文件所在位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run --work main.go</span><br></pre></td></tr></table></figure>

<p>To explicitly compile code, use <code>go build</code>:</p>
<p>要显示的编译代码，使用<code>go build</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure>

<p>This will generate an executable <code>main</code> which you can run. On Linux / OSX, don’t forget that you need to prefix the executable with dot-slash, so you need to type <code>./main</code>.</p>
<p>这会生成一个可执行的<code>main</code>程序。在Linux/OSX中，不要忘记在可执行文件前面加上点和反斜杠，所有你需要输入<code>./main</code>。</p>
<p>While developing, you can use either <code>go run</code> or <code>go build</code>. When you deploy your code however, you’ll want to deploy a binary via <code>go build</code> and execute that.</p>
<p>在开发的时候，你可以使用<code>go run</code>或者<code>go build</code>。但当你发布的时候，你需要使用<code>go build</code>来生成可执行文件并运行它。</p>
<h3 id="主函数（Main）"><a href="#主函数（Main）" class="headerlink" title="主函数（Main）"></a>主函数（Main）</h3><p>Hopefully, the code that we just executed is understandable. We’ve created a function and printed out a string with the built-in <code>println</code> function. Did <code>go run</code> know what to execute because there was only a single choice? No. In Go, the entry point to a program has to be a function called <code>main</code> within a package <code>main</code>.</p>
<p>但愿，我们刚刚的执行的代码是可以理解的。我们创建了一个函数，它调用内置的<code>println</code>函数打印一个字符串。难道是因为只有一个选择，所以<code>go run</code>才知道要执行什么吗？不是的，在Go语言中，程序的入口是<code>main</code>包中的<code>main</code>函数。</p>
<p>We’ll talk more about packages in a later chapter. For now, while we focus on understanding the basics of Go, we’ll always write our code within the <code>main</code> package.</p>
<p>后续章节我们会介绍更多包的内容。现在，为了我们着重理解Go的基础知识，我们只在<code>main</code>包中写代码。</p>
<p>If you want, you can alter the code and change the package name. Run the code via <code>go run</code> and you should get an error. Then, change the name back to <code>main</code> but use a different function name. You should see a different error message. Try making those same changes but use <code>go build</code> instead. Notice that the code compiles, there’s just no entry point to run it. This is perfectly normal when you are, for example, building a library.</p>
<p>如果你愿意，你也可以修改代码并改变包名89。并使用<code>go run</code>去执行，你会得到一个错误信息。然后，将包名改成<code>main</code>，但是函数名不叫<code>main</code>，再次运行代码，你会得到一个不同的错误信息。使用<code>go build</code>进行相同的操作，注意编译代码时，这里没有运行代码的入口点。这是很正常的，例如当你编译一个库时。</p>
<h2 id="包导入（Imports）"><a href="#包导入（Imports）" class="headerlink" title="包导入（Imports）"></a>包导入（Imports）</h2><p>Go has a number of built-in functions, such as <code>println</code>, which can be used without reference. We can’t get very far though, without making use of Go’s standard library and eventually using third-party libraries. In Go, the <code>import</code> keyword is used to declare the packages that are used by the code in the file.</p>
<p>Go有一些内建函数是不需要引入就可以直接使用，如<code>println</code>。不利用Go标准库和第三方类库的话，我们不能走得很远。在Go中，使用<code>import</code>关键字来申明代码中使用的包。</p>
<p>Let’s change our program:<br>让我们来修改下程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"It's over "</span>, os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which you can run via:</p>
<p>通过下面的命令来运行它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go 9000</span><br></pre></td></tr></table></figure>

<p>We’re now using two of Go’s standard packages: <code>fmt</code> and <code>os</code>. We’ve also introduced another built-in function <code>len</code>. <code>len</code> returns the size of a string, or the number of values in a dictionary, or, as we see here, the number of elements in an array. If you’re wondering why we expect 2 arguments, it’s because the first argument – at index 0 – is always the path of the currently running executable. (Change the program to print it out and see for yourself.)</p>
<p>我们用了两个Go的标准包：<code>fmt</code>和<code>os</code>。我们引入了另一个内建函数<code>len</code>。<code>len</code>返加字符串的长度，或者字典的个数，再或者，如这个例子，数组元素的个数。如果你想知道为什么我们期望是两个参数，这是因为索引为0的第一个参数是当前可执程序的路径（你可以自己修改代码将它打印出来看看）。</p>
<p>You’ve probably noticed we prefix the function name with the package, e.g., <code>fmt.Println</code>. This is different from many other languages. We’ll learn more about packages in later chapters. For now, knowing how to import and use a package is a good start.</p>
<p>你可能已经注意到了函数名之前的包名了，比如：<code>fmt.Println</code>，这和其他很多语言不同。后续章节我们会学习更多包的内容。现在，知道如何导入和使用包就好了。</p>
<p>Go is strict about importing packages. It will not compile if you import a package but don’t use it. Try to run the following:</p>
<p>Go对包导入很严格。如果导入了包，但没有使用是不能通过编译的。试试运行下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You should get two errors about <code>fmt</code> and <code>os</code> being imported and not used. Can this get annoying? Absolutely. Over time, you’ll get used to it (it’ll still be annoying though). Go is strict about this because unused imports can slow compilation; admittedly a problem most of us don’t have to this degree.</p>
<p>你会看到两个错误信息，显示<code>fmt</code>和<code>os</code>包被导入但是没有被使用。这会让人烦吗？绝对的。随着时间的推移，你会习惯（虽然还是烦人）。Go之所以在这点上这么严格是因为导入未使用的包会影响编译速度。不可否认的是，我们大多数人都没有这个深度。</p>
<p>Another thing to note is that Go’s standard library is well documented. You can head over to <a href="http://golang.org/pkg/fmt/#Println" target="_blank" rel="noopener">http://golang.org/pkg/fmt/#Println</a> to learn more about the <code>Println</code> function that we used. You can click on that section header and see the source code. Also, scroll to the top to learn more about Go’s formatting capabilities.</p>
<p>令一个值得注意的地方就是Go的标准包的文档很完善。你可以通过<a href="http://golang.org/pkg/fmt/#Println" target="_blank" rel="noopener">http://golang.org/pkg/fmt/#Println</a> 来学习更多我们用到过的<code>Println</code>的内容。你可以点击章节标题来查看源码。也可以滚动到顶部来查看更多关于Go格式化的功能。</p>
<p>If you’re ever stuck without internet access, you can get the documentation running locally via:<br>如果你不能访问网络，你可以通过下面的方面运行本地的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http&#x3D;:6060</span><br></pre></td></tr></table></figure>

<p>and pointing your browser to <code>http://localhost:6060</code></p>
<p>然后通过<code>http://localhost:6060</code>来浏览。</p>
<h2 id="变量和声明（Variables-and-Declarations）"><a href="#变量和声明（Variables-and-Declarations）" class="headerlink" title="变量和声明（Variables and Declarations）"></a>变量和声明（Variables and Declarations）</h2><p>It’d be nice to begin and end our look at variables by saying <em>you declare and assign to a variable by doing x = 4.</em> Unfortunately, things are more complicated in Go. We’ll begin our conversation by looking at simple examples. Then, in the next chapter, we’ll expand this when we look at creating and using structures. Still, it’ll probably take some time before you truly feel comfortable with it.</p>
<p><em>通过x = 4就能声明和赋值变量</em> ，对你来说可能是一个好的开始和结束。不幸的是，Go中要复杂一些。我们将通过简单的例子来开始我们的话题。然后，我们会在下一章节中，在讲解分创建的使用结构体的时候，我们会展开来讲解。但是，你可以需要花一些时间来适应它。</p>
<p>You might be thinking <em>Woah! What can be so complicated about this?</em> Let’s start looking at some examples.</p>
<p>你可能会觉得 <em>哇！为什么这么复杂?</em>让我们来看些例子吧。</p>
<p>The most explicit way to deal with variable declaration and assignment in Go is also the most verbose:</p>
<p>在Go中最直接也是最繁索的变量声明和赋值方式是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> power <span class="keyword">int</span></span><br><span class="line">  power = <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"It's over %d\n"</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, we declare a variable <code>power</code> of type <code>int</code>. By default, Go assigns a zero value to variables. Integers are assigned <code>0</code>, booleans <code>false</code>, strings <code>&quot;&quot;</code> and so on. Next, we assign <code>9000</code> to our <code>power</code> variable. We can merge the first two lines:</p>
<p>这里，我们声明了一个<code>int</code>类型的变量<code>power</code>。默认情况下，Go给变量赋为0值。整型赋为<code>0</code>，布尔型赋为<code>false</code>，字符串赋为<code>&quot;&quot;</code>等等。接着，我们给变量<code>power</code>赋值为<code>9000</code>。我们可以合并开始的这两行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> power <span class="keyword">int</span> = <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>Still, that’s a lot of typing. Go has a handy short variable declaration operator, <code>:=</code>, which can infer the type:</p>
<p>依然，还是需要很多的输入。Go有更方便的变量声明操作符，<code>:=</code>，它可以推断类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power := <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>This is handy, and it works just as well with functions:</p>
<p>这很方便，对函数也同样适用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := getPower()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPower</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">9001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It’s important that you remember that <code>:=</code> is used to declare the variable as well as assign a value to it. Why? Because a variable can’t be declared twice (not in the same scope anyway). If you try to run the following, you’ll get an error.</p>
<p>记住<code>:=</code>用于声明和赋值变量这点很重要。为什么呢？因为一个变量不能被声明两次（在同一个作用域中）。如果你尝试运行下面的代码，你会看到一个错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"It's over %d\n"</span>, power)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// COMPILER ERROR:</span></span><br><span class="line">  <span class="comment">// no new variables on left side of :=</span></span><br><span class="line">  power := <span class="number">9001</span></span><br><span class="line">  fmt.Printf(<span class="string">"It's also over %d\n"</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The compiler will complain with <em>no new variables on left side of :=</em>. This means that when we first declare a variable, we use <code>:=</code> but on subsequent assignment, we use the assignment operator <code>=</code>. This makes a lot of sense, but it can be tricky for your muscle memory to remember when to switch between the two.</p>
<p>编译器会抱错提示 <em>:=左边不是新的变量</em>。这就是说我们一开始用<code>:=</code>来声明一个变量，接下来我们需要用<code>=</code>来给变量赋值。这很用意义，但是对你的记忆力来说是一个负担，因为你要记住这两者之间切换的时机。</p>
<p>If you read the error message closely, you’ll notice that <em>variables</em> is plural. That’s because Go lets you assign multiple variables (using either <code>=</code> or <code>:=</code>):</p>
<p>如果你仔细看错误信息，你会发现 <em>变量</em>用了复数形式。因为Go支持多个变量同时赋值（使用<code>=</code>或者<code>:=</code>）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name, power := <span class="string">"Goku"</span>, <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"%s's power is over %d\n"</span>, name, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As long as one of the variables is new, <code>:=</code> can be used. Consider:</p>
<p>只要有一个变量是新的就可以使用<code>:=</code> 操作符。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := <span class="number">1000</span></span><br><span class="line">  fmt.Printf(<span class="string">"default power is %d\n"</span>, power)</span><br><span class="line"></span><br><span class="line">  name, power := <span class="string">"Goku"</span>, <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"%s's power is over %d\n"</span>, name, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Although <code>power</code> is being used twice with <code>:=</code>, the compiler won’t complain the second time we use it, it’ll see that the other variable, <code>name</code>, is a new variable and allow <code>:=</code>. However, you can’t change the type of <code>power</code>. It was declared (implicitly) as an integer and thus, can only be assigned integers.</p>
<p>虽然变量<code>power</code>使用了<code>:=</code>，但是编译器不会在第2次使用<code>:=</code>时报错，因为这里有一个新变量<code>name</code>，允许使用<code>:=</code>。但你不能改变<code>power</code>的类型。它已经被声明（隐式的）为整型，所以只能用整数来赋值。</p>
<p>For now, the last thing to know is that, like imports, Go won’t let you have unused variables. For example,</p>
<p>最后，和包导入一样，Go不允许未使用的变量。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name, power := <span class="string">"Goku"</span>, <span class="number">1000</span></span><br><span class="line">  fmt.Printf(<span class="string">"default power is %d\n"</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>won’t compile because <code>name</code> is declared but not used. Like unused imports it’ll cause some frustration, but overall I think it helps with code cleanliness and readability.</p>
<p>不会被编译因为变量<code>name</code>声明了但没有使用。和包导入一样会带来一些挫败感，但总的来说，这是为了代码的简洁和可读性。</p>
<p>There’s more to learn about declaration and assignments. For now, remember that you’ll use <code>var NAME TYPE</code> when declaring a variable to its zero value, <code>NAME := VALUE</code> when declaring and assigning a value, and <code>NAME = VALUE</code> when assigning to a previously declared variable.</p>
<p>声明和赋值还有内容需要学习。现在，只要记住，用<code>var NAME TYPE</code>来声明变量并赋0值，用<code>NAME := VALUE</code>声明变量并赋值，和用<code>NAME = VALUE</code>给已声明的变量赋值。</p>
<h2 id="函数声明（Function-Declarations）"><a href="#函数声明（Function-Declarations）" class="headerlink" title="函数声明（Function Declarations）"></a>函数声明（Function Declarations）</h2><p>This is a good time to point out that functions can return multiple values. Let’s look at three functions: one with no return value, one with one return value, and one with two return values.</p>
<p>现在是一个好的时机来指出函数是可以有多返回值的。让我们来看3个函数：一个没有返回值，一个有一个返回值，另一个有两个返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">power</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’d use the last one like so:<br>我们像这样来使用最后一个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, exists := power(<span class="string">"goku"</span>)</span><br><span class="line"><span class="keyword">if</span> exists == <span class="literal">false</span> &#123;</span><br><span class="line">  <span class="comment">// handle this error case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sometimes, you only care about one of the return values. In these cases, you assign the other values to <code>_</code>:</p>
<p>有时，你可能只关心其中一个返回值。在这种情况下，你可以把其他值赋为<code>_</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, exists := power(<span class="string">"goku"</span>)</span><br><span class="line"><span class="keyword">if</span> exists == <span class="literal">false</span> &#123;</span><br><span class="line">  <span class="comment">// handle this error case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is more than a convention. <code>_</code>, the blank identifier, is special in that the return value isn’t actually assigned. This lets you use <code>_</code> over and over again regardless of the returned type.</p>
<p>这不仅仅是一个约定。<code>_</code>，空白标识符，尤其在用在返回值时它没有真正的赋值。无论返回值是什么类型你都可以使用<code>_</code>。</p>
<p>Finally, there’s something else that you’re likely to run into with function declarations. If parameters share the same type, we can use a shorter syntax:</p>
<p>最后，你可能遇到一些不同的函数声明方式。如果函数的参数类型都相同，那么可以用以下更简洁的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Being able to return multiple values is something you’ll use often. You’ll also frequently use <code>_</code> to discard a value. Named return values and the slightly less verbose parameter declaration aren’t that common. Still, you’ll run into all of these sooner than later so it’s important to know about them.</p>
<p>你会常常用到函数多返回值这个特性。你也会经常使用<code>_</code>去舍弃一个返回值。具名返回值和无名参数声明并不常见。但是迟早你都会遇到，最好对他们都有所了解。</p>
<h2 id="继续之前（Before-You-Continue）"><a href="#继续之前（Before-You-Continue）" class="headerlink" title="继续之前（Before You Continue）"></a>继续之前（Before You Continue）</h2><p>We looked at a number of small individual pieces and it probably feels disjointed at this point. We’ll slowly build larger examples and hopefully, the pieces will start to come together.</p>
<p>现在我们已经学习了许多的小知识点，你可能会觉得有点脱节。我们会逐步构建一个更大的例子，有望将这些小知识点串联起来。</p>
<p>If you’re coming from a dynamic language, the complexity around types and declarations might seem like a step backwards. I don’t disagree with you. For some systems, dynamic languages are categorically more productive.</p>
<p>如果你是来自动态类型语言的开发人员，你可能会觉得Go的变量类型和声明的复杂是一种倒退。我同意你的看法。对于一些系统，动态类型的语言绝对更有效率。</p>
<p>If you’re coming from a statically typed language, you’re probably feeling comfortable with Go. Inferred types and multiple return values are nice (though certainly not exclusive to Go). Hopefully as we learn more, you’ll appreciate the clean and terse syntax.</p>
<p>如果你是来自静态类型语言的开发人员，你可能会习惯使用Go。类型推断和多返回值是如此的美好（尽管这不是Go独有的）。希望随着我们不断深入的学习，你会喜欢上Go干净和简洁的语法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/getting-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/getting-start/" class="post-title-link" itemprop="url">Go Little Book - 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:02:33" itemprop="dateCreated datePublished" datetime="2018-11-22T10:02:33+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:40" itemprop="dateModified" datetime="2018-12-05T10:40:40+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>如果你想试试Go，你可以使用Go运行环境，它可以让你无需安装任何东西就可以在网上运行代码。这也是在Go论坛如StackOverflow中寻求帮助时，分享Go代码最常用的方式。</p>
<p>安装Go很简单。你可以从源码安装，但我建议你用一个已编译好的可执行文件。当你打开下载页面时，你可以看到不同平台的安装包。让我们避免使用这些并学习自己如何配置Go。然后你就会发现这不难。</p>
<p>除了简单的例子，Go被设计成只有你的代码在工作区时才能正常运行。这个工作区是有<code>bin</code>、<code>pkg</code>和<code>src</code>三个子目录的文件夹。你也许会想强制Go去适应你自己的风格 - 别想。</p>
<p>通常，我把我的项目放在<code>~/code</code>目录下。例如，<code>~/code/blog</code>是我的博客。对于Go来说，我的工作区是<code>~/code/go</code>，而我Go版本的博客会在<del>/code/go/src/blog下。因为这经常用到，我做了个符号链接，通过`</del>/code/blog`来访问它：</p>
<pre><code>ln -s ~/code/go/src/blog ~/code/blog</code></pre><p>总之，无论你把你的项目放在哪，创建一个Go目录包含src子目录来放置你的项目。</p>
<h2 id="OSX-Linux"><a href="#OSX-Linux" class="headerlink" title="OSX / Linux"></a>OSX / Linux</h2><p>下载你平台对应<code>tar.gz</code>。OSX，你需要关心<code>go#.#.#.darwin-amd64-osx10.8.tar.gz</code>，其中<code>#.#.#</code>表示Go的最新版本。</p>
<p>通过<code>tar -C /usr/local -xzf go#.#.#.darwin-amd64-osx10.8.tar.gz</code>将文件解压到<code>/usr/local</code>目录。</p>
<p>设置两个环境变量：</p>
<ol>
<li><code>GOPATH</code>指向你的工作区，对我来说是<code>$HOME/code/go</code>。</li>
<li>我们需要将Go可执行文件的路径添加到<code>PATH</code>。</li>
</ol>
<p>你可以通过shell来完成设置：</p>
<pre><code>echo &apos;export GOPATH=$HOME/code/go&apos; &gt;&gt; $HOME/.profile
echo &apos;export PATH=$PATH:/usr/local/go/bin&apos; &gt;&gt; $HOME/.profile</code></pre><p>为了使这些变量生效，你需要关闭并重新打开你的Shell，或者运行<code>source $HOME/.profile</code>命令。</p>
<p>输入<code>go version</code>,你会看到类似这样的输出<code>go version go1.3.3</code>。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>下载最新的zip文件。如果你是x64系统，你需要下载<code>go#.#.#.windows-amd64.zip</code>，其中<code>#.#.#</code>表示Go的最新版本。</p>
<p>将其解压到你想要的位置。<code>c:\Go</code>是个不错和选择。</p>
<p>Set up two environment variables:<br>设置两个环境变理：</p>
<ol>
<li><code>GOPATH</code> 指向你的工作区. 可以是这样的目录<code>c:\users\goku\work\go</code>。</li>
<li>添加 <code>c:\Go\bin</code> 至你的<code>PATH</code>环境变量中。</li>
</ol>
<p>环境变量可以通过<code>系统</code>控制面板中的<code>环境变量</code>按钮中的<code>高级</code>标签页来设置。某些版本的Windows通过<code>System</code>控制面板里面的<code>高级系统Settings</code>选项提供该控制面板。</p>
<p>打开一个命令行窗口，输入<code>go version</code>，你会看到类似这样的输出<code>go version go1.3.3 windows/amd64</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/introduction/" class="post-title-link" itemprop="url">Go Little Book - 引言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:01:11" itemprop="dateCreated datePublished" datetime="2018-11-22T10:01:11+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-08 21:04:05" itemprop="dateModified" datetime="2018-12-08T21:04:05+08:00">2018-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>每当我学习一门新语言的时候总是爱恨交加。一方面，语言是如此的重要，以至于一点小的变化对我们产生的不可估量的影响。在你的程序和可以重新定义你对其他语言的期望的时候，你会有一个持久的效果。同时，语言的设计是增量的。学习新的关键字、类型体系、编码方式以及新类库、通讯和范式需要很多工作，但又很难评估。相对学习其他必学的东西，学习新语言让我们常常感觉是对时间的投入很大。</p>
<p>也就是说，我们要进步。我们必须愿意采用渐进的方式，又一次因为，语言是我们的基础。虽然变化是增量的，但它们往往范围很广，它们影响效率，可读性、性能、可测试性、依赖管理、错误处理、文档、分析（监控？）、通讯、标准库等等。除了说千刀万剐我们还能说什么？</p>
<p>这留给我们一个重要的问题：为什么选Go？对我来说，有两个令人信服的理由。首先它是一门相对简单的语言，还自带相对简单的标准库。在很多方面，Go的增量本质简化了我们已经看到的在过去几十年引入的语言的复杂性。另一个原因对于很多开发者来说，它会完善你的军火库。</p>
<p>Go被构建为一个系统语言（比如操作系统、设备驱动）并且面向C和C++开发人员。纵观Go的社群，我非常确信，应用开发者，而非系统开发者已经成为Go的主要使用者。为什么？我不能代表系统开发者，但是我们建设的网站、服务、桌面应用等等，这些面向新兴需求可归结为一类介于低层次的系统应用程序和更高级别的应用程序之间的系统。</p>
<p>也许它是一个消息，缓存，大数据分析，命令行接口，日志或监控。我不知如何标记它，但是在我的职业身涯中，由于系统的复杂性不断和频繁并发数以万计的增长，定制的基础设施类系统成为一个不断增长的需求。你可以用Ruby或Python或别的东西（确实很多人这么做）来构建这样的系统，如果使用Go，这些系统可以有一个更严格的类型系统和更高的性能优势。同样，您可以使用Go建立网站（确实很多人这样做），但，为了更大的回旋余地，我还是喜欢使用Node或Ruby的来构建这类系统。</p>
<p>还有一些Go的长处。比如，运行Go程序时没有依赖。你不需要担心你的用户是否已经安装了Ruby或者JVM和它们的版本。因为这个原因，Go作为命令行程序或者需要分发的其他类型的实用程序（比如日志收集器）开发语言，越来越流行了。</p>
<p>简单地说，学习Go是一种有效利用你的时间。你将不必花费很长时间来学习甚至掌握go，你可以通过一些实践来达成。</p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>我曾犹豫写这本小册子有几个原因。首先Go有自已的文档，特别是高效Go，它很实在（实用？）。</p>
<p>另一个原因是我写一本关于语言的书时的不适。当我写MongoDB小册子的时候，你可以假设很多读者理解基本的关系型数据库和模型。写Redis小册子的时候，你可以假设从一个熟悉的键值存储开始。</p>
<p>当想到摆在面前的段落和章节的时候，我知道我不能做这样的假设。你要花多少时间来讲解接口，因为对于一些人来说这是一个新概念，而另个一些人已经不需用再了解了。最终，我会感到欣慰如果你让我知道有些部分是太浅或过于详细。考虑一下这本书的价格。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/about/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/about/" class="post-title-link" itemprop="url">Go Little Book - 关于本书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:00:00" itemprop="dateCreated datePublished" datetime="2018-11-22T10:00:00+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:59" itemprop="dateModified" datetime="2018-12-05T10:40:59+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>289</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h1><h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p>本书使用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享4.0</a>许可。你不需要为本书付费。你可以自由的拷贝、发布、修改或展示本书。但是，我要求本书必须用我本人（Karl Seguin）的署名，同时不能作为经济用途。</p>
<p>你可在以下链接中查看到该许可的所有内容：</p>
<p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">http://creativecommons.org/licenses/by-nc-sa/4.0/</a></p>
<h2 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h2><p>本书最新源码的放在：<a href="http://github.com/karlseguin/the-little-go-book" target="_blank" rel="noopener">http://github.com/karlseguin/the-little-go-book</a></p>
<p>中文译本最新源码的放在：<a href="http://github.com/enderjo/the-little-go-book" target="_blank" rel="noopener">http://github.com/enderjo/the-little-go-book</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/21/frontend/nodejs/yarn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/frontend/nodejs/yarn/" class="post-title-link" itemprop="url">YARN命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 17:14:33" itemprop="dateCreated datePublished" datetime="2018-11-21T17:14:33+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-26 11:51:13" itemprop="dateModified" datetime="2019-04-26T11:51:13+08:00">2019-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/frentend/" itemprop="url" rel="index"><span itemprop="name">frentend</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/frentend/nodejs/" itemprop="url" rel="index"><span itemprop="name">nodejs</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>自己用Hexo来做博客而用到了nodejs和npm。但npm生成的<code>node-modules</code>层次过深，时常打开文件夹时会很慢。</p>
<p>后来了解到了yarn，在yarn发布之前，所有Nodejs开发者用的都是npm包管理工具，而npm工具存在挺多难以忍受的诟病，包括安装速度慢、每次都要在线重新安装等问题，而yarn也是为了解决npm当前所存在的问题而出现的。</p>
<p>为了方便自己使用，整理了下安装和基本操作。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>如果原先有npm工具的话，安装yarn很简单，只需要一行命令即可：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有npm工具，安装yarn可参照<a href="https://yarnpkg.com/en/docs/install" target="_blank" rel="noopener">各平台下yarn工具安装方式</a>。</li>
</ul>
<h2 id="更换安装源"><a href="#更换安装源" class="headerlink" title="更换安装源"></a>更换安装源</h2><p>安装yarn之后默认的包安装源是<a href="https://registry.yarnpkg.com，可用查看命令" target="_blank" rel="noopener">https://registry.yarnpkg.com，可用查看命令</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config get registry</span><br></pre></td></tr></table></figure>

<p>若想提高yarn安装的速度，可将包安装源修改为cnpm的安装源，执行以下命令即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry 'https://registry.npm.taobao.org'</span><br></pre></td></tr></table></figure>

<h2 id="操作及对比"><a href="#操作及对比" class="headerlink" title="操作及对比"></a>操作及对比</h2><table>
<thead>
<tr>
<th>操作</th>
<th>npm</th>
<th>yarn</th>
</tr>
</thead>
<tbody><tr>
<td>初始化项目</td>
<td>npm init</td>
<td>yarn init</td>
</tr>
<tr>
<td>安装依赖操作</td>
<td>npm install/link</td>
<td>yarn install/link</td>
</tr>
<tr>
<td>安装某个依赖，并且默认保存到package</td>
<td>npm install xxx —save</td>
<td>yarn add xxx</td>
</tr>
<tr>
<td>移除某个依赖项目</td>
<td>npm uninstall xxx   —save</td>
<td>yarn remove xxx</td>
</tr>
<tr>
<td>安装某个开发时依赖项目</td>
<td>npm install –save   -dev xxx</td>
<td>yarn add xxx —dev</td>
</tr>
<tr>
<td>更新某个依赖项目</td>
<td>npm update –save xxx</td>
<td>yarn upgrade xxx</td>
</tr>
<tr>
<td>安装某个全局依赖项目</td>
<td>npm install -g xxx</td>
<td>yarn global add xxx</td>
</tr>
<tr>
<td>发布/登录/登出，一系列NPM   Registry操作</td>
<td>npm   publish/login/logout</td>
<td>yarn   publish/login/logout</td>
</tr>
<tr>
<td>运行某个命令</td>
<td>npm run/test</td>
<td>yarn run/test</td>
</tr>
<tr>
<td>查看帮助</td>
<td>npm -h</td>
<td>yarn -h</td>
</tr>
</tbody></table>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="yarn-global"><a href="#yarn-global" class="headerlink" title="yarn global"></a>yarn global</h3><p>yarn 的全局安装并不是加 -g 或者 –global 这样的参数，它使用 <a href="https://yarnpkg.com/en/docs/cli/global" target="_blank" rel="noopener">yarn global</a> 命令。用 yarn global –help 可以看到子命令列表</p>
<p>这些子命令的用法和非 global 的同名命令用法差不多。</p>
<h3 id="指定bin目录"><a href="#指定bin目录" class="headerlink" title="指定bin目录"></a>指定bin目录</h3><p>对于一些带 CLI 的模块，通过 yarn global add 可能会出问题，yarn global bin查看目录，并把该目录添加到Path中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000007189426" target="_blank" rel="noopener">yarn —— Nodejs包新管理工具</a></p>
<p><a href="https://segmentfault.com/a/1190000008489881" target="_blank" rel="noopener">使用 yarn global 代替 npm -g</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/02/misc/tunnel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/02/misc/tunnel/" class="post-title-link" itemprop="url">打造自己的HTTPS安全遂道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-02 08:27:18" itemprop="dateCreated datePublished" datetime="2018-11-02T08:27:18+08:00">2018-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-22 08:51:48" itemprop="dateModified" datetime="2018-11-22T08:51:48+08:00">2018-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/misc/" itemprop="url" rel="index"><span itemprop="name">misc</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近刚好在做小程序的开发，需要用到本地调试，刚开始时使用<code>Natapp</code>的免费遂道，勉强能开发（域免），后面买了付费遂道，域名不变开发顺畅起来。但要真机调试时还是不行，微信不认三级域名，需要购买他的二级域名服务。转念一想还不如自己搭建一个呢，成本可控，也只要折腾一次就好，反正也能学东西。于是也就有了本文。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>一台云主机，可在购买<a href="https://promotion.aliyun.com/ntms/act/qwbk.html#share_box?spm=5176.11533457.1089570.36.15da77e3g6I8CL&aliyunapp_auto_login=true&userCode=l7irb6oi" target="_blank" rel="noopener">阿里云</a>，开放对应端口。</li>
<li>一个已经备案的域名（备案过程真是个痛苦的过程，各种资料，各种步骤，还可能审不过），并且做了二级域名泛解析。（本文假设你已经会域名解析配置）</li>
<li><code>Go http tunnel</code>，可在这里下载(<a href="https://github.com/mmatczuk/go-http-tunnel/releases" target="_blank" rel="noopener">https://github.com/mmatczuk/go-http-tunnel/releases</a>)</li>
<li>Let’s Encrypt工具。</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="https证书"><a href="#https证书" class="headerlink" title="https证书"></a>https证书</h2><p>可参看<a href="http://www.infoq.com/cn/news/2018/03/lets-encrypt-wildcard-https" target="_blank" rel="noopener">这里</a>或<a href="https://www.jianshu.com/p/c5c9d071e395" target="_blank" rel="noopener">这里</a><br>此处唯一要注意的就是有个域名解析的交互过程，这个在上述资料中也有说明。</p>
<p>记录下证书的生成位置如上文是<code>/etc/letsencrypt/archive/newyingyong.cn</code>，自动的生成路径可能不现。</p>
<h2 id="http-tunnel服务器"><a href="#http-tunnel服务器" class="headerlink" title="http tunnel服务器"></a>http tunnel服务器</h2><ul>
<li>服务器需要开放80,443,5223端口。</li>
<li>根据自己的服务器系统下载对应版本。</li>
<li>解压就可以了，进入目录。</li>
<li>执行如下命令，以https证书参考资料证书地址为例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tunneld -tlsCrt &#x2F;etc&#x2F;letsencrypt&#x2F;archive&#x2F;newyingyong.cn&#x2F;fullchain.pem -tlsKey &#x2F;etc&#x2F;letsencrypt&#x2F;archive&#x2F;newyingyong.cn&#x2F;privkey.pem</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="http-tunnel客户端"><a href="#http-tunnel客户端" class="headerlink" title="http tunnel客户端"></a>http tunnel客户端</h2><ul>
<li>根据自己的服务器系统下载对应版本</li>
<li>解压就可以了，进入目录。</li>
<li>生成客户端证书<code>openssl req -x509 -nodes -newkey rsa:2048 -sha256 -keyout client.key -out client.crt</code>,并将证书放到解压目录</li>
<li>创建<code>tunnel.yml</code>，默认读当前路径配置。</li>
<li>参考样例：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server_addr:</span> <span class="string">SERVER_IP:5223</span></span><br><span class="line"><span class="attr">tunnels:</span></span><br><span class="line">    <span class="attr">webui:</span></span><br><span class="line">        <span class="attr">proto:</span> <span class="string">http</span></span><br><span class="line">        <span class="attr">addr:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="attr">auth:</span> <span class="string">user:password</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">webui.my-tunnel-host.com</span></span><br></pre></td></tr></table></figure>
其中,<code>server_addr</code>为服务器地址，<code>tunnels</code>为开启的遂道列表，<code>webui</code>为实际的遂道名，正常可去掉<code>auth</code>配置，<code>host</code>中的域名与遂道名无直接关系。更多配置信息参看<a href="https://github.com/mmatczuk/go-http-tunnel" target="_blank" rel="noopener">官网</a>。</li>
<li>启动<code>tunnel start-all</code>。</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在客户端启动最简单http服务，使用客户端配置的域名进行访问，如果正常访问，恭喜你。如果还有问题，请核查服务器或客户端配置。</p>
<h1 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h1><p>如果你觉得以上配置过于复杂。有以下两种方式供你选择，当然你可能有更好的选择。</p>
<ol>
<li>可以使用<a href="https://natapp.cn/" target="_blank" rel="noopener">Natapp</a>，他提供免费的HTTPS的遂道，但提供的免费域名会一直变化。最好购买遂道和域名服务，付费时可以使用我的推广优惠码<code>ADBE2C5C</code>。</li>
<li>如果你恰好刚起步，希望用于本地调试，可以加我微信号，也可提供相关服务支持。申请时请备注<code>https tunnel技术支持</code>。<img src="https://l4qiang.me/images/wechat.png" alt="微信"></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/09/28/es/olap-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/28/es/olap-1/" class="post-title-link" itemprop="url">基于ElasticSearch的OLAP框架思路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-28 11:22:43" itemprop="dateCreated datePublished" datetime="2018-09-28T11:22:43+08:00">2018-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-12 23:44:44" itemprop="dateModified" datetime="2019-12-12T23:44:44+08:00">2019-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ElasticSearch/" itemprop="url" rel="index"><span itemprop="name">ElasticSearch</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ElasticSearch/OLAP/" itemprop="url" rel="index"><span itemprop="name">OLAP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OLAP基本概念"><a href="#OLAP基本概念" class="headerlink" title="OLAP基本概念"></a>OLAP基本概念</h1><h2 id="联机分析处理（On-Line-Analytical-Processing，OLAP）"><a href="#联机分析处理（On-Line-Analytical-Processing，OLAP）" class="headerlink" title="联机分析处理（On-Line Analytical Processing，OLAP）"></a>联机分析处理（On-Line Analytical Processing，OLAP）</h2><p>联机分析处理的概念最早是由关系数据库之父爱德华·库德（E·F·Codd）博士于1993年提出的，是一种用于组织大型商务数据库和支持商务智能的技术。OLAP 数据库分为一个或多个多维数据集，每个多维数据集都由多维数据集管理员组织和设计以适应用户检索和分析数据的方式，从而更易于创建和使用所需的数据透视表和数据透视图。</p>
<h2 id="维（Dimension）"><a href="#维（Dimension）" class="headerlink" title="维（Dimension）"></a>维（Dimension）</h2><p>是人们观察数据的特定角度，是考虑问题时的一类属性，属性集合构成一个维（时间维、地理维等）。</p>
<h2 id="维的层次（Level）"><a href="#维的层次（Level）" class="headerlink" title="维的层次（Level）"></a>维的层次（Level）</h2><p>人们观察数据的某个特定角度（即某个维）还可以存在细节程度不同的各个描述方面（时间维：日期、月份、季度、年）。</p>
<h2 id="维的成员（Member）"><a href="#维的成员（Member）" class="headerlink" title="维的成员（Member）"></a>维的成员（Member）</h2><p>维的一个取值，是数据项在某维中位置的描述。（“某年某月某日”是在时间维上位置的描述）。</p>
<h2 id="度量（Measure）"><a href="#度量（Measure）" class="headerlink" title="度量（Measure）"></a>度量（Measure）</h2><p>多维数组的取值。（2000年1月，上海，笔记本电脑，$100000）。</p>
<h2 id="指标（Quota），补充"><a href="#指标（Quota），补充" class="headerlink" title="指标（Quota），补充"></a>指标（Quota），补充</h2><p>可度量的属性。一般为某种值，如费用，入院人次。</p>
<h2 id="典型操作"><a href="#典型操作" class="headerlink" title="典型操作"></a>典型操作</h2><p>OLAP的基本多维分析操作有钻取（Drill-up和Drill-down）、切片（Slice）和切块（Dice）、以及旋转（Pivot）等。</p>
<h3 id="钻取"><a href="#钻取" class="headerlink" title="钻取"></a>钻取</h3><p>是改变维的层次，变换分析的粒度。它包括向下钻取（Drill-down）和向上钻取（Drill-up）/上卷(Roll-up)。Drill- up是在某一维上将低层次的细节数据概括到高层次的汇总数据，或者减少维数；而Drill-down则相反，它从汇总数据深入到细节数据进行观察或增加新维。</p>
<h3 id="切片和切块"><a href="#切片和切块" class="headerlink" title="切片和切块"></a>切片和切块</h3><p>是在一部分维上选定值后，关心度量数据在剩余维上的分布。如果剩余的维只有两个，则是切片；如果有三个或以上，则是切块。</p>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>是变换维的方向，即在表格中重新安排维的放置（例如行列互换）。</p>
<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><p>Apache Lucene™可能是目前存在的，不论开源还是私有的，拥有最先进，高性能和全功能搜索引擎功能的库。但Lucene是很复杂的。 Elasticsearch是一个使用Java编写的开源的搜索引擎，它的内部使用 Lucene 做索引与搜索，但是它的目标是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
<p>然而，Elasticsearch不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持PB级别的结构化或者非结构化数据</li>
</ul>
<p>Elasticsearch将所有的功能打包成一个单独的服务，这样你可以通过程序去访问它提供的简单的RESTful API服务， 不论你是使用自己喜欢的编程语言还是直接使用命令行。</p>
<p>Elasticsearch是一个实时的分布式搜索分析引擎， 它能让你以一个之前从未有过的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合：</p>
<ul>
<li>Wikipedia 使用 Elasticsearch 提供带有高亮片段的全文搜索，还有 search-as-you-type 和 did-you-mean 的建议。</li>
<li>卫报 使用 Elasticsearch 将网络社交数据结合到访客日志中，实时的给它的编辑们提供公众对于新文章的反馈。</li>
<li>Stack Overflow 将地理位置查询融入全文检索中去，并且使用 more-like-this 接口去查找相关的问题与答案。</li>
<li>GitHub 使用 Elasticsearch 对1300亿行代码进行查询。</li>
</ul>
<h2 id="ES文档和多维数据集"><a href="#ES文档和多维数据集" class="headerlink" title="ES文档和多维数据集"></a>ES文档和多维数据集</h2><h3 id="ES的存储结构"><a href="#ES的存储结构" class="headerlink" title="ES的存储结构"></a>ES的存储结构</h3><p>ES文档通过JSON格式来表示。文档是可以被索引的基本单元，文档需要索引需要指定类型。ES能支持索引的数据类型有，其中的数组类型，对象类型和内嵌类型的支持，使得ES能存储更复杂的文档。</p>
<h3 id="多维联机分析处理（MOLAP）"><a href="#多维联机分析处理（MOLAP）" class="headerlink" title="多维联机分析处理（MOLAP）"></a>多维联机分析处理（MOLAP）</h3><p>MOLAP将OLAP分析所用到的多维数据物理上存储为多维数组的形式，形成“立方体”的结构。维的属性值被映射成多维数组的下标值或下标的范围，而总结数据作为多维数组的值存储在数组的单元中。由于MOLAP采用了新的存储结构，从物理层实现起，因此又称为物理OLAP（PhysicalOLAP）；而 ROLAP主要通过一些软件工具或中间软件实现，物理层仍采用关系数据库的存储结构，因此称为虚拟OLAP（VirtualOLAP）。</p>
<p>我们可以看到基于复杂数据类型（Complex datatypes）构建的ES文档与MOLAP的概念是非常接近的，利用ElasticSearch的聚合的能力，我们能相对简单的实现OLAP框架。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>要实现整个OLAP框架主要需要处理以下几个环节</p>
<ol>
<li>数据建模</li>
<li>数据ETL</li>
<li>数据分析</li>
<li>数据展示</li>
</ol>
<p>大致思路如下：<br><img src="olap.png" alt="OLAP"></p>
<h2 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h2><p>数据建模就是建立多维数据集的过程，同时为了能更有效的利用ES的索引，不建议过深的JSON层次，所以对应到维度建模时采用的是星形模式。</p>
<p>正常情况，是先进行数据建模，之后才能进行数据ETL，首先需要知道抽取的源数据的结构，即数据元数据之后，才能进一步分析数据模型。对于ES来说，实际上就是建立Index/Type的过程。</p>
<h3 id="维度管理"><a href="#维度管理" class="headerlink" title="维度管理"></a>维度管理</h3><h3 id="元数据管理"><a href="#元数据管理" class="headerlink" title="元数据管理"></a>元数据管理</h3><p>元数据管理维护了原始数据的元数据结构，简单来说就是原始数据有哪些库，哪些表，表之间有什么关系。</p>
<h3 id="映射管理"><a href="#映射管理" class="headerlink" title="映射管理"></a>映射管理</h3><p>映射管理是指定了需要抽取的数据范围及方法和确定了多维数据集的模型。</p>
<h2 id="数据ETL"><a href="#数据ETL" class="headerlink" title="数据ETL"></a>数据ETL</h2><p>正常情况，是先进行数据建模，之后才能进行数据ETL，而实际过程中，是一般需要知道源数据的结构，即数据元数据之后，才能进一步分析数据模型。</p>
<p>数据ETL，实质就是从各个数据源提取数据，对数据进行转换，并最终加载填充数据到数据仓库维度建模后的表中。只有当多维数据集被填充好，ETL工作才算完成。</p>
<p>数据加载主要分为两种，一种是首次加载，一种是刷新加载（增量加载）。当前产品中主要涉及两种数据库，Mysql和Hbase。</p>
<h3 id="首次加载"><a href="#首次加载" class="headerlink" title="首次加载"></a>首次加载</h3><p>通过Quartz Job或MapRedurce Job将数据转换为Kafka消息，由数据加载组件来进行数据处理。</p>
<h3 id="刷新加载"><a href="#刷新加载" class="headerlink" title="刷新加载"></a>刷新加载</h3><p>通过扩展mysql-binlog-connector-java和HBase Side-Effect Processor，可以实现数据的实时增量更新。本方案中通过Kafka消息中间件来统一转发不同类型的数据更新，此处需要定义好Kafka的消息格式，以便数据加载组件能较简单的处理数据。</p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>转换步骤主要是指对提取好了的数据的结构进行转换，以满足目标数据仓库模型的过程。此外，转换过程也负责数据质量工作，这部分也被称为数据清洗(data cleaning)。转换过程可以通过逐步实现转换算法，动态上线的方式进行。</p>
<h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><p>统计分析其实就是从事实表中统计任意组合维度的指标，也就是过滤、分组、聚合，其中，聚合除了一般的SUM、COUNT、AVG、MAX、MIN等，还有一个重要的COUNT(DISTINCT)。ElasticSearch本来就是做实时搜索的，过滤自然不是问题，现在也支持各种聚合以及Pipeline aggregations（相当于SQL子查询的功能）。</p>
<p>统计分析是根据模板配置和页面操作时的条件生成ES语法，执行语法，返回结果数据的过程。从表面看，该过程不难，然而为了生成的ES语法的准确性，ES语法的生成引擎是非常重要的一个环节，通过在模板管理来增加一些配置来辅助ES的语法生成，如行维度，列维度，维的层次等等。</p>
<h2 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h2><p>通过模板的动态配置，利用Echart和Vue可以实现，动态布局和各种仪表盘的展示，这部分内容也可参看Kibana。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>ES的文档结构符合MOLAP的概念，它提供的聚合功能可以实现OLAP的各种操作，基于Lucene和分布式架构在性能上也能得到保障。通过定义一定的规则和开发一系列的辅助功能，可比较容易的实现一套通用的实时OLAP的框架。本文主要讲解的是基于ES构建OLAP框架的思路，而非完整的构建方案。</p>
<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><ul>
<li>联机分析处理</li>
<li>Elasticsearch Basic Concepts</li>
<li><a href="https://www.elastic.co/products/hadoop" target="_blank" rel="noopener">https://www.elastic.co/products/hadoop</a></li>
<li>Hbase Indexer SEP</li>
<li>使用ElasticSearch作为大数据平台的实时OLAP框架</li>
<li><a href="https://blog.csdn.net/fighting_one_piece/article/details/51765383" target="_blank" rel="noopener">https://blog.csdn.net/fighting_one_piece/article/details/51765383</a></li>
<li><a href="https://yq.aliyun.com/articles/575991" target="_blank" rel="noopener">https://yq.aliyun.com/articles/575991</a></li>
<li>Mapping Types</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/09/19/git/git-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/19/git/git-1/" class="post-title-link" itemprop="url">管理多个Github帐号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-19 08:15:40" itemprop="dateCreated datePublished" datetime="2018-09-19T08:15:40+08:00">2018-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-07 09:06:14" itemprop="dateModified" datetime="2020-09-07T09:06:14+08:00">2020-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前通过GithubPages和Hexo搭建了个人博客，在<a href="https://l4qiang.me/2016/10/05/hexo/">这里</a>可看到搭建的方法。现在呢，希望用另一个帐号，管理一个不同内容的<a href="http://goldyear.info" target="_blank" rel="noopener">博客</a>。有了之前的经验，整个搭建的过程还是比较顺利，主要碰到的问题就是代码发布。之前github帐号，是通过Windows的<a href="https://www.howto-connect.com/how-to-use-credential-manager-windows-10/" target="_blank" rel="noopener">凭证管理</a>来实现的，按理说Github配置了多个帐号也是可以管理的。如图：</p>
<p><img src="crdential.png" alt="crdential.png"></p>
<p>但是两套博客在发布代码的时候都出现了问题。</p>
<h2 id="初步方案"><a href="#初步方案" class="headerlink" title="初步方案"></a>初步方案</h2><p>将用户名和密码配置在Hexo的<code>_config.yml</code>的配置项中，形如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;enderjo:xyz@github.com&#x2F;enderjo&#x2F;enderjo.github.io</span><br></pre></td></tr></table></figure>
<p>虽然这样配置是解决了发布问题，但密码安全问题就暴露出来了，想想之前有了解到Github有ssh功能，但也没用过，初步试了下一样发现两个帐号配置的问题，github不支持同一个公钥用于不同的帐号，会提示公钥已经被使用了，请教了下前同事事了解到ssh有个config的配置。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>基于同事的提示刚开始创建的config如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github:enderjo</span><br><span class="line"> Hostname github.com</span><br><span class="line"> User git</span><br><span class="line"> PreferredAuthentications publickey</span><br><span class="line"> IdentityFile ~&#x2F;.ssh&#x2F;github-enderjo&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<p>Window中在用户目录<code>%USERPROFILE%</code>下。之后使用ssh测试也是通的。<br>如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T github.com:enderjo</span></span><br><span class="line">Hi enderjo! You've successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>但测试Git Clone的时候提示无法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:enderjo/enderjo.github.io.git</span></span><br><span class="line">Cloning into 'enderjo.github.io'...</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://help.github.com/articles/error-permission-denied-publickey/" target="_blank" rel="noopener">Error: Permission denied (publickey)</a>通过ssh-add证书的方式，能正常git clone。此时已可初步判断，git clone没有正常取到config的配置。<br>接着同事发来这篇文章<br><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/45593" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-ce/issues/45593</a><br>其中提到，可通过如下命令查看git clone的实际执行过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GIT_TRACE&#x3D;1 GIT_SSH_COMMAND&#x3D;&quot;ssh -vvv&quot; git clone git@gitlab.example.com:my-group&#x2F;my-project.git</span><br></pre></td></tr></table></figure>
<p>测试后的部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ GIT_TRACE&#x3D;1 GIT_SSH_COMMAND&#x3D;&quot;ssh -vvv&quot; git clone git@github.com:enderjo&#x2F;enderjo.github.io.git</span><br><span class="line">14:03:51.164492 exec-cmd.c:236          trace: resolved executable dir: C:&#x2F;Program Files&#x2F;Git&#x2F;mingw64&#x2F;bin</span><br><span class="line">14:03:51.165492 git.c:415               trace: built-in: git clone git@github.com:enderjo&#x2F;enderjo.github.io.git</span><br><span class="line">Cloning into &#39;enderjo.github.io&#39;...</span><br><span class="line">14:03:51.225463 run-command.c:637       trace: run_command: unset GIT_DIR; &#39;ssh -vvv&#39; git@github.com &#39;git-upload-pack &#39;\&#39;&#39;enderjo&#x2F;enderjo.github.io.git&#39;\&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>
<p>此时我们可以看到，实际执行的地址和测试的地址是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com:enderjo</span><br><span class="line">$ ssh -vvv git@github.com</span><br></pre></td></tr></table></figure>
<p>ssh命令是根据config文件中Host记录与ssh命令时所输入的主机名来进行匹配的，而git clone因为使用<code>:</code>分隔用户名。</p>
<p>之后查到<a href="https://blog.csdn.net/huasonl88/article/details/52166876" target="_blank" rel="noopener">这篇</a>文章。config文件中的Host就是一个别名。</p>
<p>调整config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host gh-enderjo</span><br><span class="line"> Hostname github.com</span><br><span class="line"> User git</span><br><span class="line"> PreferredAuthentications publickey</span><br><span class="line"> IdentityFile ~&#x2F;.ssh&#x2F;github-enderjo&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<p>修改git clone命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone gh-enderjo:enderjo&#x2F;enderjo.github.io.git</span><br><span class="line">Cloning into &#39;enderjo.github.io&#39;...</span><br><span class="line">remote: Counting objects: 4822, done.</span><br><span class="line">remote: Compressing objects: 100% (386&#x2F;386), done.</span><br><span class="line">remote: Total 4822 (delta 873), reused 2292 (delta 846), pack-reused 2496</span><br><span class="line">Receiving objects: 100% (4822&#x2F;4822), 5.20 MiB | 215.00 KiB&#x2F;s, done.</span><br><span class="line">Resolving deltas: 100% (1686&#x2F;1686), done.</span><br></pre></td></tr></table></figure>
<p>测试正常，修改Hexo的_config.yml也能正常发布代码了。</p>
<h2 id="增加Mac的配置"><a href="#增加Mac的配置" class="headerlink" title="增加Mac的配置"></a>增加Mac的配置</h2><p>因为之前配置过了Windows，这里我需要把Windows中的ssh配置先拷贝到Mac上（~/.ssh）。<br>测试，此时会提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Permissions 0755 for &#39;&#x2F;Users&#x2F;airhead&#x2F;.ssh&#x2F;github-enderjo&#x2F;id_rsa&#39; are too open.</span><br><span class="line">It is required that your private key files are NOT accessible by others.</span><br><span class="line">This private key will be ignored.</span><br><span class="line">Load key &quot;&#x2F;Users&#x2F;airhead&#x2F;.ssh&#x2F;github-enderjo&#x2F;id_rsa&quot;: bad permissions</span><br><span class="line">git@github.com: Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br></pre></td></tr></table></figure>
<p>需要修改权限为400（600也可以），注意修改路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 &#x2F;Users&#x2F;airhead&#x2F;.ssh&#x2F;github-enderjo&#x2F;id_rsa</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>利用ssh的config功能可以很好的管理Git的多帐号问题，但需要注意修改Git仓库的获取地址。</p>
<p>虽然一直Git，但对于Git和ssh还是有很多不了解的地方。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://help.github.com/articles/error-permission-denied-publickey/" target="_blank" rel="noopener">Error: Permission denied (publickey)</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/45593" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-ce/issues/45593</a><br><a href="https://blog.csdn.net/huasonl88/article/details/52166876" target="_blank" rel="noopener">ssh-config配置</a><br><a href="https://deepzz.com/post/how-to-setup-ssh-config.html" target="_blank" rel="noopener">SSH Config 那些你所知道和不知道的事</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/09/08/frontend/news/news-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/08/frontend/news/news-1/" class="post-title-link" itemprop="url">(翻译)GitHub.com前端移除jQuery库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-08 06:42:30" itemprop="dateCreated datePublished" datetime="2018-09-08T06:42:30+08:00">2018-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-22 08:49:30" itemprop="dateModified" datetime="2018-11-22T08:49:30+08:00">2018-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/frentend/" itemprop="url" rel="index"><span itemprop="name">frentend</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/frentend/news/" itemprop="url" rel="index"><span itemprop="name">news</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>因本人能力有限，理解不到位，翻译内容可能存在偏差。如果可能，请尽量读<a href="https://githubengineering.com/removing-jquery-from-github-frontend/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website" target="_blank" rel="noopener">原文</a>。</p>
</blockquote>
<p>We have recently completed a milestone where we were able to drop jQuery as a dependency of the frontend code for GitHub.com. This marks the end of a gradual, years-long transition of increasingly decoupling from jQuery until we were able to completely remove the library. In this post, we will explain a bit of history of how we started depending on jQuery in the first place, how we realized when it was no longer needed, and point out that—instead of replacing it with another library or framework—we were able to achieve everything that we needed using standard browser APIs.</p>
<p>我们最近完成了一个里程碑，就是将jQuery从我们Github.com的前端依赖库中移了。直到完全移除了jQuery库才意味着一个逐步的、长达数年的去jQuery化的结束。在这篇文章中，我们会解释为一些历史，为什么我们一开始会引入jQuery，我们是何时意识到已经不再需要jQuery了，以及找出可替代它的类库或者框架，我需要使用浏览器的标准API来达到目的。</p>
<h2 id="为什么jQuery之前是有用的（Why-jQuery-made-sense-early-on）"><a href="#为什么jQuery之前是有用的（Why-jQuery-made-sense-early-on）" class="headerlink" title="为什么jQuery之前是有用的（Why jQuery made sense early on）"></a>为什么jQuery之前是有用的（Why jQuery made sense early on）</h2><p>GitHub.com pulled in <a href="https://blog.jquery.com/2007/09/16/jquery-1-2-1-released/" target="_blank" rel="noopener">jQuery 1.2.1</a> as a dependency in late 2007. For a bit of context, that was a year before Google released the first version of their Chrome browser. There was no standard way to query DOM elements by a CSS selector, no standard way to animate visual styles of an element, and the 【XMLHttpRequest interface](<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest</a>) pioneered by Internet Explorer was, like many other APIs, inconsistent between browsers.</p>
<p>GitHub.com在2007年底时引入了<a href="https://blog.jquery.com/2007/09/16/jquery-1-2-1-released/" target="_blank" rel="noopener">jQuery 1.2.1</a>。因为这样的一些背景，当时距Google发布第一个版本还有一年时间。通过CSS选择器来查询DOM元素没有标准的方式，将元素视觉动画化也没有标准的样式，IE提供<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest接口</a>，和其他API一样，在不同的浏览器之间也是不同。</p>
<p>jQuery made it simple to manipulate the DOM, define animations, and make “AJAX” requests— basically, it enabled web developers to create more modern, dynamic experiences that stood out from the rest. Most importantly of all, the JavaScript features built in one browser with jQuery would generally work in other browsers, too. In those early days of GitHub when most of its features were still getting fleshed out, this allowed the small development team to prototype rapidly and get new features out the door without having to adjust code specifically for each web browser.</p>
<p>jQuery使得操作DOM，定义动画，发起“AJAX”请求变得简单——基本上，它使Web开发人员能够创建出更现代、更动态的体验，这些体验在其他方面都非常突出。更为重要的是，使用了jQuery的JavaScript特性在不同的浏览器都可正常工作。在GitHub早期，它的大部分功能还在不断充实，这使得小型开发团队能够快速地进行原型，而无需为每个Web浏览器专门调整代码来实现新的特性。</p>
<p>The simple interface of jQuery also served as a blueprint to craft extension libraries that would later serve as building blocks for the rest of GitHub.com frontend: <a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="noopener">pjax</a> and <a href="https://github.com/defunkt/facebox" target="_blank" rel="noopener">facebox</a>.</p>
<p>jQuery的简单接口为设计扩展库提供了蓝图，GitHub.com扩展前端的基础模块： <a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="noopener">pjax</a>和<a href="https://github.com/defunkt/facebox" target="_blank" rel="noopener">facebox</a>。</p>
<p>We will always be thankful to John Resig and the jQuery contributors for creating and maintaining such a useful and, for the time, essential library.</p>
<p>我们将一直感激John Resig和jQuery的贡献者创建和维护了这样一个有用的，对于当时来说，必不可少的类库。</p>
<h2 id="近年来的Web标准（Web-standards-in-the-later-years）"><a href="#近年来的Web标准（Web-standards-in-the-later-years）" class="headerlink" title="近年来的Web标准（Web standards in the later years）"></a>近年来的Web标准（Web standards in the later years）</h2><p>Over the years, GitHub grew into a company with hundreds of engineers and a dedicated team gradually formed to take responsibility for the size and quality of JavaScript code that we serve to web browsers. One of the things that we’re constantly on the lookout for is technical debt, and sometimes technical debt grows around dependenices that once provided value, but whose value dropped over time.</p>
<p>这些年来，Github成长为一家拥有数百名工程师的公司，并逐渐形成了一只专门负责我们运行在Web浏览器上的JavaScript代码的大小和质量的团队。其中一件我们一直在做的事情就是找出技术债务，有时技术债务会随着曾经提供价值的附属物而增长，但其价值会随着时间的推移而下降。</p>
<p>When it came to jQuery, we compared it against the rapid evolution of supported web standard in modern browsers and realized:</p>
<p>The $(selector) pattern can easily be replaced with querySelectorAll();<br>CSS classname switching can now be achieved using Element.classList;<br>CSS now supports defining visual animations in stylesheets rather than in JavaScript;<br>$.ajax requests can be performed using the Fetch Standard;<br>The addEventListener() interface is stable enough for cross-platform use;<br>We could easily encapsulate the event delegation pattern with a lighweight library;<br>Some syntactic sugar that jQuery provides has become reduntant with the evolution of JavaScript language.<br>Furthermore, the chaining syntax didn’t satisfy how we wanted to write code going forward. For example:</p>
<p>$(‘.js-widget’)<br>  .addClass(‘is-loading’)<br>  .show()<br>This syntax is simple to write, but to our standards, doesn’t communicate intent really well. Did the author expect one or more js-widget elements on this page? Also, if we update our page markup and accidentally leave out the js-widget classname, will an exception in the browser inform us that something went wrong? By default, jQuery silently skips the whole expresion when nothing matched the initial selector; but to us, such behavior was a bug rather than a feature.</p>
<p>Finally, we wanted to start annotating types with Flow to perform static type checking at build time, and we concluded that the chaining syntax doesn’t lend itself well to static analysis, since almost every result of a jQuery method call is of the same type. We chose Flow over alternatives because, at the time, features such as @flow weak mode allowed us to progressively and efficiently start applying types to a codebase which was largely untyped.</p>
<p>All in all, decoupling from jQuery would mean that we could rely on web standards more, have MDN web docs be de-facto default documentation for our frontend developers, maintain more resilient code in the future, and eventually drop a 30 kB dependency from our packaged bundles, speeding up page load times and JavaScript execution times.</p>
<p>Incremental decoupling<br>Even with an end goal in sight, we knew that it wouldn’t be feasible to just allocate all resources we had to rewriting everything from jQuery to vanilla JS. If anything, such a rushed endeavor would likely lead to many regressions in site functionality that we would later have to weed out. Instead, we:</p>
<p>Set up metrics that tracked ratio of jQuery calls used per overall line of code and monitored that graph over time to make sure that it’s either staying constant or going down, not up.</p>
<p>Graph of jQuery usage going down over time.</p>
<p>We discouraged importing jQuery in any new code. To facilitate that using automation, we created eslint-plugin-jquery which would fail CI checks if anyone tried to use jQuery features, for example $.ajax.</p>
<p>There were now plenty of violations of eslint rules in old code, all of which we’ve annotated with specific eslint-disable rules in code comments. To the reader of that code, those comments would serve as a clear signal that this code doesn’t represent our current coding practices.</p>
<p>We created a pull request bot that would leave a review comment on a pull request pinging our team whenever somebody tried to add a new eslint-disable rule. This way we would get involved in code review early and suggest alternatives.</p>
<p>A lot of old code had explicit coupling to external interfaces of pjax and facebox jQuery plugins, so we’ve kept their interfaces relatively the same while we’ve internally replaced their implementation with vanilla JS. Having static type checking helped us have greater confidence around those refactorings.</p>
<p>Plenty of old code interfaced with rails-behaviors, our adapter for the Ruby on Rails approach to “unobtrusive” JS, in a way that they would attach an AJAX lifecycle handler to certain forms:</p>
<p>  // LEGACY APPROACH<br>  $(document).on(‘ajaxSuccess’, ‘form.js-widget’, function(event, xhr, settings, data) {<br>    // insert response data somewhere into the DOM<br>  })<br>Instead of having to rewrite all of those call sites at once to the new approach, we’ve opted to trigger fake ajax* lifecycle events and keep these forms submitting their contents asynchronously as before; only this time fetch() was used internally.</p>
<p>We maintained a custom build of jQuery and whenever we’ve identified that we’re not using a certain module of jQuery anymore, we would remove it from the custom build and ship a slimmer version. For instance, after we have removed the final usage of jQuery-specific CSS pseudo-selectors such as :visible or :checkbox, we were able to remove the Sizzle module; and when the last $.ajax call was replaced with fetch(), we were able to remove the AJAX module. This served a dual purpose: speeding up JavaScript execution times while at the same time ensuring that no new code is created that would try using the removed functionality.</p>
<p>We kept dropping support for old Internet Explorer versions as soon as it would be feasible to, as informed by our site analytics. Whenever use of a certain IE version dropped below a certain treshold, we would stop serving JavaScript to it and focus on testing against and supporting more modern browsers. Dropping support for IE 8–9 early on allowed us to adopt many native browser features that would otherwise be hard to polyfill.</p>
<p>As part of our refined approach to building frontend features on GitHub.com, we focused on getting away with regular HTML foundation as much as we could, and only adding JavaScript behaviors as progressive enhancement. As a result, even those web forms and other UI elements that were enhanced using JS would usually also work with JavaScript disabled in the browser. In some cases, we were able to delete certain legacy behaviors altogether instead of having to rewrite them in vanilla JS.</p>
<p>With these and similar efforts combined over the years, we were able gradually reduce our dependence on jQuery until there was not a single line of code referencing it anymore.</p>
<p>Custom Elements<br>One technology that has been making waves in the recent years is Custom Elements: a component library native to the browser, which means that there are no additional bytes of a framework for the user to download, parse and compile.</p>
<p>We had created a few Custom Elements based on the v0 specification since 2014. However, as standards were still in flux back then, we did not invest as much. It was not until 2017 when the Web Components v1 spec was released and implemented in both Chrome and Safari that we began to adopt Custom Elements on a wider scale.</p>
<p>During the jQuery migration, we looked for patterns that would be suitable for extraction as custom elements. For example, we converted our facebox usage for displaying modal dialogs to the <details-dialog> element.</p>
<p>Our general philosophy of striving for progressive enhancement extends to custom elements as well. This means that we keep as much of the content in markup as possible and only add behaviors on top of that. For example, <local-time> shows the raw timestamp by default and gets upgraded to translate the time to the local timezone, while <details-dialog>, when nested in the <details> element, is interactive even without JavaScript, but gets upgraded with accessibility enhancements.</p>
<p>Here is an example of how a <local-time> custom element could be implemented:</p>
<p>// The local-time element displays time in the user’s current timezone<br>// and locale.<br>//<br>// Example:<br>//   <local-time datetime="2018-09-06T08:22:49Z">Sep 6, 2018</local-time><br>//<br>class LocalTimeElement extends HTMLElement {<br>  static get observedAttributes() {<br>    return [‘datetime’]<br>  }</p>
<p>  attributeChangedCallback(attrName, oldValue, newValue) {<br>    if (attrName === ‘datetime’) {<br>      const date = new Date(newValue)<br>      this.textContent = date.toLocaleString()<br>    }<br>  }<br>}</p>
<p>if (!window.customElements.get(‘local-time’)) {<br>  window.LocalTimeElement = LocalTimeElement<br>  window.customElements.define(‘local-time’, LocalTimeElement)<br>}</p>
<p>One aspect of Web Components that we’re looking forward to adopting is Shadow DOM. The powerful nature of Shadow DOM has the potential to unlock a lot of possibilities for the web, but that also makes it harder to polyfill. Because polyfilling it today incurs a performance penalty even for code that manipulates parts of the DOM unrelated to web components, it is unfeasible for us to start using it in production.</p>
<p>Polyfills<br>These are the polyfills that helped us transition to using standard browser features. We try to serve most of these polyfills only when absolutely necessary, i.e. to outdated browsers as part of a separate “compatibility” JavaScript bundle.</p>
<ul>
<li><a href="https://github.com/github/eventlistener-polyfill#readme" target="_blank" rel="noopener">github/eventlistener-polyfill</a></li>
<li><a href="https://github.com/github/fetch#readme" target="_blank" rel="noopener">github/fetch</a></li>
<li><a href="https://github.com/github/form-data-entries#readme" target="_blank" rel="noopener">github/form-data-entries</a></li>
<li><a href="https://github.com/iamdustan/smoothscroll#readme" target="_blank" rel="noopener">iamdustan/smoothscroll</a></li>
<li><a href="https://github.com/javan/details-element-polyfill#readme" target="_blank" rel="noopener">javan/details-element-polyfill</a></li>
<li><a href="https://github.com/jonathantneal/closest#readme" target="_blank" rel="noopener">jonathantneal/closest</a></li>
<li><a href="https://github.com/kumarharsh/custom-event-polyfill#readme" target="_blank" rel="noopener">kumarharsh/custom-event-polyfill</a></li>
<li><a href="https://github.com/marvinhagemeister/request-idle-polyfill#readme" target="_blank" rel="noopener">marvinhagemeister/request-idle-polyfill</a></li>
<li><a href="https://github.com/mathiasbynens/Array.from#readme" target="_blank" rel="noopener">mathiasbynens/Array.from</a></li>
<li><a href="https://github.com/mathiasbynens/String.prototype.codePointAt#readme" target="_blank" rel="noopener">mathiasbynens/String.prototype.codePointAt</a></li>
<li><a href="https://github.com/mathiasbynens/String.prototype.endsWith#readme" target="_blank" rel="noopener">mathiasbynens/String.prototype.endsWith</a></li>
<li><a href="https://github.com/mathiasbynens/String.prototype.startsWith#readme" target="_blank" rel="noopener">mathiasbynens/String.prototype.startsWith</a></li>
<li><a href="https://github.com/medikoo/es6-symbol#readme" target="_blank" rel="noopener">medikoo/es6-symbol</a></li>
<li><a href="https://github.com/nicjansma/usertiming.js#readme" target="_blank" rel="noopener">nicjansma/usertiming.js</a></li>
<li><a href="https://github.com/rubennorte/es6-object-assign#readme" target="_blank" rel="noopener">rubennorte/es6-object-assign</a></li>
<li><a href="https://github.com/stefanpenner/es6-promise#readme" target="_blank" rel="noopener">stefanpenner/es6-promise</a></li>
<li><a href="https://github.com/webcomponents/template#template" target="_blank" rel="noopener">webcomponents/template</a></li>
<li><a href="https://github.com/webcomponents/URL#readme" target="_blank" rel="noopener">webcomponents/URL</a></li>
<li><a href="https://github.com/webcomponents/webcomponentsjs#readme" target="_blank" rel="noopener">webcomponents/webcomponentsjs</a></li>
<li><a href="https://github.com/WebReflection/url-search-params#readme" target="_blank" rel="noopener">WebReflection/url-search-params</a></li>
<li><a href="https://github.com/yola/classlist-polyfill#readme" target="_blank" rel="noopener">yola/classlist-polyfill</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">L4qiang</p>
  <div class="site-description" itemprop="description">记录点滴，注重积累。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/enderjo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;enderjo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:L4qiang@gmail.com" title="E-Mail → mailto:L4qiang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">L4qiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">384k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:49</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
      <div class="footer-inner">
        <a href="https://ri.cms.firesbox.com" target="_blank" rel="noopener">践行群官方情报站</a>
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>
</html>
