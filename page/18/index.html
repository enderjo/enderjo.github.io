<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"l4qiang.me","root":"/","scheme":"Gemini","version":"8.0.0-rc.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录点滴，注重积累。">
<meta property="og:type" content="website">
<meta property="og:title" content="CrazyAirhead">
<meta property="og:url" content="http://l4qiang.me/page/18/index.html">
<meta property="og:site_name" content="CrazyAirhead">
<meta property="og:description" content="记录点滴，注重积累。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="L4qiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://l4qiang.me/page/18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CrazyAirhead</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c3ed9d534576a67e94ff8be03a704994";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CrazyAirhead</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">疯狂的傻瓜，傻瓜也疯狂——傻方能执著，疯狂才专注!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/crazy-airhead" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-5/" class="post-title-link" itemprop="url">Go Little Book - 第五章 - 特点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:45:32" itemprop="dateCreated datePublished" datetime="2018-11-22T10:45:32+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:46" itemprop="dateModified" datetime="2018-12-05T10:40:46+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-特点（珍品？）（Chapter-5-Tidbits）"><a href="#第五章-特点（珍品？）（Chapter-5-Tidbits）" class="headerlink" title="第五章 - 特点（珍品？）（Chapter 5 - Tidbits）"></a>第五章 - 特点（珍品？）（Chapter 5 - Tidbits）</h1><p>In this chapter, we’ll talk about a miscellany of Go’s feature which didn’t quite fit anywhere else.</p>
<p>在这一章是，我们会来介绍一些Go的特性的杂烩，这些内容不太适合放在其他章节中。</p>
<h2 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h2><p>Go’s preferred way to deal with errors is through return values, not exceptions. Consider the <code>strconv.Atoi</code> function which takes a string and tries to convert it to an integer:</p>
<p>Go更喜欢用返回值而不是异常的方式来处理错误。例如<code>strconv.Atoi</code>函数将一个字符串转换成一个整数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n, err := strconv.Atoi(os.Args[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"not a valid number"</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can create your own error type; the only requirement is that it fulfills the contract of the built-in <code>error</code> interface, which is:</p>
<p>你可以创建你自己的错误类型；唯一的要求就是需要实现内置接口<code>error</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>More commonly, we can create our own errors by importing the <code>errors</code> package and using it in the <code>New</code> function:</p>
<p>更为常见的是，我们可以通过导入<code>errors</code>包，并通过它的<code>New</code>函数来创建自己的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(count <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> count &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"Invalid count"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s a common pattern in Go’s standard library of using error variables. For example, the <code>io</code> package has an <code>EOF</code> variable which is defined as:</p>
<p>在GO的标准库中，使用错误变量是一个常用的模式。例如， 在<code>io</code>包中有一个<code>EOF</code>变量是这样定义的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</span><br></pre></td></tr></table></figure>

<p>This is a package variable (it’s defined outside of a function) which is publicly accessible (upper-case first letter). Various functions can return this error, say when we’re reading from a file or STDIN. If it makes contextual sense, you should use this error, too. As consumers, we can use this singleton:</p>
<p>这是一个公共（大写字母开关）的包变量（它定义有函数之外）。如果我们从文件或者标准输入时失败时，我们可以返回这个错误。为了更容易理解，你也应该用这个错误。作为使用者，我们可以用这个单件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> input <span class="keyword">int</span></span><br><span class="line">  _, err := fmt.Scan(&amp;input)</span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">    fmt.Println(<span class="string">"no more input!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As a final note, Go does have <code>panic</code> and <code>recover</code> functions. <code>panic</code> is like throwing an exception while <code>recover</code> is like <code>catch</code>; they are rarely used.</p>
<p>最后要注意的是，Go有<code>panic</code>和<code>recover</code>函数。<code>panic</code>像是抛出异常，而<code>recover</code>是捕获异常；它们不常使用。</p>
<h2 id="Defer-Defer"><a href="#Defer-Defer" class="headerlink" title="Defer(Defer)"></a>Defer(Defer)</h2><p>Even though Go has a garbage collector, some resources require that we explicitly release them. For example, we need to <code>Close()</code> files after we’re done with them. This sort of code is always dangerous. For one thing, as we’re writing a function, it’s easy to forget to <code>Close</code> something that we declared 10 lines up. For another, a function might have multiple return points. Go’s solution is the <code>defer</code> keyword:</p>
<p>虽然Go有垃圾回收机制，但是有些资源需要显示的释放它们。比如，当我们使用文件完了之后，需要调用<code>Close()</code>来关闭它们。这类代码总是很危险。其一，我们写一下函数的时候，如果申请一个资源超过10行，就很容易忘记<code>Close</code>。其二，一个函数可能会有多个返回点。Go的解决方案是使用<code>defer</code>关键字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">"a_file_to_read"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// read the file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you try to run the above code, you’ll probably get an error (the file doesn’t exist). The point is to show how <code>defer</code> works. Whatever you <code>defer</code> will be executed after the method returns, even if it does so violently. This lets you release resources near where it’s initialized and takes care of multiple return points.</p>
<p>如果你尝试运行上面的代码，你可能收到一个错误（文件不存在）。这里展示的是<code>defer</code>是如何工作的。无论如何在函数返回时<code>defer</code>都会被执行，虽然这样有点极端。但这可以让你在初始化附近释放资源和不要操心多个返回点的问题。</p>
<h2 id="go-fmt-go-fmt"><a href="#go-fmt-go-fmt" class="headerlink" title="go fmt(go fmt)"></a>go fmt(go fmt)</h2><p>Most programs written in Go follow the same formatting rules, namely, a tab is used to indent and braces go on the same line as their statement.</p>
<p>绝大多数Go写的代码遵守有一个相同的格式化规则，也就是说，使用Tab来缩进和花括号与语句同一行。</p>
<p>I know, you have your own style and you want to stick to it. That’s what I did for a long time, but I’m glad I eventually gave in. A big reason for this is the <code>go fmt</code> command. It’s easy to use and authoritative (so no one argues over meaningless preferences).</p>
<p>我知道你有自己的代码风格并且严格遵守它。我一直以来也是这么做的，但是我最终还是放弃了。一个最在的原因就是<code>go fmt</code>命令。它很容用且权威（所以没有人会为了毫无意义的偏好而争论） </p>
<p>When you’re inside a project, you can apply the formatting rule to it and all sub-projects via:</p>
<p>当你在一个工程目录下，你可以通过下面的命令将工程下所有文件使用相同的格式化规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt .&#x2F;...</span><br></pre></td></tr></table></figure>

<p>Give it a try. It does more than indent your code; it also aligns field declarations and alphabetically orders imports.</p>
<p>尝试一下吧。除了缩进代码，它还会自动对齐你的声明语句并将包导入按字母顺序排序。</p>
<h2 id="If初始化-Initialized-If"><a href="#If初始化-Initialized-If" class="headerlink" title="If初始化(Initialized If)"></a>If初始化(Initialized If)</h2><p>Go supports a slightly modified if-statement, one where a value can be initiated prior to the condition being evaluated:<br>Go提供了一种稍有不同的if声明，一个可以在条件执行之前声明和初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x := <span class="number">10</span>; count &gt; x &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s a pretty silly example. More realistically, you might do something like:</p>
<p>这是一个非常简单的例子。更实际的例子是，你可能是这样做的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := process(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interestingly, while the values aren’t available outside the if-statement, they are available inside any <code>else if</code> or <code>else</code>.</p>
<p>有趣的是，<code>if</code>语句中定义并初始化的值在<code>if</code>语句之外是不可用的，仅可以在<code>else if</code>和<code>else</code>语句中使用。</p>
<h2 id="空接口和转换-Empty-Interface-and-Conversions"><a href="#空接口和转换-Empty-Interface-and-Conversions" class="headerlink" title="空接口和转换(Empty Interface and Conversions)"></a>空接口和转换(Empty Interface and Conversions)</h2><p>In most object-oriented languages, a built-in base class, often named <code>object</code>, is the superclass for all other classes. Go, having no inheritance, doesn’t have such a superclass. What it does have is an empty interface with no methods: <code>interface{}</code>. Since every type implements all 0 of the empty interface’s methods, and since interfaces are implicitly implemented, every type fulfills the contract of the empty interface.</p>
<p>在大多数面向对象语言中，都有一种内置的基类，叫<code>object</code>，它是所有其他类的超类。但是go语言不支持继承，所以没有类似的超类。Go确实有一个没有任何方法的空接口：<code>interface{}</code>。因为接口都是隐式实现，每种类型都实现了空接口的0个方法，所以每种类型都实现了空接口的协议。</p>
<p> If we wanted to, we could write an <code>add</code> function with the following signature:</p>
<p>如果我们愿意，我们可以通过下面声明方式写一个<code>add</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To convert an interface variable to an explicit type, you use <code>.(TYPE)</code>:</p>
<p>将一个空接口变量转换成一个指定的类型，你可以使用<code>.(TYPE)</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a.(<span class="keyword">int</span>) + b.(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>Note that if the underlying type is not <code>int</code>, the above will result in an error.</p>
<p>需要注意如果底层类型示是一个<code>int</code>，上面的代码会导致一个错误。</p>
<p>You also have access to a powerful type switch:</p>
<p>你也可以通过switch使用强大的类型转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"a is now an int and equals %d\n"</span>, a)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You’ll see and probably use the empty interface more than you might first expect. Admittedly, it won’t result in clean code. Converting values back and forth is ugly and dangerous but sometimes, in a static language, it’s the only choice.</p>
<p>你会发现，空接口的使用会超出你的预期。诚然，这不会让代码变得简洁。来回转换值是丑陋和危险的，但有时候在静态类型语言中，这是唯一的选择。</p>
<h2 id="字符串和字节数组-Strings-and-Byte-Arrays"><a href="#字符串和字节数组-Strings-and-Byte-Arrays" class="headerlink" title="字符串和字节数组(Strings and Byte Arrays)"></a>字符串和字节数组(Strings and Byte Arrays)</h2><p>Strings and byte arrays are closely related. We can easily convert one to the other:</p>
<p>字符串和字节数组有密切关系，我们可以轻易的将它们转换成对方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stra := <span class="string">"the spice must flow"</span></span><br><span class="line">byts := []<span class="keyword">byte</span>(stra)</span><br><span class="line">strb := <span class="keyword">string</span>(byts)</span><br></pre></td></tr></table></figure>

<p>In fact, this way of converting is common across various types as well. Some functions explicitly expect an <code>int32</code> or an <code>int64</code> or their unsigned counterparts. You might find yourself having to do things like:</p>
<p>事实上，这也是大多数类型的转换方式。一些函数明确指定一个<code>int32</code>或者<code>int64</code>或者相应的无符号类型。你可能会发现你自己不得不像下面这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64</span>(count)</span><br></pre></td></tr></table></figure>

<p>Still, when it comes to bytes and strings, it’s probably something you’ll end up doing often. Do note that when you use <code>[]byte(X)</code> or <code>string(X)</code>, you’re creating a copy of the data. This is necessary because strings are immutable.</p>
<p>然而，当涉及到字节和字符串时，这可能是你会经常做的事。当你使用<code>[]byte(X)</code>或者<code>string(X)</code>时务必注意，你创建了数据的拷贝。这是因为字符串的不可变性。</p>
<p>Strings are made of <code>runes</code> which are unicode code points. If you take the length of a string, you might not get what you expect. The following prints 3:</p>
<p>当字符串有由<code>unicode</code>字符码<code>runes</code>组成时。如果你计算字符串的长度时，可能得到的结果和你期待的不同。下面结果是输出3：</p>
<pre><code>fmt.Println(len(&quot;椒&quot;))</code></pre><p>If you iterate over a string using <code>range</code>, you’ll get runes, not bytes. Of course, when you turn a string into a <code>[]byte</code> you’ll get the correct data.</p>
<p>如果你使用<code>range</code>迭代一个字符串，你得到的是<code>runes</code>,而不是<code>bytes</code>。当然，你将一个字符串转换为<code>[]byte</code>时，你得到的数据还是正确的。</p>
<h2 id="函数类型-Function-Type"><a href="#函数类型-Function-Type" class="headerlink" title="函数类型(Function Type)"></a>函数类型(Function Type)</h2><p>Functions are first-class types:<br>函数是第一类类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>which can then be used anywhere – as a field type, as a parameter, as a return value.</p>
<p>可以在任何地方使用————可以做为一个字段，参数，返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(process(<span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(adder Add)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> adder(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using functions like this can help decouple code from specific implementations much like we achieve with interfaces.</p>
<p>像这样使用函数可以使你在一些特定实现时减少代码的耦合性，就像使用接口实现那样。</p>
<h2 id="继续之前-Before-You-Continue"><a href="#继续之前-Before-You-Continue" class="headerlink" title="继续之前(Before You Continue)"></a>继续之前(Before You Continue)</h2><p>We looked at various aspects of programming with Go. Most notably, we saw how error handling behaves and how to release resources such as connections and open files. Many people dislike Go’s approach to error handling. It can feel like a step backwards. Sometimes, I agree. Yet, I also find that it results in code that’s easier to follow. <code>defer</code> is an unusual but practical approach to resource management. In fact, it isn’t tied to resource management only. You can use <code>defer</code> for any purpose, such as logging when a function exits.</p>
<p>我们已经学习了Go编程的很多内容。显而易见，我们看见了错误处理的行为和资源释放如连接或者打开文件。很多人不喜欢Go的错误处理方式。它让人觉得这是一种退步。有些时候，我同意这种说法。然而，我也发现这会导致代码更易读。<code>defer</code>是一种不常见但很实用的资源管理手段。事实上，它不仅仅可以进行资源管理。你可以使用<code>defer</code>完成任何目的，例如当一个函数退出时打印日志记录。</p>
<p>Certainly, we haven’t looked at all of the tidbits Go has to offer. But you should be feeling comfortable enough to tackle whatever you come across.</p>
<p>当然，我们还没有学习Go提供的所有花絮。但是无论你遇到什么你应该可以轻松应对。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-4/" class="post-title-link" itemprop="url">Go Little Book - 第四章 - 代码组织和接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:45:23" itemprop="dateCreated datePublished" datetime="2018-11-22T10:45:23+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:52" itemprop="dateModified" datetime="2018-12-05T10:40:52+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-代码组织和接口（Chapter-4-Code-Organization-and-Interfaces）"><a href="#第四章-代码组织和接口（Chapter-4-Code-Organization-and-Interfaces）" class="headerlink" title="第四章 - 代码组织和接口（Chapter 4 - Code Organization and Interfaces）"></a>第四章 - 代码组织和接口（Chapter 4 - Code Organization and Interfaces）</h1><p>It’s now time to look at how to organize our code.</p>
<p>现在是时候来看看我们是怎么组织代码了。</p>
<h2 id="包（Packages）"><a href="#包（Packages）" class="headerlink" title="包（Packages）"></a>包（Packages）</h2><p>To keep more complicated libraries and systems organized, we need to learn about packages. In Go, package names follow the directory structure of your Go workspace. If we were building a shopping system, we’d probably start with a package name “shopping” and put our source files in <code>$GOPATH/src/shopping/</code>.</p>
<p>为了组织更复杂的类库和系统，我们需要了解包。在Go中，包名紧跟在工作目录结构之下。如果我们构建一个电商系统，我们可能以”shopping”命名包和把源文件存在<code>$GOPATH/src/shopping/</code>下。</p>
<p>We don’t want to put everything inside this folder though. For example, maybe we want to isolate some database logic inside its own folder. To achieve this, we create a subfolder at <code>$GOPATH/src/shopping/db</code>. The package name of the files within this subfolder is simply <code>db</code>, but to access it from another package, including the <code>shopping</code> package, we need to import <code>shopping/db</code>.</p>
<p>显然我们不想反所有的东西都放在这个目录。例如，我们希望在数据库目录下关联一些数据库的逻辑。要达到这个目的，我们创建了一个子目录<code>$GOPATH/src/shopping/db</code>。这个目录下的包名可以是简单的<code>db</code>，但是其他包需要访问这个包时，就需要包含<code>shopping</code>，我们需要这样导入<code>shopping/db</code>。</p>
<p>In other words, when you name a package, via the <code>package</code> keyword, you provide a single value, not a complete hierarchy (e.g., “shopping” or “db”). When you import a package, you specify the complete path.</p>
<p>换名话来说，当你命名一个包时，可以通过<code>package</code>关键字，你提供一个单一的值，不是完整的层级（比如，”shopping”或者”db”）。当你导入包时，你需要指定完整的路径。</p>
<p>Let’s try it. Inside your Go workspace’s <code>src</code> folder (which we set up in Getting Started of the Introduction), create a new folder called <code>shopping</code> and a subfolder within it called <code>db</code>.</p>
<p>让我们来试一试，在我们的Go的工作目录下的<code>src</code>文件夹中（我们在入门介绍中设置的），创建一个<code>shopping</code>的文件夹并创建一个<code>db</code>的子文件夹。</p>
<p>Inside of <code>shopping/db</code>, create a file called <code>db.go</code> and add the following code:</p>
<p>在<code>shopping/db</code>目录下，创建一个名为<code>db.go</code>的文件并添加如下代码： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that the name of the package is the same as the name of the folder. Also, obviously, we aren’t actually accessing the database. We’re just using this as an example to show how to organize code.</p>
<p>注意下包名和文件夹的名字是一样的。显然，我们也没有真下的访问数据库。我们只是用这个例子来演示如何组织代码。</p>
<p>Now, create a file called <code>pricecheck.go</code> inside of the main <code>shopping</code> folder. Its content is:</p>
<p>现在，在主目录<code>shopping</code>下创建一个名为<code>pricecheck.go</code>的文件。它的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shopping</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"shopping/db"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PriceCheck</span><span class="params">(itemId <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  item := db.LoadItem(itemId)</span><br><span class="line">  <span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.Price, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It’s tempting to think that importing <code>shopping/db</code> is somehow special because we’re inside the <code>shopping</code> package/folder already. In reality, you’re importing <code>$GOPATH/src/shopping/db</code>, which means you could just as easily import <code>test/db</code> so long as you had a package named <code>db</code> inside of your workspace’s <code>src/test</code> folder.</p>
<p>这很容易理解，导入<code>shopping/ db</code>有些特殊，因为我们是<code>shopping</code>包/文件夹中了。实际上，要导入<code>$ GOPATH/src/shopping/db</code>，这意味着你可以很容易地导入<code>test/db</code>，只要工作空间下的<code>src/test/db</code>的文件夹有一个<code>db</code>的包。</p>
<p>If you’re building a package, you don’t need anything more than what we’ve seen. To build an executable, you still need a <code>main</code>. The way I prefer to do this is to create a subfolder called <code>main</code> inside of <code>shopping</code> with a file called <code>main.go</code> and the following content:</p>
<p>如果你想建一个包，只需要我们看到的这些内容就可以了。要创建一个可执行程序，我们还需要一个<code>main</code>函数。我喜欢在<code>shopping</code>文件夹下建一个<code>main</code>文件夹并新增一个<code>main.go</code>的文件。它的内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"shopping"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(shopping.PriceCheck(<span class="number">4343</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can now run your code by going into your <code>shopping</code> project and typing:</p>
<p>进入<code>shopping</code>目录输入如下内容可以运行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main&#x2F;main.go</span><br></pre></td></tr></table></figure>

<h3 id="循环导入（Cyclical-Imports）"><a href="#循环导入（Cyclical-Imports）" class="headerlink" title="循环导入（Cyclical Imports）"></a>循环导入（Cyclical Imports）</h3><p>As you start writing more complex systems, you’re bound to run into cyclical imports. This happens when package A imports package B but package B imports package A (either directly or indirectly through another package). This is something the compiler won’t allow.</p>
<p>当你开始写一些更复杂的系统时，你不免会碰到循环导入的问题。当包A的导入了包B但是包B又导入了包A（无论是直接还是间接通过其他包导入）循环导入就发生了。这是编译器不允许的。</p>
<p>Let’s change our shopping structure to cause the error.</p>
<p>让我们来修改一下<code>shopping</code>的结构来引发这个错误。</p>
<p>Move the <code>Item</code> definition from <code>shopping/db/db.go</code> into <code>shopping/pricecheck.go</code>. Your <code>pricecheck.go</code> file should now look like:</p>
<p>把<code>Item</code>的定义从<code>shopping/db/db.go</code>移到<code>shopping/pricecheck.go</code>中。你的<code>pricecheck.go</code>应该看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shopping</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"shopping/db"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PriceCheck</span><span class="params">(itemId <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  item := db.LoadItem(itemId)</span><br><span class="line">  <span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.Price, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you try to run the code, you’ll get a couple of errors from <code>db/db.go</code> about <code>Item</code> being undefined. This makes sense. <code>Item</code> no longer exists in the <code>db</code> package; it’s been moved to the shopping package. We need to change <code>shopping/db/db.go</code> to:</p>
<p>如果你尝试运行代码，你会从<code>db/db.go</code>中收到一些错误信息说<code>Item</code>未定义。这好理解。<code>Item</code>已经不在<code>db</code>包下了；这被移到了<code>shopping</code>包。我们需要修改<code>shopping/db/db.go</code>的代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"shopping"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">shopping</span>.<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;shopping.Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now when you try to run the code, you’ll get a dreaded <em>import cycle not allowed</em> error. We solve this by introducing another package which contains shared structures. Your directory structure should look like:</p>
<p>现在当你尝试运行代码时，你会收到一个令人害怕的错误<em>import cycle not allowed</em>。我们通过引入一个包含共享结构的另一个包来解决这个问题。你的目录结构看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH&#x2F;src</span><br><span class="line">  - shopping</span><br><span class="line">    pricecheck.go</span><br><span class="line">    - db</span><br><span class="line">      db.go</span><br><span class="line">    - models</span><br><span class="line">      item.go</span><br><span class="line">    - main</span><br><span class="line">      main.go</span><br></pre></td></tr></table></figure>

<p><code>pricecheck.go</code> will still import <code>shopping/db</code>, but <code>db.go</code> will now import <code>shopping/models</code> instead of <code>shopping</code>, thus breaking the cycle. Since we moved the shared <code>Item</code> structure to <code>shopping/models/item.go</code>, we need to change <code>shopping/db/db.go</code> to reference the <code>Item</code> structure from <code>models</code> package:</p>
<p><code>pricecheck.go</code>一样是导入<code>shopping/db</code>，但是<code>db.go</code>现在要导入<code>shopping/models</code>来替换<code>shopping</code>，这样打破了循环。因为将共享结构体<code>Item</code>移到了<code>shopping/models/item.go</code>，我们需要修改<code>shopping/db/db.go</code>从<code>model</code>包中引用结构体<code>Item</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"shopping/models"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">models</span>.<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;models.Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You’ll often need to share more than just <code>models</code>, so you might have other similar folder named <code>utilities</code> and such. The important rule about these shared packages is that they shouldn’t import anything from the <code>shopping</code> package or any sub-packages. In a few sections, we’ll look at interfaces which can help us untangle these types of dependencies.</p>
<p>你常常需要的共享结构不仅仅是<code>models</code>，所以你可能还有一些类似<code>utilities</code>这样的文件夹。最重要的原则是这些共享对象，不能导入<code>shopping</code>包或者它的子包。要不了几个章节，我们会看到接口是如何解开这些依赖的。</p>
<h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><p>Go uses a simple rule to define what types and functions are visible outside of a package. If the name of the type or function starts with an uppercase letter, it’s visible. If it starts with a lowercase letter, it isn’t.</p>
<p>Go用一个非常简单的原则来决定一个包的类型和函数是否在包外可见。如果类型或者函数是以大写字母开头，就是可见的，如果是小写字母开头，就是不可见的。</p>
<p>This also applies to structure fields. If a structure field name starts with a lowercase letter, only code within the same package will be able to access them.</p>
<p>这对结构体的字段也是一样适用的。如果一个结构体的字段名是以小写字母开头，只有在同一个包里的代码可以访问它们。</p>
<p>For example, if our <code>items.go</code> file had a function that looked like:</p>
<p>例如：在我们的<code>items.go</code>文件中有这样的一个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewItem</span><span class="params">()</span> *<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>it could be called via <code>models.NewItem()</code>. But if the function was named <code>newItem</code>, we wouldn’t be able to access it from a different package.</p>
<p>可以通过<code>models.NewItem()</code>来调用。但是如果这个函数被命名为<code>newItem</code>，我们就不能在其他包里面来调用它了。</p>
<p>Go ahead and change the name of the various functions, types and fields from the <code>shopping</code> code. For example, if you rename the <code>Item&#39;s</code> <code>Price</code> field to <code>price</code>, you should get an error.</p>
<p>继续修改在<code>shopping</code>中修改函数，类型和字段的名字。例如，如果你修改<code>Item</code>的<code>Price</code>为<code>price</code>,你会收到一个编译错误。</p>
<h3 id="包管理（Package-Management）"><a href="#包管理（Package-Management）" class="headerlink" title="包管理（Package Management）"></a>包管理（Package Management）</h3><p>The <code>go</code> command we’ve been using to <code>run</code> and <code>build</code> has a <code>get</code> subcommand which is used to fetch third-party libraries. <code>go get</code> supports various protocols but for this example, we’ll be getting a library from Github, meaning, you’ll need <code>git</code> installed on your computer.</p>
<p>我们用来<code>run</code>和<code>build</code>的<code>go</code>命令，它还一个<code>get</code>的子命令用来获取第三方的类库。<code>go get</code>支持多种协议，但是这里，我们将从Github上获取一个类库。这是说，你要在你的电脑上安装好<code>git</code>。</p>
<p>Assuming you already have git installed, from a shell/command prompt, enter:</p>
<p>假设你已经安装好了git，打开一个shell/命令提示符，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;mattn&#x2F;go-sqlite3</span><br></pre></td></tr></table></figure>

<p><code>go get</code> fetches the remote files and stores them in your workspace. Go ahead and check your <code>$GOPATH/src</code>. In addition to the <code>shopping</code> project that we created, you’ll now see a <code>github.com</code> folder. Within, you’ll see a <code>mattn</code> folder which contains a <code>go-sqlite3</code> folder.</p>
<p><code>go get</code>获取远程文件并把它们存在你的工作目录中。到<code>$GOPATH/src</code>目录中检查一下。除了我们自己创建的<code>shopping</code>项目外，还会看到一个<code>github.com</code>文件夹。里面你会看到一个包含<code>go-sqlite3</code>文件夹的<code>mattn</code>文件夹。</p>
<p>We just talked about how to import packages that live in our workspace. To use our newly gotten <code>go-sqlite3</code> package, we’d import it like so:</p>
<p>我们刚介绍了在工作区中如何导入包。要用我们刚刚获取到的<code>go-sqlite3</code>包，我们需要像这样来导入它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/mattn/go-sqlite3"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>I know this looks like a URL but in reality, it’ll simply import the <code>go-sqlite3</code> package which it expects to find in <code>$GOPATH/src/github.com/mattn/go-sqlite3</code>.</p>
<p>我知道这看起来像是一个URL，但实际上，如果知道是在<code>$GOPATH/src/github.com/mattn/go-sqlite3</code>目录，导入<code>go-sqlite3</code>包是很简单的。</p>
<h3 id="依赖管理（Dependency-Management）"><a href="#依赖管理（Dependency-Management）" class="headerlink" title="依赖管理（Dependency Management）"></a>依赖管理（Dependency Management）</h3><p><code>go get</code> has a couple of other tricks up its sleeve. If we <code>go get</code> within a project, it’ll scan all the files, looking for <code>imports</code> to third-party libraries and will download them. In a way, our own source code becomes a <code>Gemfile</code> or <code>package.json</code>.</p>
<p><code>go get</code>有一些其他的戏法。如果我们在一个项目中执行<code>go get</code>，它会扫描所有文件并查找所有导入的第三方库，然后下载这些第三方库。某种程度上说，我们自己的源代码变成一个<code>Gemfile</code>或者<code>package.json</code>。</p>
<p>If you call <code>go get -u</code> it’ll update the packages (or you can update a specific package via <code>go get -u FULL_PACKAGE_NAME</code>).</p>
<p>执行<code>go get -u</code>将更新你的包（或者你可以通过<code>go get -u FULL_PACKAGE_NAME</code>更新指定的包）</p>
<p>Eventually, you might find <code>go get</code> inadequate. For one thing, there’s no way to specify a revision, it always points to the master/head/trunk/default. This is an even larger problem if you have two projects needing different versions of the same library.</p>
<p>最后，你可能发现了<code>go get</code>的一些不足。首先，它不能指定一个修订，它会一直指向<code>master/head/trunk/default</code>。这是一个严重的问题，尤其当你有2个项目需要同一个库的不同版本时。</p>
<p>To solve this, you can use a third-party dependency management tool. They are still young, but two promising ones are <a href="https://github.com/nitrous-io/goop" target="_blank" rel="noopener">goop</a> and <a href="https://github.com/tools/godep" target="_blank" rel="noopener">godep</a>. A more complete list is available at the <a href="https://code.google.com/p/go-wiki/wiki/PackageManagementTools" target="_blank" rel="noopener">go-wiki</a>.</p>
<p>为了解决这个问题，你可以使用一个第三方的依赖管理工具。虽然还不太成熟，但是有2个依赖管理工具比较有前景，即<a href="https://github.com/nitrous-io/goop" target="_blank" rel="noopener">goop</a>和<a href="https://github.com/tools/godep" target="_blank" rel="noopener">godep</a>。更完整的列表可以参考<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="noopener">go-wiki</a>。</p>
<h2 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h2><p>Interfaces are types that define a contract but not an implementation. Here’s an example:</p>
<p>接中是一种定义了协议但没有实现的类型。这是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">  Log(message <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You might be wondering what purpose this could possibly serve. Interfaces help decouple your code from specific implementations. For example, we might have various types of loggers:</p>
<p>你可能会想知道这么做有什么目的。接口可以帮的的代码从特定的实现中解藕出来。例如,我们可能有多种类型的日志：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SqlLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> ConsoleLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> FileLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Yet by programming against the interface, rather than these concrete implementations, we can easily change (and test) which we use without any impact to our code.</p>
<p>是的，能过接口而不是这些具体的实现来编程，我们可以很容易的在不影响我们的代码的基础上修改（和测试）。</p>
<p>How would you use one? Just like any other type, it could be a structure’s field:</p>
<p>你要如何来使用？就像其他类型一样，它可以是一个结构体的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  logger Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>or a function parameter (or return value):</p>
<p>或者是一个函数的参数（或者访回值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(logger Logger)</span></span> &#123;</span><br><span class="line">  logger.Log(<span class="string">"hello!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In a language like C# or Java, we have to be explicit when a class implements an interface:</p>
<p>在像C#或者Java的语言中，我们必须显示的申请明一个类实现了一个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConsoleLogger : Logger &#123;</span><br><span class="line">  public void Logger(message <span class="keyword">string</span>) &#123;</span><br><span class="line">    Console.WriteLine(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In Go, this happens implicitly. If your structure has a function name <code>Log</code> with a <code>string</code> parameter and no return value, then it can be used as a <code>Logger</code>. This cuts down on the verboseness of using interfaces:</p>
<p>在Go中，这是隐式的。如果的结构体有一个名为<code>Log</code>的函数，有一个<code>string</code>的参数和没有返回值，那么它就可以当作<code>Logger</code>来使用。这减少了使用接口时的繁索：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConsoleLogger <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l ConsoleLogger)</span> <span class="title">Log</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It also tends to promote small and focused interfaces. The standard library is full of interfaces. The <code>io</code> package has a handful of popular ones such as <code>io.Reader</code>, <code>io.Writer</code>, and <code>io.Closer</code>. If you write a function that expects a parameter that you’ll only be calling <code>Close()</code> on, you absolutely should accept an <code>io.Closer</code> rather than whatever concrete type you’re using.</p>
<p>这也会倾向于促进接口的小巧和单一。标准库中到处都是接口。在<code>io</code>包中有一些流行的接口，如<code>io.Reader</code>, <code>io.Writer</code>, 和<code>io.Closer</code>。如果你要写一个函数需要一个参数但只调用它的<code>Close()</code>方法，你绝对可以使用<code>io.Closer</code>接口需不是任何具体的类型。</p>
<p>Interfaces can also participate in composition. And, interfaces themselves can be composed of other interfaces. For example, <code>io.ReadCloser</code> is an interface composed of the <code>io.Reader</code> interface as well as the <code>io.Closer</code> interface.</p>
<p>接口也可以组合。也就是说接口可以有其他接口组成。例如，<code>io.ReadCloser</code>就是由接口<code>io.Reader</code>和<code>io.Closer</code>接口组成。</p>
<p>Finally, interfaces are commonly used to avoid cyclical imports. Since they don’t have implementations, they’ll have limited dependencies.</p>
<p>最后，接口常用于避免循环导入。由于接口没有实现，他们的依赖关系有限。</p>
<h2 id="继续之前（Before-You-Continue）"><a href="#继续之前（Before-You-Continue）" class="headerlink" title="继续之前（Before You Continue）"></a>继续之前（Before You Continue）</h2><p>Ultimately, how you structure your code around Go’s workspace is something that you’ll only feel comfortable with after you’ve written a couple of non-trivial projects. What’s most important for you to remember is the tight relationship between package names and your directory structure (not just within a project, but within the entire workspace).</p>
<p>最后，当你试着用go写一些简单的项目之后，你会习惯在go语言的工作区中组织代码的方式。最重要是的记住go语言中的包名和你的目录结构有密切关系（不仅仅在一个项目中，在整个工作空间都如此）。</p>
<p>The way Go handles visibility of types is straightforward and effective. It’s also consistent. There are a few things we haven’t looked at, such as constants and global variables but rest assured, their visibility is determined by the same naming rule.</p>
<p>go语言处理类型的可见性方法是简单有效的。也是一致的。还有一些内容我们没有介绍，例如常量和全局变量，但是不用担心，它们的可见性也是遵循同样的规则。</p>
<p>Finally, if you’re new to interfaces, it might take some time before you get a feel for them. However, the first time you see a function that expects something like <code>io.Reader</code>, you’ll find yourself thanking the author for not demanding more than he or she needed.</p>
<p>最后，如果你不熟悉go语言中的接口，你可能需要花一些时间去感受它们。无论如何，当你首次看见一个函数需要例如<code>io.Reader</code>之类的参数时，你会发现你自己感激作者的要求不是太苛刻。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-3/" class="post-title-link" itemprop="url">Go Little Book - 第三章 - 字典 ，数组和切片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:45:04" itemprop="dateCreated datePublished" datetime="2018-11-22T10:45:04+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:43" itemprop="dateModified" datetime="2018-12-05T10:40:43+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章-字典-，数组和切片（Chapter-3-Maps-Arrays-and-Slices）"><a href="#第三章-字典-，数组和切片（Chapter-3-Maps-Arrays-and-Slices）" class="headerlink" title="第三章 - 字典 ，数组和切片（Chapter 3 - Maps, Arrays and Slices）"></a>第三章 - 字典 ，数组和切片（Chapter 3 - Maps, Arrays and Slices）</h1><p>So far we’ve seen a number of simple types and structures. It’s now time to look at arrays, slices and maps.</p>
<p>目前为止我们看了些简单类型和结构体。现在是时候来看看数组，切片和字典了。</p>
<h2 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h2><p>If you come from Python, Ruby, Perl, JavaScript or PHP (and more), you’re probably used to programming with <em>dynamic arrays</em>. These are arrays that resize themselves as data is added to them. In Go, like many other languages, arrays are fixed. Declaring an array requires that we specify the size, and once the size is specified, it cannot grow:</p>
<p>如果你从Python、Ruby、Perl、JavaScript或者PHP（还有更多），你可能使用过<em>动态数组</em>。这些数组当数据添加进来可以调整大小。在Go中，和其他语言一样，数组是固定大小的。申请一个数组需要我们指定它的大小。申明一个数组时需要指定大小，一旦大小指定了，就不能增长了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">scores[<span class="number">0</span>] = <span class="number">339</span></span><br></pre></td></tr></table></figure>

<p>The above array can hold up to 10 scores using indexes <code>scores[0]</code> through <code>scores[9]</code>. Attempts to access an out of range index in the array will result in a compiler or runtime error.</p>
<p>上面的这个数组从<code>scores[0]</code>到<code>scores[9]</code>可以容纳10个分数。尝试访问超出数组索引的会报编译或者运行时错误。</p>
<p>We can initialize the array with values:</p>
<p>我们可以带值初始化数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">9001</span>, <span class="number">9333</span>, <span class="number">212</span>, <span class="number">33</span>&#125;</span><br></pre></td></tr></table></figure>

<p>We can use <code>len</code> to get the length of the array. <code>range</code> can be used to iterate over it:</p>
<p>我们可能通过<code>len</code>来获取数组的长度。可以用<code>range</code>来迭代数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> scores &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arrays are efficient but rigid. We often don’t know the number of elements we’ll be dealing with upfront. For this, we turn to slices.</p>
<p>数组高效但不灵活。我们常常不能预先知道有多少元素需要处理。因此，我们使用切片。</p>
<h2 id="切片（Slices）"><a href="#切片（Slices）" class="headerlink" title="切片（Slices）"></a>切片（Slices）</h2><p>In Go, you rarely, if ever, use arrays directly. Instead, you use slices. A slice is a lightweight structure that wraps and represents a portion of an array. There are a few ways to create a slice, and we’ll go over when to use which later on. The first is a slight variation on how we created an array:</p>
<p>在Go中，你很少，或者根本不，直接使用数组。反而，你使用切片。切片是对数组一个轻量型封装。有几种方式来创建一个切片，我们会全部过一遍。第一种方式和创建数组有一点小小的变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">293</span>,<span class="number">4</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Unlike the array declaration, our slice isn’t declared with a length within the square brackets. To understand how the two are different, let’s see another way to create a slice, using <code>make</code>:</p>
<p>和申请数组不同，我们的切片没有在中括号内指定长度。要理解这两者的不同，我们用另一种方式创建切片，使用<code>make</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>We use <code>make</code> instead of <code>new</code> because there’s more to creating a slice than just allocating the memory (which is what <code>new</code> does). Specifically, we have to allocate the memory for the underlying array and also initialize the slice.  In the above, we initialize a slice with a length of 10 and a capacity of 10. The length is the size of the slice, the capacity is the size of the underlying array. Using <code>make</code> we can specify the two separately:</p>
<p>我们使用<code>make</code>来替代<code>new</code>因为创建一个切片比只是分配内存（<code>new</code>做的事情）要复杂一些。特别的，我们需要分配底层数组和初始化切片。上面的例子，我们初始化了一个长度和容量为10的切片。长度是切片的大小，容量时底层数组的大小。使用<code>make</code>时可以分开提定这两个值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>This creates a slice with a length of 0 but with a capacity of 10. (If you’re paying attention, you’ll note that <code>make</code> and <code>len</code> <em>are</em> overloaded. Go is a language that, to the frustration of some, makes use of features which aren’t exposed for developers to use.)</p>
<p>这创建了一个长度为0但容量为10的切片。（如果你留心，你会注意到<code>make</code>和<code>len</code><em>是</em>重载的。Go有的时候令人沮丧，一些在使用的功能没有暴露给开发者使用。）</p>
<p>To better understand the interplay between length and capacity, let’s look at some examples:</p>
<p>为了更好的理解长度和容量之间的相互作用，让我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  scores[<span class="number">5</span>] = <span class="number">9033</span></span><br><span class="line">  fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our first example crashes. Why? Because our slice has a length of 0. Yes, the underlying array has 10 elements, but we need to explicitly expand our slice in order to access those elements. One way to expand a slice is via <code>append</code>:</p>
<p>我们的第一个程序崩溃了。为什么呢？因我们的切片的长度为0。是的，底层数组有10个元素，但是我们需要显示的扩展切片来访问这些元素。一种扩展方式是使用<code>append</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  scores = <span class="built_in">append</span>(scores, <span class="number">5</span>)</span><br><span class="line">  fmt.Println(scores) <span class="comment">// prints [5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But that changes the intent of our original code. Appending to a slice of length 0 will set the first element. For whatever reason, our crashing code wanted to set the element at index 5. To do this, we can re-slice our slice:</p>
<p>上面的修改改变了我们的原始代码的意图。扩展一个长度为0的切片会设置第一个元素。无论什么原因，我们崩溃的代码想要的是修改索引为5的元素。 我们可以重切片一次我们的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">  scores = scores[<span class="number">0</span>:<span class="number">6</span>]</span><br><span class="line">  scores[<span class="number">5</span>] = <span class="number">9033</span></span><br><span class="line">  fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>How large can we resize a slice? Up to its capacity which, in this case, is 10. You might be thinking <em>this doesn’t actually solve the fixed-length issue of arrays.</em> It turns out that <code>append</code> is pretty special. If the underlying array is full, it will create a new larger array and copy the values over (this is exactly how dynamic arrays work in PHP, Python, Ruby, JavaScript, …). This is why, in the example above that used <code>append</code>, we had to re-assign the value returned by <code>append</code> to our <code>scores</code> variable: <code>append</code> might have created a new value if the original had no more space.</p>
<p>我们调整切片最大是多少？这是由它的容量决定的，在本例中，是10。你可能会想<em>这没有从本质上解决数能固定和长度的问题</em>。事实上，<code>append</code>是非常特殊的。当底层数组满了，它会创建一个新的数组，并把数值拷贝过来（PHP, Python, Ruby, JavaScript等也是这么做的）。这也就是为什么，我们上面的代码，使用了<code>append</code>之后，我们需要把<code>append</code>的返回值重新赋值给<code>scores</code>的原因：<code>append</code>会产生一个新的值如果原始的空间不足。</p>
<p>If I told you that Go grew arrays with a 2x algorithm, can you guess what the following will output?</p>
<p>如果我告诉你说Go是近两倍的算法来增长数组，那下面的代码会输出什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">  c := <span class="built_in">cap</span>(scores)</span><br><span class="line">  fmt.Println(c)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">25</span>; i++ &#123;</span><br><span class="line">    scores = <span class="built_in">append</span>(scores, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if our capacity has changed,</span></span><br><span class="line">    <span class="comment">// Go had to grow our array to accommodate the new data</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span>(scores) != c &#123;</span><br><span class="line">      c = <span class="built_in">cap</span>(scores)</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The initial capacity of <code>scores</code> is 5. In order to hold 20 values, it’ll have to be expanded 3 times with a capacity of 10, 20 and finally 40.</p>
<p><code>scores</code>最初的容量是5。为了容纳20个值，它将会扩展3次，分别是10，20和40。</p>
<p>As a final example, consider:</p>
<p>来思考下最后一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">  scores = <span class="built_in">append</span>(scores, <span class="number">9332</span>)</span><br><span class="line">  fmt.Println(scores)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, the output is going to be <code>[0, 0, 0, 0, 0, 9332]</code>. Maybe you thought it would be <code>[9332, 0, 0, 0, 0]</code>? To a human, that might seem logical. To a compiler, you’re telling it to append a value to a slice that already holds 5 values.</p>
<p>这里，输出是<code>[0, 0, 0, 0, 0, 9332]</code>。可能你会想它应该是<code>[9332, 0, 0, 0, 0]</code>？对于人来说这可能符合逻辑。对于编译器来说，你告诉它的就是要扩展一个已经有5个值的切片。</p>
<p>Ultimately, there are four common ways to initialize a slice:</p>
<p>最后，有四种常用的方式来初始化一个切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;<span class="string">"leto"</span>, <span class="string">"jessica"</span>, <span class="string">"paul"</span>&#125;</span><br><span class="line">checks := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line">scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>When do you use which? The first one shouldn’t need much of an explanation. You use this when you know the values that you want in the array ahead of time.</p>
<p>何时用哪一种呢？第一种不需要过多的解释。当你知道所有的值并且你要的是数组头的时候使用。</p>
<p>The second one is useful when you’ll be writing into specific indexes of a slice. For example:</p>
<p>当你需要写入切片的指定索引时，第二种就很有用。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractPowers</span><span class="params">(saiyans []*Saiyans)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  powers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(saiyans))</span><br><span class="line">  <span class="keyword">for</span> index, saiyan := <span class="keyword">range</span> saiyans &#123;</span><br><span class="line">    powers[index] = saiyan.Power</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> powers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The third version is a nil slice and is used in conjunction with <code>append</code>, when the number of elements is unknown.</p>
<p>当知道有多少元素的时候，就可使用第三种是一个空切片和<code>append</code>配合使用。</p>
<p>The last version lets us specify an initial capacity; useful if we have a general idea of how many elements we’ll need.</p>
<p>当我们对需要多少元素有多少了解时使用最后一种方式来指定初始容量。</p>
<p>Even when you know the size, <code>append</code> can be used. It’s largely a matter of preference:</p>
<p>即使你知道了大小，<code>append</code>依然可以使用。这很大程度上是一个偏好问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractPowers</span><span class="params">(saiyans []*Saiyans)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  powers := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(saiyans))</span><br><span class="line">  <span class="keyword">for</span> _, saiyan := <span class="keyword">range</span> saiyans &#123;</span><br><span class="line">    powers = <span class="built_in">append</span>(powers, saiyan.Power)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> powers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Slices as wrappers to arrays is a powerful concept. Many languages have the concept of slicing an array. Both JavaScript and Ruby arrays have a <code>slice</code> method. You can also get a slice in Ruby by using <code>[START..END]</code> or in Python via <code>[START:END]</code>. However, in these languages, a slice is actually a new array with the values of the original copied over. If we take Ruby, what’s the output of the following?</p>
<p>切片做为数组的封装是一个很有用的概念。许多语言有数组切片的概念。JavaScript和Ruby的数组都有<code>slice</code>方法。你可以对通过<code>[START..END]</code>或者在Python中用<code>[START:END]</code>的方式取得一个切片。但是，在这些语言中切片是对原数组的拷贝。如果我们使用Ruby，下面的代码会输出什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scores = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">slice = scores[<span class="number">2.</span><span class="number">.4</span>]</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">puts scores</span><br></pre></td></tr></table></figure>

<p>The answer is <code>[1, 2, 3, 4, 5]</code>. That’s because <code>slice</code> is a completely new array with copies of values. Now, consider the Go equivalent:</p>
<p>答案是<code>[1, 2, 3, 4, 5]</code>。那是因为<code>slice</code>是一个复制了所有值的全新数组。现在，来看下Go相同的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">slice := scores[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">fmt.Println(scores)</span><br></pre></td></tr></table></figure>

<p>The output is <code>[1, 2, 999, 4, 5]</code>.</p>
<p>输出是<code>[1, 2, 999, 4, 5]</code>。</p>
<p>This changes how you code. For example, a number of functions take a position parameter. In JavaScript, if we want to find the first space in a string (yes, slices work on strings too!) after the first five characters, we’d write:</p>
<p>这改变了你的编码方式。比如，一些函数需要一个位置参数。在JavaScript中，如果我们需要找到字符串中第五个字符之后的第一个空格（是的，切片对字符串也是有效的！）， 我们这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">haystack = <span class="string">"the spice must flow"</span>;</span><br><span class="line">console.log(haystack.indexOf(<span class="string">" "</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>In Go, we leverage slices:</p>
<p>在Go中，我们使用切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Index(haystack[<span class="number">5</span>:], <span class="string">" "</span>)</span><br></pre></td></tr></table></figure>

<p>We can see from the above example, that <code>[X:]</code> is shorthand for <em>from X to the end</em> while <code>[:X]</code> is shorthand for <em>from the start to X</em>. Unlike other languages, Go doesn’t support negative values. If we want all of the values of a slice except the last, we do:</p>
<p>上面的例子，我们可以看到，<code>[X:]</code>是<em>从X到结束</em>的简写，就如<code>[:X]</code>是<em>从开始到X</em>的简写一样。和其他语言不同的是，Go不支持反向取值（这边感觉不对）。如果我们需要切片除了最后一个值以外的所有值，我们这样来写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">scores = scores[:<span class="built_in">len</span>(scores)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>The above is the start of an efficient way to remove a value from an unsorted slice:</p>
<p>以上是一种快速删除未排序的切片中的某个值的方法的开头：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">  scores = removeAtIndex(scores, <span class="number">2</span>)</span><br><span class="line">  fmt.Println(scores)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAtIndex</span><span class="params">(source []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">  lastIndex := <span class="built_in">len</span>(source) - <span class="number">1</span></span><br><span class="line">  <span class="comment">//swap the last value and the value we want to remove</span></span><br><span class="line">  source[index], source[lastIndex] = source[lastIndex], source[index]</span><br><span class="line">  <span class="keyword">return</span> source[:lastIndex]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, now that we know about slices, we can look at another commonly used built-in function: <code>copy</code>. <code>copy</code> is one of those functions that highlights how slices change the way we code. Normally, a method that copies values from one array to another has 5 parameters: <code>source</code>, <code>sourceStart</code>, <code>count</code>, <code>destination</code> and <code>destinationStart</code>. With slices, we only need two:</p>
<p>最后，既然我们是学习了切片，我们来看另一个常用的内置函数： <code>copy</code>。 <code>copy</code>是能突出切片是如何改变我们的编码方式的函数之一。通常，数组间拷贝需要5个参数：<code>source</code>, <code>sourceStart</code>, <code>count</code>, <code>destination</code> 和 <code>destinationStart</code>。使用切片只要两个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math/rand"</span></span><br><span class="line">  <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  scores := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    scores[i] = <span class="keyword">int</span>(rand.Int31n(<span class="number">1000</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  sort.Ints(scores)</span><br><span class="line"></span><br><span class="line">  worst := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="built_in">copy</span>(worst, scores[:<span class="number">5</span>])</span><br><span class="line">  fmt.Println(worst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Take some time and play with the above code. Try variations. See what happens if you change copy to something like <code>copy(worst[2:4], scores[:5])</code>, or what if you try to copy more or less than <code>5</code> values into <code>worst</code>?</p>
<p>花一些时间来执行上面的代码。多试几次。看看会发生什么，如果将代码改为<code>copy(worst[2:4], scores[:5])</code>，或者要拷贝比<code>5</code>更多或少的值到<code>worst</code>？</p>
<h2 id="映射（Maps）"><a href="#映射（Maps）" class="headerlink" title="映射（Maps）"></a>映射（Maps）</h2><p>Maps in Go are what other languages call hashtables or dictionaries. They work as you expect: you define a key and value, and can get, set and delete values from it.</p>
<p>Go中的映射在其他语言中叫哈希表或者字典。它们都如你想的一样：你定义一个键和值，然后你可以通过映射来删改查这些值。</p>
<p>Maps, like slices, are created with the <code>make</code> function. Let’s look at an example:</p>
<p>映射，和切片一样，是通过<code>make</code>函数来创建的。让我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lookup := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">  lookup[<span class="string">"goku"</span>] = <span class="number">9001</span></span><br><span class="line">  power, exists := lookup[<span class="string">"vegeta"</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prints 0, false</span></span><br><span class="line">  <span class="comment">// 0 is the default value for an integer</span></span><br><span class="line">  fmt.Println(power, exists)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To get the number of keys, we use <code>len</code>. To remove a value based on its key, we use <code>delete</code>:</p>
<p>我们使用<code>len</code>来获取有多少键。要通过键来删除一个值，我们用<code>delete</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns 1</span></span><br><span class="line">total := <span class="built_in">len</span>(lookup)</span><br><span class="line"></span><br><span class="line"><span class="comment">// has no return, can be called on a non-existing key</span></span><br><span class="line"><span class="built_in">delete</span>(lookup, <span class="string">"goku"</span>)</span><br></pre></td></tr></table></figure>

<p>Maps grow dynamically. However, we can supply a second argument to <code>make</code> to set an initial size:</p>
<p>映射是动态增长的。但是，我们可以通过<code>make</code>的第二个参数来设置它的初始大小：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lookup := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>If you have some idea of how many keys your map will have, defining an initial size can help with performance.</p>
<p>如果知道有多少值，指定初始大小可以有更好的性能表现。</p>
<p>When you need a map as a field of a structure, you define it as:</p>
<p>如果想要把映射做为结构体的一个字段，我们这样定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Friends <span class="keyword">map</span>[<span class="keyword">string</span>]*Saiyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>One way to initialize the above is via:</p>
<p>初始化的一种方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Name: <span class="string">"Goku"</span>,</span><br><span class="line">  Friends: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Saiyan),</span><br><span class="line">&#125;</span><br><span class="line">goku.Friends[<span class="string">"krillin"</span>] = ... <span class="comment">//todo load or create Krillin</span></span><br></pre></td></tr></table></figure>

<p>There’s yet another way to declare and initialize values in Go. Like <code>make</code>, this approach is specific to maps and arrays. We can declare as a composite literal:</p>
<p>在Go中有另一种申明和初始化的方式。和<code>make</code>一样，这对映射和数组都是有效的。我们可以像组合文字一样申明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lookup := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">  <span class="string">"goku"</span>: <span class="number">9001</span>,</span><br><span class="line">  <span class="string">"gohan"</span>: <span class="number">2044</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can iterate over a map using a <code>for</code> loop combined with the <code>range</code> keyword:</p>
<p>我们可以通过<code>for</code>和<code>range</code>关键字来迭代映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> lookup &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iteration over maps isn’t ordered. Each iteration over a lookup will return the key value pair in a random order.</p>
<p>映射的迭代器是无序的。每个迭代器随机查找键值对。</p>
<h2 id="指针和值（Pointers-versus-Values）"><a href="#指针和值（Pointers-versus-Values）" class="headerlink" title="指针和值（Pointers versus Values）"></a>指针和值（Pointers versus Values）</h2><p>We finished Chapter 2 by looking at whether you should assign and pass pointers or values. We’ll now have this same conversation with respect to array and map values. Which of these should you use?</p>
<p>通过了解什么时候传值或指针我们结束了第二章。在数组和映射的值方面我们将碰到相同的问题。我们应该用哪一种？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]Saiyan, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">b := <span class="built_in">make</span>([]*Saiyan, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>Many developers think that passing <code>b</code> to, or returning it from, a function is going to be more efficient. However, what’s being passed/returned is a copy of the slice, which itself is a reference. So with respect to passing/returning the slice itself, there’s no difference.</p>
<p>许多开发人员会想对于一个函数来说是传<code>b</code>还是将它做为返回值更高效。然而，这里传递或者返回的都是一个切片的拷贝，它本身就是一个引用。所以就传递或者返回这个切片而言，没有什么区别。</p>
<p>Where you will see a difference is when you modify the values of a slice or map. At this point, the same logic that we saw in Chapter 2 applies. So the decision on whether to define an array of pointers versus an array of values comes down to how you use the individual values, not how you use the array or map itself.</p>
<p>当你改变一个切片或者映射的值时，你会看见不同。在这点上，同样的逻辑，我们在第二章看到已经适用。所以是否定义一个数组指针还是一个数组值主要归结于如何使用单个值，而不是你如何使用数组或者映射本身。</p>
<h2 id="继续之前（Before-You-Continue）"><a href="#继续之前（Before-You-Continue）" class="headerlink" title="继续之前（Before You Continue）"></a>继续之前（Before You Continue）</h2><p>Arrays and maps in Go work much like they do in other languages. If you’re used to dynamic arrays, there might be a small adjustment, but <code>append</code> should solve most of your discomfort. If we peek beyond the superficial syntax of arrays, we find slices. Slices are powerful and they have a surprisingly large impact on the clarity of your code.</p>
<p>在Go中数组和映射的工作方式与其他语言非常像。如果你用过动态数组，可能有会有一些需要调整，但是通过<code>append</code>可以解决所有的不适。如果我们抛开数组表面的语法，我们就会发现切片。切片是相当强大的，使用切片对你代码的整洁性有着非常巨大的影响。</p>
<p>There are edge cases that we haven’t covered, but you’re not likely to run into them. And, if you do, hopefully the foundation we’ve built here will let you understand what’s going on.</p>
<p>这里有一些边界例子我们没有涉及到，但是你不太可能遇见这些例子。另外，如果你遇到了，希望我们已经打下的基础能让你理解这是怎么回事。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-2/" class="post-title-link" itemprop="url">Go Little Book - 第二章 - 结构体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:26:07" itemprop="dateCreated datePublished" datetime="2018-11-22T10:26:07+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:51" itemprop="dateModified" datetime="2018-12-05T10:40:51+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二章-结构体（Chapter-2-Structures）"><a href="#第二章-结构体（Chapter-2-Structures）" class="headerlink" title="第二章 - 结构体（Chapter 2 - Structures）"></a>第二章 - 结构体（Chapter 2 - Structures）</h1><p>Go isn’t an object-oriented (OO) language like C++, Java, Ruby and C#. It doesn’t have objects nor inheritance and thus, doesn’t have the many concepts associated with OO such as polymorphism and overloading.</p>
<p>和C++, Java, Ruby以及C#不一样，Go并不是面向对象的语言。它没有对象、继承和其他一些和面向对象相关的概念，比各多态和重载。</p>
<p>What Go does have are structures, which can be associated with methods. Go also supports a simple but effective form of composition. Overall, it results in simpler code, but there’ll be occasions where you’ll miss some of what OO has to offer. (It’s worth pointing out that <em>composition over inheritance</em> is an old battle cry and Go is the first language I’ve used that takes a firm stand on the issue.)</p>
<p>Go有的就是结构体，可以直接绑定方法。Go支持简单便高效的组合。总的来说，它带来更简洁的代码，但在一些场合中失去OO的一些特性。（有必要指出 <em>组合优于继承</em> 是一个老早的争议，但Go是我用过的这么多语言中第一个立场这么坚定的。）</p>
<p>Although Go doesn’t do OO like you may be used to, you’ll notice a lot of similarities between the definition of a structure and that of a class. A simple example is the following <code>Saiyan</code> structure:</p>
<p>虽然Go确实不是你用过的OO样，但是你会发现结构体和类之间的很多相似之处。来看一个简单的例子，结构体<code>Saiyan</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’ll soon see how to add a method to this structure, much like you’d have methods as part of a class. Before we do that, we have to dive back into declarations.<br>很快我们就会看到怎么往这个结构体中添加方法，就像你要类中添加方法一样。在那之前，我们先细看下结构体的声明.</p>
<h2 id="声明和初始化（Declarations-and-Initializations）"><a href="#声明和初始化（Declarations-and-Initializations）" class="headerlink" title="声明和初始化（Declarations and Initializations）"></a>声明和初始化（Declarations and Initializations）</h2><p>When we first looked at variables and declarations, we looked only at built-in types, like integers and strings. Now that we’re talking about structures, we need to expand that conversation to include pointers.</p>
<p>我们最初学习变量和声明的时候，我们只用到内建类型，比如整形和字符串。现在我们讲的是结构体，我们要深入这个话题，包括指针。</p>
<p>The simplest way to create a value of our structure is:<br>创建一个结构体的值最简单的方式是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;</span><br><span class="line">  Name: <span class="string">"Goku"</span>,</span><br><span class="line">  Power: <span class="number">9000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Note:</em> The trailing <code>,</code> in the above structure is required. Without it, the compiler will give an error. You’ll appreciate the required consistency, especially if you’ve used a language or format that enforces the opposite.</p>
<p><em>注意：</em>结构体中最后一个<code>,</code>是必需的。没有的话，编译器会报错。你会喜欢这种一致性要求，特别是如果你使用了强制性相反的语言或格式</p>
<p>We don’t have to set all or even any of the fields. Both of these are valid:<br>我们可以不给所有或者任何一个字段赋值。下面两种方式都是正确的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">goku := Saiyan&#123;Name: <span class="string">"Goku"</span>&#125;</span><br><span class="line">goku.Power = <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>Just like unassigned variables have a zero value, so do fields.</p>
<p>和没有赋值的变量一样，没有赋值的字段默认为0值。</p>
<p>Furthermore, you can skip the field name and rely on the order of the field declarations (though for the sake of clarity, you should only do this for structures with few fields):</p>
<p>再者，你也可以省略字段的名字，按字段的顺序进行声明（尽管为了简洁起见，你尽量在结构体只有少量字段时才使用这种方式）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goku := Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br></pre></td></tr></table></figure>

<p>What all of the above examples do is declare a variable <code>goku</code> and assign a value to it.</p>
<p>上面所有的例子所做的事件就是声明一个变量<code>goku</code>并给它赋一个值。</p>
<p>Many times though, we don’t want a variable that is directly associated with our value but rather a variable that has a pointer to our value. A pointer is a memory address; it’s the location of where to find the actual value. It’s a level of indirection. Loosely, it’s the difference between being at a house and having directions to the house.</p>
<p>很多时候，我们不想变量直接相关的值，而是一个指向指针的变量。指针是内存地址，它可以定位实际的值有哪里。这是一种间接层。简单点说，这好比是在房子里还是有房子地址的区别。</p>
<p>Why do we want a pointer to the value, rather than the actual value? It comes down to the way Go passes arguments to a function: as copies. Knowing this, what does the following print?</p>
<p>为什么我们确实需要指针，而不是实际的值？这是因为Go在函数中参数的传递方式是：值。了解了这个，下面的程序会打出来什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s Saiyan)</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The answer is 9000, not 19000. Why? Because <code>Super</code> made changes to a copy of our original <code>goku</code> value and thus, changes made in <code>Super</code> weren’t reflected in the caller. To make this work as you probably expect, we need to pass a pointer to our value:</p>
<p>答案是9000，而示是19000。为什么呢？因为<code>Super</code>改变的是<code>goku</code>的一个拷贝的值，<code>Super</code>中的改变不会在调用者中显示出来。要如你期望的方式运行，我们需要传入一个指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := &amp;Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s *Saiyan)</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We made two changes. The first is the use of the <code>&amp;</code> operator to get the address of our value (it’s called the <em>address of</em> operator). Next, we changed the type of parameter <code>Super</code> expects. It used to expect a value of type <code>Saiyan</code> but now expects an address of type <code>*Saiyan</code>, where <code>*X</code> means <em>pointer to value of type X</em>. There’s obviously some relation between the types <code>Saiyan</code> and <code>*Saiyan</code>, but they are two distinct types.</p>
<p>我们做了两处修改。第一处是使用了<code>&amp;</code>操作符来获取值的地址（它被称为 <em>取址</em>操作符）。接下来，我们修改<code>Super</code>期望的参数类型。原来它期望的是<code>Saiyan</code>值类型，而现在期望的是<code>*Saiyan</code>的地址类型，此处<code>*X</code>是指 <em>指向X类型的指针</em>。<code>Saiyan</code>和 <code>*Saiyan</code>的类型有一些明显的关联，但是它们两是不同的类型。</p>
<p>Note that we’re still passing a copy of <code>goku&#39;s</code> value to <code>Super</code> it just so happens that <code>goku&#39;s</code> value has become an address. That copy is the same address as the original, which is what that indirection buys us. Think of it as copying the directions to a restaurant. What you have is a copy, but it still points to the same restaurant as the original.</p>
<p>需要指出的是，我们现在传递给<code>Super</code>参数的仍然是<code>goku</code>的值拷贝。只是现在<code>goku</code>的值变成了一个地址。这个地址拷贝和源地址相同。可以认为它类似一个指向餐厅方向的拷贝，这就间接服务于我们。虽然是一个拷贝，但是和源地址一样，也指向同一个餐厅。</p>
<p>We can prove that it’s a copy by trying to change where it points to (not something you’d likely want to actually do):</p>
<p>我们可以通过改变它的指向来证明这是个拷贝（虽然不是你想要的）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  goku := &amp;Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9000</span>&#125;</span><br><span class="line">  Super(goku)</span><br><span class="line">  fmt.Println(goku.Power)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Super</span><span class="params">(s *Saiyan)</span></span> &#123;</span><br><span class="line">  s = &amp;Saiyan&#123;<span class="string">"Gohan"</span>, <span class="number">1000</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above, once again, prints 9000. This is how many languages behave, including Ruby, Python, Java and C#. Go, and to some degree C#, simply make the fact visible.</p>
<p>上例，依然，打印9000。这和很多语言的行为是一样的，包括Ruby，Python，Java和C#。Go和C#一定程度是要样的，让这个更显而易见。</p>
<p>It should also be obvious that copying a pointer is going to be cheaper than copying a complex structure. On a 64-bit machine, a pointer is 64 bits large. If we have a structure with many fields, creating copies can be expensive. The real value of pointers though is that they let you share values. Do we want <code>Super</code> to alter a copy of <code>goku</code> or alter the shared <code>goku</code> value itself?</p>
<p>很明显拷贝一个指针比拷贝一个复杂的结构体开销小多了。在64位的机器上，一个指针是64位的大小。如果我们有一个有很多字段的结构体，创建一份拷贝开销是比较大的。指针的真正价值是通过它可以共享值。我们想通过<code>Super</code>去改变<code>goku</code>的拷贝或者改变共享的<code>goku</code>值本身？</p>
<p>All this isn’t to say that you’ll always want a pointer. At the end of this chapter, after we’ve seen a bit more of what we can do with structures, we’ll re-examine the pointer-versus-value question.</p>
<p>所有这些不是说你一直要用指针。本章末尾，当我们学到更多结构体的内容后，我们会重新审视指针和值类型的问题。</p>
<h2 id="结构体上的函数（结构体的方法）（Functions-on-Structures）"><a href="#结构体上的函数（结构体的方法）（Functions-on-Structures）" class="headerlink" title="结构体上的函数（结构体的方法）（Functions on Structures）"></a>结构体上的函数（结构体的方法）（Functions on Structures）</h2><p>We can associate a method with a structure:<br>我们可以为结构体关联一个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Saiyan)</span> <span class="title">Super</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s.Power += <span class="number">10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above code, we say that the type <code>*Saiyan</code> is the <strong>receiver</strong> of the <code>Super</code> method. We call <code>Super</code> like so:</p>
<p>上面的代码，我们说<code>*Saiyan</code>是<code>Super</code>方法的 <strong>接收器</strong> 。我们能过这样的方式调用<code>Super</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;<span class="string">"Goku"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">goku.Super()</span><br><span class="line">fmt.Println(goku.Power) <span class="comment">// will print 19001</span></span><br></pre></td></tr></table></figure>

<h2 id="构造器（Constructors）"><a href="#构造器（Constructors）" class="headerlink" title="构造器（Constructors）"></a>构造器（Constructors）</h2><p>Structures don’t have constructors. Instead, you create a function that returns an instance of the desired type (like a factory):</p>
<p>结构体没有构造器。你可创建一个函数来返回一个期望类型的实例来替代（像工厂一样）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSaiyan</span><span class="params">(name <span class="keyword">string</span>, power <span class="keyword">int</span>)</span> *<span class="title">Saiyan</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Saiyan&#123;</span><br><span class="line">    Name: name,</span><br><span class="line">    Power: power,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This pattern rubs a lot of developers the wrong way. On the one hand, it’s a pretty slight syntactical change; on the other, it does feel a little less compartmentalized.</p>
<p>这种方式导致很多开发者犯错。一方面，它有一些轻微的语法变化；另一方面，它有一点让人感觉不好区分。 </p>
<p>Our factory doesn’t have to return a pointer; this is absolutely valid:</p>
<p>我们的工厂没有必要返回指针；下面的代码完全正确：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSaiyan</span><span class="params">(name <span class="keyword">string</span>, power <span class="keyword">int</span>)</span> <span class="title">Saiyan</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Saiyan&#123;</span><br><span class="line">    Name: name,</span><br><span class="line">    Power: power,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建（New）"><a href="#创建（New）" class="headerlink" title="创建（New）"></a>创建（New）</h2><p>Despite the lack of constructors, Go does have a built-in <code>new</code> function which is used to allocate the memory required by a type. The result of <code>new(X)</code> is the same as <code>&amp;X{}</code>:</p>
<p>尽管没有构造器，但是Go有内置的<code>new</code>函数可以用来分配一下指定类弄的内存。<code>new(X)</code>和<code>&amp;X{}</code>的效果是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goku := <span class="built_in">new</span>(Saiyan)</span><br><span class="line"><span class="comment">// same as</span></span><br><span class="line">goku := &amp;Saiyan&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Which you use is up to you, but you’ll find that most people prefer the latter whenever they have fields to initialize, since it tends to be easier to read:</p>
<p>使有哪种方式看你自己的喜好，但是你会发现当字段需要初始化时，大多数人喜欢使用后一种方式，因为这样更易读：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">goku := <span class="built_in">new</span>(Saiyan)</span><br><span class="line">goku.name = <span class="string">"goku"</span></span><br><span class="line">goku.power = <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vs</span></span><br><span class="line"></span><br><span class="line">goku := &amp;Saiyan &#123;</span><br><span class="line">  name: <span class="string">"goku"</span>,</span><br><span class="line">  power: <span class="number">9000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Whichever approach you choose, if you follow the factory pattern above, you can shield the rest of your code from knowing and worrying about any of the allocation details.</p>
<p>无论你使用哪种方式，如果你使用上面的工厂模式，接下来的代码中你可以不要了解和担心任何分配的细节。</p>
<h2 id="结构体字段（Fields-of-a-Structure）"><a href="#结构体字段（Fields-of-a-Structure）" class="headerlink" title="结构体字段（Fields of a Structure）"></a>结构体字段（Fields of a Structure）</h2><p>In the example that we’ve seen so far, <code>Saiyan</code> has two fields <code>Name</code> and <code>Power</code> of types <code>string</code> and <code>int</code>, respectively. Fields can be of any type – including other structures and types that we haven’t explored yet such as arrays, maps, interfaces and functions.</p>
<p>目前为止我们看到的例子中，<code>Saiyan</code>有两个字段，一个<code>字符串</code>类型的<code>Name</code>和一个<code>整型</code>的<code>Power</code>。字段可以是任何类型————包括其他的结构体和暂时我们没有讲到的类型，例如数组、字典、接口和函数。</p>
<p>For example, we could expand our definition of <code>Saiyan</code>:</p>
<p>例如，我们可以这样扩展<code>Saiyan</code>的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">  Father *Saiyan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>which we’d initialize via:</p>
<p>我们可以通过下面的方式初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gohan := &amp;Saiyan&#123;</span><br><span class="line">  Name: <span class="string">"Gohan"</span>,</span><br><span class="line">  Power: <span class="number">1000</span>,</span><br><span class="line">  Father: &amp;Saiyan &#123;</span><br><span class="line">    Name: <span class="string">"Goku"</span>,</span><br><span class="line">    Power: <span class="number">9001</span>,</span><br><span class="line">    Father: <span class="literal">nil</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>Go supports composition, which is the act of including one structure into another. In some languages, this is called a trait or a mixin. Languages that don’t have an explicit composition mechanism can always do it the long way. In Java:</p>
<p>Go支持组合，就是将一个结构体包含在另一个之中。在一些语言中，这被叫特性或混入。没有明确的组合机制的语言，要实现这个特性就比较繁杂。在Java中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saiyan</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Saiyan is said to have a person</span></span><br><span class="line">  <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we forward the call to person</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.person.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This can get pretty tedious. Every method of <code>Person</code> needs to be duplicated in <code>Saiyan</code>. Go avoids this tediousness:</p>
<p>这样会相当的冗长。每个<code>Person</code>的方法都需要在<code>Saiyan</code>中复制一遍。Go可以避免这种冗长：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Introduce</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hi, I'm %s\n"</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Saiyan <span class="keyword">struct</span> &#123;</span><br><span class="line">  *Person</span><br><span class="line">  Power <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and to use it:</span></span><br><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Person: &amp;Person&#123;<span class="string">"Goku"</span>&#125;,</span><br><span class="line">  Power: <span class="number">9001</span>,</span><br><span class="line">&#125;</span><br><span class="line">goku.Introduce()</span><br></pre></td></tr></table></figure>

<p>The <code>Saiyan</code> structure has a field of type <code>*Person</code>. Because we didn’t give it an explicit field name,<br>we can implicitly access the fields and functions of the composed type.<br>However, the Go compiler <em>did</em> give it a field name, consider the perfectly valid:</p>
<p><code>Saiyan</code>结构体中有一个<code>*Person</code>类型的字段。因为我们没有给他一个显示的字段名，我们可以隐示的访问组合类型的所有字段和函数。<br>但出于完全有效的考虑，Go编辑器<em>确实</em>有给它分配一个字段名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goku := &amp;Saiyan&#123;</span><br><span class="line">  Person: &amp;Person&#123;<span class="string">"Goku"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(goku.Name)</span><br><span class="line">fmt.Println(goku.Person.Name)</span><br></pre></td></tr></table></figure>

<p>Both of the above will print “Goku”.</p>
<p>上面的两个输出都是”Goku”。</p>
<p>Is composition better than inheritance? Many people think that it’s a more robust way to share code.<br>When using inheritance, your class is tightly coupled to your superclass and you end up focusing on hierarchy rather than behavior.<br>组合是不优于继承？很多人认为这是一种更健壮的共享代码的方式。当使用继承时，你的类和超类捆绑在一起，你最终关注继承而不是行为。</p>
<h3 id="重载（Overloading）"><a href="#重载（Overloading）" class="headerlink" title="重载（Overloading）"></a>重载（Overloading）</h3><p>While overloading isn’t specific to structures, it’s worth addressing. Simply, Go doesn’t support overloading.<br>For this reason, you’ll see (and write) a lot of functions that look like <code>Load</code>, <code>LoadById</code>, <code>LoadByName</code> and so on.</p>
<p>值得指出的是，结构体没有重载。简而言之，Go不支持重载。因为这个原因，你会看到（和写）很多像 <code>Load</code>, <code>LoadById</code>, <code>LoadByName</code>这样的函数。</p>
<p>However, because implicit composition is really just a compiler trick, we can “overwrite” the functions of a composed type.<br>For example, our <code>Saiyan</code> structure can have its own <code>Introduce</code> function:<br>但是，因为非显示的组合是一个编辑器技巧，我们可以“重写”组合类型的函数。比如， 我们的<code>Saiyan</code>结构体可以有自己的<code>Introduce</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Saiyan)</span> <span class="title">Introduce</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hi, I'm %s. Ya!\n"</span>, s.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The composed version is always available via <code>s.Person.Introduce()</code>.</p>
<p>组合版本中使用<code>s.Person.Introduce()</code>也是一样的。</p>
<h2 id="指针和值（Pointers-versus-Values）"><a href="#指针和值（Pointers-versus-Values）" class="headerlink" title="指针和值（Pointers versus Values）"></a>指针和值（Pointers versus Values）</h2><p>As you write Go code, it’s natural to ask yourself <em>should this be a value, or a pointer to a value?</em> There are two pieces of good news.<br>First, the answer is the same regardless of which of the following we’re talking about:</p>
<p>当你写Go代码的时候，你很自然的就会问你自己<em>这应该是要用值还是要用指针?</em>下面是两个好消息。首先，下面讨论的这些话题是没有什么差别的：</p>
<ul>
<li><p>A local variable assignment</p>
</li>
<li><p>Field in a structure</p>
</li>
<li><p>Return value from a function</p>
</li>
<li><p>Parameters to a function</p>
</li>
<li><p>The receiver of a method</p>
</li>
<li><p>局部变量赋值</p>
</li>
<li><p>结构体中的字段</p>
</li>
<li><p>函数的返回值</p>
</li>
<li><p>函数的参数</p>
</li>
<li><p>方法的接收者</p>
</li>
</ul>
<p>Secondly, if you aren’t sure, use a pointer.<br>其次，如果你不确定，就用指针好了。</p>
<p>As we already saw, passing values is a great way to make data immutable<br>(changes that a function makes to it won’t be reflected in the calling code).<br>Sometimes, this is the behavior that you’ll want but more often, it won’t be.</p>
<p>就如我们看到的那样，传值是一个让值不可变的好方法（函数内的改变不会影响调用代码中的值）。有些时候，我们却时希望如此，可常常不是这样的。<br>Even if you don’t intend to change the data, consider the cost of creating a copy of large structures.<br>Conversely, you might have small structures, say:</p>
<p>就算你不想改变值，想一下创建一个大结构体拷贝的开销。相反地，你可能有一个小结构体，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">  X <span class="keyword">int</span></span><br><span class="line">  Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In such cases, the cost of copying the structure is probably offset by being able to access <code>X</code> and <code>Y</code> directly, without any indirection.</p>
<p>在这种情况下，拷贝结构体的开销可以通过偏移量来直接访问<code>X</code>和<code>Y</code>，而不是间接访问。<br>Again, these are all pretty subtle cases. Unless you’re iterating over thousands or possibly tens of thousands of such points, you wouldn’t notice a difference.</p>
<p>再次指出，这些只是非常微妙的情况。除非你要访问成千上百个这样的点，否则你不会察觉有任何的不同。</p>
<h2 id="继续之前（Before-You-Continue）"><a href="#继续之前（Before-You-Continue）" class="headerlink" title="继续之前（Before You Continue）"></a>继续之前（Before You Continue）</h2><p>From a practical point of view, this chapter introduced structures, how to make an instance of a structure a receiver of a function, and added pointers to our existing knowledge of Go’s type system. The following chapters will build on what we know about structures as well as the inner workings that we’ve explored.</p>
<p>本章从实践的角度来看，介绍了结构体，以及如何创建方法接收器的结构体实例，并在我们现有的Go知识体系中引入了指针。<br>下面的章节将基于我们所知道的结构体知识来探讨其内部运行机制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-1/" class="post-title-link" itemprop="url">Go Little Book - 第一章 - 基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:03:33" itemprop="dateCreated datePublished" datetime="2018-11-22T10:03:33+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:55" itemprop="dateModified" datetime="2018-12-05T10:40:55+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-基础（Chapter-1-The-Basics）"><a href="#第一章-基础（Chapter-1-The-Basics）" class="headerlink" title="第一章 - 基础（Chapter 1 - The Basics）"></a>第一章 - 基础（Chapter 1 - The Basics）</h1><p>Go is a compiled, statically typed language with a C-like syntax and garbage collection. What does that mean?</p>
<p>Go是一门静态类型、编译型语言，有类C风格的语法和垃圾回收机制。这意味着什么呢？</p>
<h2 id="编译（Compilation）"><a href="#编译（Compilation）" class="headerlink" title="编译（Compilation）"></a>编译（Compilation）</h2><p>Compilation is the process of translating the source code that you write into a lower level language – either assembly (as is the case with Go), or some other intermediary language (as with Java and C#).</p>
<p>编译将你写的源代码转换成一种更低级的语言————可能是汇编（如Go就是这样），或者其他中间语言（如Java和C#）的过程。</p>
<p>Compiled languages can be unpleasant to work with because compilation can be slow. It’s hard to iterate quickly if you have to spend minutes or hours waiting for code to compile. Compilation speed is one of the major design goals of Go. This is good news for people working on large projects as well as those of us used to a quick feedback cycle offered by interpreted languages.</p>
<p>因为编译可能很慢，使用编译型语言可能不是个令人愉快的事情。很难实现快速迭代因为你不得不花几分钟甚至几个小时的时间来等待编绎完成。编译速度是Go设计时的一个主要目标。这对于大项目的开发人员来说是个好消息，就像我们可以使用解释语言提供的快速反馈周期。</p>
<p>Compiled languages tend to run faster and the executable can be run without additional dependencies (at least, that’s true for languages like C, C++ and Go which compile directly to assembly).</p>
<p>编译型语言往往运行得更快，不需要额外的依赖也可以正常运行（至少，像C、C++和Go这样直接编译成汇编的语言来说，就是如此。）</p>
<h2 id="静态类型（Static-Typing）"><a href="#静态类型（Static-Typing）" class="headerlink" title="静态类型（Static Typing）"></a>静态类型（Static Typing）</h2><p>Being statically typed means that variables must be of a specific type (int, string, bool, []byte, etc.). This is either achieved by specifying the type when the variable is declared or, in many cases, letting the compiler infer the type (we’ll look at examples shortly).</p>
<p>静态类型是指变量必须指定一个类型（整型、字符串、布尔、字节数组等等）。可以在申明变量的时候指定数据类型，也可以,大多数情况是让编译器来推断类型（我们将会在接下来的例子中看到）。</p>
<p>There’s a lot more that can be said about static typing, but I believe it’s something better understood by looking at code. If you’re used to dynamically typed languages, you might find this cumbersome. You’re not wrong, but there are advantages, especially when you pair static typing with compilation. The two are often conflated. It’s true that when you have one, you normally have the other but it isn’t a hard rule. With a rigid type system, a compiler is able to detect problems beyond mere syntactical mistakes as well as make further optimizations.</p>
<p>关于静态类型还有很多可以介绍，但我相信理解它更好的方式是阅读代码。如果你习惯于动态语言，你可能觉得这比较麻烦。没错，不过静态类型也有优势，尤其是和编译相结合的时候。静态类型和编译这两者经常被混为一谈。虽然这不是硬性的规定，但通常情况下，有其一就必有其二。在严格类型系统中，编译器除了能够检测出单纯的语法错误问题还能做出进一步的优化。</p>
<h2 id="类C语法（C-Like-Syntax）"><a href="#类C语法（C-Like-Syntax）" class="headerlink" title="类C语法（C-Like Syntax）"></a>类C语法（C-Like Syntax）</h2><p>Saying that a language has a C-like syntax means that if you’re used to any other C-like languages such as C, C++, Java, JavaScript and C#, then you’re going to find Go familiar – superficially, at least. For example, it means <code>&amp;&amp;</code> is used as a boolean AND, <code>==</code> is used to compare equality, <code>{</code> and <code>}</code> start and end a scope, and array indexes start at 0.</p>
<p>说一门语言有一个类C的语法意味着，如果你使用的任何其他类似C语言，如C，C ++，Java，JavaScript以及C＃，那么你会发现Go的相似之处————至少从表面上看。比如，<code>&amp;&amp;</code>表示逻辑与,<code>==</code>表示相等判断，<code>{}</code>和<code>}</code>是作用域的开始和结束，以及数组从0开始索引。</p>
<p>C-like syntax also tends to mean semi-colon terminated lines and parentheses around conditions. Go does away with both of these, though parentheses are still used to control precedence. For example, an <code>if</code> statement looks like this:</p>
<p>类C语法也往往使用分号结束行和条件表达式用括号括起来。Go没用使用这两种方式，尽管依然使用括号来控制优先权。比如，一个<code>if</code>表达式看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">"Leto"</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"the spice must flow"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And in more complicated cases, parentheses are still useful:</p>
<p>在更复杂的情况下，括号依然有用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name == <span class="string">"Goku"</span> &amp;&amp; power &gt; <span class="number">9000</span>) || (name == <span class="string">"gohan"</span> &amp;&amp; power &lt; <span class="number">4000</span>)  &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"super Saiyan"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Beyond this, Go is much closer to C than C# or Java - not only in terms of syntax, but in terms of purpose. That’s reflected in the terseness and simplicity of the language which will hopefully start to become obvious as you learn it.</p>
<p>除此之外，Go比C#或者Java更接近C，不仅在语法方面，还在用途方面。这体现在语言风格的简洁和简单，随着不断深入学习，你会越来越明显的体会到这种特性。</p>
<h2 id="垃圾回收机制（Garbage-Collected）"><a href="#垃圾回收机制（Garbage-Collected）" class="headerlink" title="垃圾回收机制（Garbage Collected）"></a>垃圾回收机制（Garbage Collected）</h2><p>Some variables, when created, have an easy-to-define life. A variable local to a function, for example, disappears when the function exits. In other cases, it isn’t so obvious – at least to a compiler. For example, the lifetime of a variable returned by a function or referenced by other variables and objects can be tricky to determine. Without garbage collection, it’s up to developers to free the memory associated with such variables at a point where the developer knows the variable isn’t needed. How? In C, you’d literally <code>free(str);</code> the variable.</p>
<p>一些变量，在创建时就有明确的生命周期。如函数内的局部变量，当函数结束时就消失了。在另一些情况下，就没有这么明显了，起码对编译器来说是这样。比如函数中返回的变量，变量的引用和对象的引用的生命周期就很难判断了。没有垃圾回收机制的情况下，这依赖于开发人员在不需要这些变量时进行内存的释放。怎么实现？例如在c中，你需要正确的去释放一个变量的内存<code>free(str);</code>。</p>
<p>Languages with garbage collectors (e.g., Ruby, Python, Java, JavaScript, C#, Go) are able to keep track of these and free them when they’re no longer used. Garbage collection adds overhead, but it also eliminates a number of devastating bugs.</p>
<p>有垃圾回收机制的语言（如Ruby、Python、Java、JavaScript、C#、Go）能记录变量并在不使用时进行释放。垃圾回收机制增加了开销，但也杜绝了一些破坏性的bug。</p>
<h2 id="运行Go代码（Running-Go-Code）"><a href="#运行Go代码（Running-Go-Code）" class="headerlink" title="运行Go代码（Running Go Code）"></a>运行Go代码（Running Go Code）</h2><p>Let’s start our journey by creating a simple program and learning how to compile and execute it. Open your favorite text editor and write the following code:</p>
<p>让我们创建一个简单的例子来学习如何编译和运行它，来开始我们的Go学习之旅。打开你最喜欢的文本编辑器，输入如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"it's over 9000!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Save the file as <code>main.go</code>. For now, you can save it anywhere you want; we don’t need to live inside Go’s workspace for trivial examples.</p>
<p>将文件保存为<code>main.go</code>。开始，你可以将它保存在任何你想要的地方；作为简单的例子，我们还不需要深入理解Go的工作区。</p>
<p>Next, open a shell/command prompt and change the directory to where you saved the file. For me, that means typing <code>cd ~/code</code>.</p>
<p>接下来，打开一个shell/命令行，然后将目录切换到你保存文件的位置。对我来，输入<code>cd ~/code</code>就可以了。</p>
<p>Finally, run the program by entering:</p>
<p>最后，能过输入如下命令来运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure>

<p>If everything worked, you should see <em>it’s over 9000!</em>.</p>
<p>如果一切正常，你会看到 <em>it’s over 9000!</em>。</p>
<p>But wait, what about the compilation step? <code>go run</code> is a handy command that compiles <em>and</em> runs your code. It uses a temporary directory to build the program, executes it and then cleans itself up. You can see the location of the temporary file by running:</p>
<p>等等，那编译过程呢？<code>go run</code>是一个方便的编译和执行代码的命令。它使用临时目录来生成程序和运行，然后清理。通过下面的代码你可以查看临时文件所在位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run --work main.go</span><br></pre></td></tr></table></figure>

<p>To explicitly compile code, use <code>go build</code>:</p>
<p>要显示的编译代码，使用<code>go build</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure>

<p>This will generate an executable <code>main</code> which you can run. On Linux / OSX, don’t forget that you need to prefix the executable with dot-slash, so you need to type <code>./main</code>.</p>
<p>这会生成一个可执行的<code>main</code>程序。在Linux/OSX中，不要忘记在可执行文件前面加上点和反斜杠，所有你需要输入<code>./main</code>。</p>
<p>While developing, you can use either <code>go run</code> or <code>go build</code>. When you deploy your code however, you’ll want to deploy a binary via <code>go build</code> and execute that.</p>
<p>在开发的时候，你可以使用<code>go run</code>或者<code>go build</code>。但当你发布的时候，你需要使用<code>go build</code>来生成可执行文件并运行它。</p>
<h3 id="主函数（Main）"><a href="#主函数（Main）" class="headerlink" title="主函数（Main）"></a>主函数（Main）</h3><p>Hopefully, the code that we just executed is understandable. We’ve created a function and printed out a string with the built-in <code>println</code> function. Did <code>go run</code> know what to execute because there was only a single choice? No. In Go, the entry point to a program has to be a function called <code>main</code> within a package <code>main</code>.</p>
<p>但愿，我们刚刚的执行的代码是可以理解的。我们创建了一个函数，它调用内置的<code>println</code>函数打印一个字符串。难道是因为只有一个选择，所以<code>go run</code>才知道要执行什么吗？不是的，在Go语言中，程序的入口是<code>main</code>包中的<code>main</code>函数。</p>
<p>We’ll talk more about packages in a later chapter. For now, while we focus on understanding the basics of Go, we’ll always write our code within the <code>main</code> package.</p>
<p>后续章节我们会介绍更多包的内容。现在，为了我们着重理解Go的基础知识，我们只在<code>main</code>包中写代码。</p>
<p>If you want, you can alter the code and change the package name. Run the code via <code>go run</code> and you should get an error. Then, change the name back to <code>main</code> but use a different function name. You should see a different error message. Try making those same changes but use <code>go build</code> instead. Notice that the code compiles, there’s just no entry point to run it. This is perfectly normal when you are, for example, building a library.</p>
<p>如果你愿意，你也可以修改代码并改变包名89。并使用<code>go run</code>去执行，你会得到一个错误信息。然后，将包名改成<code>main</code>，但是函数名不叫<code>main</code>，再次运行代码，你会得到一个不同的错误信息。使用<code>go build</code>进行相同的操作，注意编译代码时，这里没有运行代码的入口点。这是很正常的，例如当你编译一个库时。</p>
<h2 id="包导入（Imports）"><a href="#包导入（Imports）" class="headerlink" title="包导入（Imports）"></a>包导入（Imports）</h2><p>Go has a number of built-in functions, such as <code>println</code>, which can be used without reference. We can’t get very far though, without making use of Go’s standard library and eventually using third-party libraries. In Go, the <code>import</code> keyword is used to declare the packages that are used by the code in the file.</p>
<p>Go有一些内建函数是不需要引入就可以直接使用，如<code>println</code>。不利用Go标准库和第三方类库的话，我们不能走得很远。在Go中，使用<code>import</code>关键字来申明代码中使用的包。</p>
<p>Let’s change our program:<br>让我们来修改下程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"It's over "</span>, os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which you can run via:</p>
<p>通过下面的命令来运行它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go 9000</span><br></pre></td></tr></table></figure>

<p>We’re now using two of Go’s standard packages: <code>fmt</code> and <code>os</code>. We’ve also introduced another built-in function <code>len</code>. <code>len</code> returns the size of a string, or the number of values in a dictionary, or, as we see here, the number of elements in an array. If you’re wondering why we expect 2 arguments, it’s because the first argument – at index 0 – is always the path of the currently running executable. (Change the program to print it out and see for yourself.)</p>
<p>我们用了两个Go的标准包：<code>fmt</code>和<code>os</code>。我们引入了另一个内建函数<code>len</code>。<code>len</code>返加字符串的长度，或者字典的个数，再或者，如这个例子，数组元素的个数。如果你想知道为什么我们期望是两个参数，这是因为索引为0的第一个参数是当前可执程序的路径（你可以自己修改代码将它打印出来看看）。</p>
<p>You’ve probably noticed we prefix the function name with the package, e.g., <code>fmt.Println</code>. This is different from many other languages. We’ll learn more about packages in later chapters. For now, knowing how to import and use a package is a good start.</p>
<p>你可能已经注意到了函数名之前的包名了，比如：<code>fmt.Println</code>，这和其他很多语言不同。后续章节我们会学习更多包的内容。现在，知道如何导入和使用包就好了。</p>
<p>Go is strict about importing packages. It will not compile if you import a package but don’t use it. Try to run the following:</p>
<p>Go对包导入很严格。如果导入了包，但没有使用是不能通过编译的。试试运行下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You should get two errors about <code>fmt</code> and <code>os</code> being imported and not used. Can this get annoying? Absolutely. Over time, you’ll get used to it (it’ll still be annoying though). Go is strict about this because unused imports can slow compilation; admittedly a problem most of us don’t have to this degree.</p>
<p>你会看到两个错误信息，显示<code>fmt</code>和<code>os</code>包被导入但是没有被使用。这会让人烦吗？绝对的。随着时间的推移，你会习惯（虽然还是烦人）。Go之所以在这点上这么严格是因为导入未使用的包会影响编译速度。不可否认的是，我们大多数人都没有这个深度。</p>
<p>Another thing to note is that Go’s standard library is well documented. You can head over to <a href="http://golang.org/pkg/fmt/#Println" target="_blank" rel="noopener">http://golang.org/pkg/fmt/#Println</a> to learn more about the <code>Println</code> function that we used. You can click on that section header and see the source code. Also, scroll to the top to learn more about Go’s formatting capabilities.</p>
<p>令一个值得注意的地方就是Go的标准包的文档很完善。你可以通过<a href="http://golang.org/pkg/fmt/#Println" target="_blank" rel="noopener">http://golang.org/pkg/fmt/#Println</a> 来学习更多我们用到过的<code>Println</code>的内容。你可以点击章节标题来查看源码。也可以滚动到顶部来查看更多关于Go格式化的功能。</p>
<p>If you’re ever stuck without internet access, you can get the documentation running locally via:<br>如果你不能访问网络，你可以通过下面的方面运行本地的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http&#x3D;:6060</span><br></pre></td></tr></table></figure>

<p>and pointing your browser to <code>http://localhost:6060</code></p>
<p>然后通过<code>http://localhost:6060</code>来浏览。</p>
<h2 id="变量和声明（Variables-and-Declarations）"><a href="#变量和声明（Variables-and-Declarations）" class="headerlink" title="变量和声明（Variables and Declarations）"></a>变量和声明（Variables and Declarations）</h2><p>It’d be nice to begin and end our look at variables by saying <em>you declare and assign to a variable by doing x = 4.</em> Unfortunately, things are more complicated in Go. We’ll begin our conversation by looking at simple examples. Then, in the next chapter, we’ll expand this when we look at creating and using structures. Still, it’ll probably take some time before you truly feel comfortable with it.</p>
<p><em>通过x = 4就能声明和赋值变量</em> ，对你来说可能是一个好的开始和结束。不幸的是，Go中要复杂一些。我们将通过简单的例子来开始我们的话题。然后，我们会在下一章节中，在讲解分创建的使用结构体的时候，我们会展开来讲解。但是，你可以需要花一些时间来适应它。</p>
<p>You might be thinking <em>Woah! What can be so complicated about this?</em> Let’s start looking at some examples.</p>
<p>你可能会觉得 <em>哇！为什么这么复杂?</em>让我们来看些例子吧。</p>
<p>The most explicit way to deal with variable declaration and assignment in Go is also the most verbose:</p>
<p>在Go中最直接也是最繁索的变量声明和赋值方式是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> power <span class="keyword">int</span></span><br><span class="line">  power = <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"It's over %d\n"</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, we declare a variable <code>power</code> of type <code>int</code>. By default, Go assigns a zero value to variables. Integers are assigned <code>0</code>, booleans <code>false</code>, strings <code>&quot;&quot;</code> and so on. Next, we assign <code>9000</code> to our <code>power</code> variable. We can merge the first two lines:</p>
<p>这里，我们声明了一个<code>int</code>类型的变量<code>power</code>。默认情况下，Go给变量赋为0值。整型赋为<code>0</code>，布尔型赋为<code>false</code>，字符串赋为<code>&quot;&quot;</code>等等。接着，我们给变量<code>power</code>赋值为<code>9000</code>。我们可以合并开始的这两行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> power <span class="keyword">int</span> = <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>Still, that’s a lot of typing. Go has a handy short variable declaration operator, <code>:=</code>, which can infer the type:</p>
<p>依然，还是需要很多的输入。Go有更方便的变量声明操作符，<code>:=</code>，它可以推断类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power := <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>This is handy, and it works just as well with functions:</p>
<p>这很方便，对函数也同样适用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := getPower()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPower</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">9001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It’s important that you remember that <code>:=</code> is used to declare the variable as well as assign a value to it. Why? Because a variable can’t be declared twice (not in the same scope anyway). If you try to run the following, you’ll get an error.</p>
<p>记住<code>:=</code>用于声明和赋值变量这点很重要。为什么呢？因为一个变量不能被声明两次（在同一个作用域中）。如果你尝试运行下面的代码，你会看到一个错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"It's over %d\n"</span>, power)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// COMPILER ERROR:</span></span><br><span class="line">  <span class="comment">// no new variables on left side of :=</span></span><br><span class="line">  power := <span class="number">9001</span></span><br><span class="line">  fmt.Printf(<span class="string">"It's also over %d\n"</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The compiler will complain with <em>no new variables on left side of :=</em>. This means that when we first declare a variable, we use <code>:=</code> but on subsequent assignment, we use the assignment operator <code>=</code>. This makes a lot of sense, but it can be tricky for your muscle memory to remember when to switch between the two.</p>
<p>编译器会抱错提示 <em>:=左边不是新的变量</em>。这就是说我们一开始用<code>:=</code>来声明一个变量，接下来我们需要用<code>=</code>来给变量赋值。这很用意义，但是对你的记忆力来说是一个负担，因为你要记住这两者之间切换的时机。</p>
<p>If you read the error message closely, you’ll notice that <em>variables</em> is plural. That’s because Go lets you assign multiple variables (using either <code>=</code> or <code>:=</code>):</p>
<p>如果你仔细看错误信息，你会发现 <em>变量</em>用了复数形式。因为Go支持多个变量同时赋值（使用<code>=</code>或者<code>:=</code>）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name, power := <span class="string">"Goku"</span>, <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"%s's power is over %d\n"</span>, name, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As long as one of the variables is new, <code>:=</code> can be used. Consider:</p>
<p>只要有一个变量是新的就可以使用<code>:=</code> 操作符。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  power := <span class="number">1000</span></span><br><span class="line">  fmt.Printf(<span class="string">"default power is %d\n"</span>, power)</span><br><span class="line"></span><br><span class="line">  name, power := <span class="string">"Goku"</span>, <span class="number">9000</span></span><br><span class="line">  fmt.Printf(<span class="string">"%s's power is over %d\n"</span>, name, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Although <code>power</code> is being used twice with <code>:=</code>, the compiler won’t complain the second time we use it, it’ll see that the other variable, <code>name</code>, is a new variable and allow <code>:=</code>. However, you can’t change the type of <code>power</code>. It was declared (implicitly) as an integer and thus, can only be assigned integers.</p>
<p>虽然变量<code>power</code>使用了<code>:=</code>，但是编译器不会在第2次使用<code>:=</code>时报错，因为这里有一个新变量<code>name</code>，允许使用<code>:=</code>。但你不能改变<code>power</code>的类型。它已经被声明（隐式的）为整型，所以只能用整数来赋值。</p>
<p>For now, the last thing to know is that, like imports, Go won’t let you have unused variables. For example,</p>
<p>最后，和包导入一样，Go不允许未使用的变量。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  name, power := <span class="string">"Goku"</span>, <span class="number">1000</span></span><br><span class="line">  fmt.Printf(<span class="string">"default power is %d\n"</span>, power)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>won’t compile because <code>name</code> is declared but not used. Like unused imports it’ll cause some frustration, but overall I think it helps with code cleanliness and readability.</p>
<p>不会被编译因为变量<code>name</code>声明了但没有使用。和包导入一样会带来一些挫败感，但总的来说，这是为了代码的简洁和可读性。</p>
<p>There’s more to learn about declaration and assignments. For now, remember that you’ll use <code>var NAME TYPE</code> when declaring a variable to its zero value, <code>NAME := VALUE</code> when declaring and assigning a value, and <code>NAME = VALUE</code> when assigning to a previously declared variable.</p>
<p>声明和赋值还有内容需要学习。现在，只要记住，用<code>var NAME TYPE</code>来声明变量并赋0值，用<code>NAME := VALUE</code>声明变量并赋值，和用<code>NAME = VALUE</code>给已声明的变量赋值。</p>
<h2 id="函数声明（Function-Declarations）"><a href="#函数声明（Function-Declarations）" class="headerlink" title="函数声明（Function Declarations）"></a>函数声明（Function Declarations）</h2><p>This is a good time to point out that functions can return multiple values. Let’s look at three functions: one with no return value, one with one return value, and one with two return values.</p>
<p>现在是一个好的时机来指出函数是可以有多返回值的。让我们来看3个函数：一个没有返回值，一个有一个返回值，另一个有两个返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">power</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’d use the last one like so:<br>我们像这样来使用最后一个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, exists := power(<span class="string">"goku"</span>)</span><br><span class="line"><span class="keyword">if</span> exists == <span class="literal">false</span> &#123;</span><br><span class="line">  <span class="comment">// handle this error case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sometimes, you only care about one of the return values. In these cases, you assign the other values to <code>_</code>:</p>
<p>有时，你可能只关心其中一个返回值。在这种情况下，你可以把其他值赋为<code>_</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, exists := power(<span class="string">"goku"</span>)</span><br><span class="line"><span class="keyword">if</span> exists == <span class="literal">false</span> &#123;</span><br><span class="line">  <span class="comment">// handle this error case</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is more than a convention. <code>_</code>, the blank identifier, is special in that the return value isn’t actually assigned. This lets you use <code>_</code> over and over again regardless of the returned type.</p>
<p>这不仅仅是一个约定。<code>_</code>，空白标识符，尤其在用在返回值时它没有真正的赋值。无论返回值是什么类型你都可以使用<code>_</code>。</p>
<p>Finally, there’s something else that you’re likely to run into with function declarations. If parameters share the same type, we can use a shorter syntax:</p>
<p>最后，你可能遇到一些不同的函数声明方式。如果函数的参数类型都相同，那么可以用以下更简洁的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Being able to return multiple values is something you’ll use often. You’ll also frequently use <code>_</code> to discard a value. Named return values and the slightly less verbose parameter declaration aren’t that common. Still, you’ll run into all of these sooner than later so it’s important to know about them.</p>
<p>你会常常用到函数多返回值这个特性。你也会经常使用<code>_</code>去舍弃一个返回值。具名返回值和无名参数声明并不常见。但是迟早你都会遇到，最好对他们都有所了解。</p>
<h2 id="继续之前（Before-You-Continue）"><a href="#继续之前（Before-You-Continue）" class="headerlink" title="继续之前（Before You Continue）"></a>继续之前（Before You Continue）</h2><p>We looked at a number of small individual pieces and it probably feels disjointed at this point. We’ll slowly build larger examples and hopefully, the pieces will start to come together.</p>
<p>现在我们已经学习了许多的小知识点，你可能会觉得有点脱节。我们会逐步构建一个更大的例子，有望将这些小知识点串联起来。</p>
<p>If you’re coming from a dynamic language, the complexity around types and declarations might seem like a step backwards. I don’t disagree with you. For some systems, dynamic languages are categorically more productive.</p>
<p>如果你是来自动态类型语言的开发人员，你可能会觉得Go的变量类型和声明的复杂是一种倒退。我同意你的看法。对于一些系统，动态类型的语言绝对更有效率。</p>
<p>If you’re coming from a statically typed language, you’re probably feeling comfortable with Go. Inferred types and multiple return values are nice (though certainly not exclusive to Go). Hopefully as we learn more, you’ll appreciate the clean and terse syntax.</p>
<p>如果你是来自静态类型语言的开发人员，你可能会习惯使用Go。类型推断和多返回值是如此的美好（尽管这不是Go独有的）。希望随着我们不断深入的学习，你会喜欢上Go干净和简洁的语法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/getting-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/getting-start/" class="post-title-link" itemprop="url">Go Little Book - 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:02:33" itemprop="dateCreated datePublished" datetime="2018-11-22T10:02:33+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:40" itemprop="dateModified" datetime="2018-12-05T10:40:40+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>如果你想试试Go，你可以使用Go运行环境，它可以让你无需安装任何东西就可以在网上运行代码。这也是在Go论坛如StackOverflow中寻求帮助时，分享Go代码最常用的方式。</p>
<p>安装Go很简单。你可以从源码安装，但我建议你用一个已编译好的可执行文件。当你打开下载页面时，你可以看到不同平台的安装包。让我们避免使用这些并学习自己如何配置Go。然后你就会发现这不难。</p>
<p>除了简单的例子，Go被设计成只有你的代码在工作区时才能正常运行。这个工作区是有<code>bin</code>、<code>pkg</code>和<code>src</code>三个子目录的文件夹。你也许会想强制Go去适应你自己的风格 - 别想。</p>
<p>通常，我把我的项目放在<code>~/code</code>目录下。例如，<code>~/code/blog</code>是我的博客。对于Go来说，我的工作区是<code>~/code/go</code>，而我Go版本的博客会在<del>/code/go/src/blog下。因为这经常用到，我做了个符号链接，通过`</del>/code/blog`来访问它：</p>
<pre><code>ln -s ~/code/go/src/blog ~/code/blog</code></pre><p>总之，无论你把你的项目放在哪，创建一个Go目录包含src子目录来放置你的项目。</p>
<h2 id="OSX-Linux"><a href="#OSX-Linux" class="headerlink" title="OSX / Linux"></a>OSX / Linux</h2><p>下载你平台对应<code>tar.gz</code>。OSX，你需要关心<code>go#.#.#.darwin-amd64-osx10.8.tar.gz</code>，其中<code>#.#.#</code>表示Go的最新版本。</p>
<p>通过<code>tar -C /usr/local -xzf go#.#.#.darwin-amd64-osx10.8.tar.gz</code>将文件解压到<code>/usr/local</code>目录。</p>
<p>设置两个环境变量：</p>
<ol>
<li><code>GOPATH</code>指向你的工作区，对我来说是<code>$HOME/code/go</code>。</li>
<li>我们需要将Go可执行文件的路径添加到<code>PATH</code>。</li>
</ol>
<p>你可以通过shell来完成设置：</p>
<pre><code>echo &apos;export GOPATH=$HOME/code/go&apos; &gt;&gt; $HOME/.profile
echo &apos;export PATH=$PATH:/usr/local/go/bin&apos; &gt;&gt; $HOME/.profile</code></pre><p>为了使这些变量生效，你需要关闭并重新打开你的Shell，或者运行<code>source $HOME/.profile</code>命令。</p>
<p>输入<code>go version</code>,你会看到类似这样的输出<code>go version go1.3.3</code>。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>下载最新的zip文件。如果你是x64系统，你需要下载<code>go#.#.#.windows-amd64.zip</code>，其中<code>#.#.#</code>表示Go的最新版本。</p>
<p>将其解压到你想要的位置。<code>c:\Go</code>是个不错和选择。</p>
<p>Set up two environment variables:<br>设置两个环境变理：</p>
<ol>
<li><code>GOPATH</code> 指向你的工作区. 可以是这样的目录<code>c:\users\goku\work\go</code>。</li>
<li>添加 <code>c:\Go\bin</code> 至你的<code>PATH</code>环境变量中。</li>
</ol>
<p>环境变量可以通过<code>系统</code>控制面板中的<code>环境变量</code>按钮中的<code>高级</code>标签页来设置。某些版本的Windows通过<code>System</code>控制面板里面的<code>高级系统Settings</code>选项提供该控制面板。</p>
<p>打开一个命令行窗口，输入<code>go version</code>，你会看到类似这样的输出<code>go version go1.3.3 windows/amd64</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/introduction/" class="post-title-link" itemprop="url">Go Little Book - 引言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:01:11" itemprop="dateCreated datePublished" datetime="2018-11-22T10:01:11+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-08 21:04:05" itemprop="dateModified" datetime="2018-12-08T21:04:05+08:00">2018-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>每当我学习一门新语言的时候总是爱恨交加。一方面，语言是如此的重要，以至于一点小的变化对我们产生的不可估量的影响。在你的程序和可以重新定义你对其他语言的期望的时候，你会有一个持久的效果。同时，语言的设计是增量的。学习新的关键字、类型体系、编码方式以及新类库、通讯和范式需要很多工作，但又很难评估。相对学习其他必学的东西，学习新语言让我们常常感觉是对时间的投入很大。</p>
<p>也就是说，我们要进步。我们必须愿意采用渐进的方式，又一次因为，语言是我们的基础。虽然变化是增量的，但它们往往范围很广，它们影响效率，可读性、性能、可测试性、依赖管理、错误处理、文档、分析（监控？）、通讯、标准库等等。除了说千刀万剐我们还能说什么？</p>
<p>这留给我们一个重要的问题：为什么选Go？对我来说，有两个令人信服的理由。首先它是一门相对简单的语言，还自带相对简单的标准库。在很多方面，Go的增量本质简化了我们已经看到的在过去几十年引入的语言的复杂性。另一个原因对于很多开发者来说，它会完善你的军火库。</p>
<p>Go被构建为一个系统语言（比如操作系统、设备驱动）并且面向C和C++开发人员。纵观Go的社群，我非常确信，应用开发者，而非系统开发者已经成为Go的主要使用者。为什么？我不能代表系统开发者，但是我们建设的网站、服务、桌面应用等等，这些面向新兴需求可归结为一类介于低层次的系统应用程序和更高级别的应用程序之间的系统。</p>
<p>也许它是一个消息，缓存，大数据分析，命令行接口，日志或监控。我不知如何标记它，但是在我的职业身涯中，由于系统的复杂性不断和频繁并发数以万计的增长，定制的基础设施类系统成为一个不断增长的需求。你可以用Ruby或Python或别的东西（确实很多人这么做）来构建这样的系统，如果使用Go，这些系统可以有一个更严格的类型系统和更高的性能优势。同样，您可以使用Go建立网站（确实很多人这样做），但，为了更大的回旋余地，我还是喜欢使用Node或Ruby的来构建这类系统。</p>
<p>还有一些Go的长处。比如，运行Go程序时没有依赖。你不需要担心你的用户是否已经安装了Ruby或者JVM和它们的版本。因为这个原因，Go作为命令行程序或者需要分发的其他类型的实用程序（比如日志收集器）开发语言，越来越流行了。</p>
<p>简单地说，学习Go是一种有效利用你的时间。你将不必花费很长时间来学习甚至掌握go，你可以通过一些实践来达成。</p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>我曾犹豫写这本小册子有几个原因。首先Go有自已的文档，特别是高效Go，它很实在（实用？）。</p>
<p>另一个原因是我写一本关于语言的书时的不适。当我写MongoDB小册子的时候，你可以假设很多读者理解基本的关系型数据库和模型。写Redis小册子的时候，你可以假设从一个熟悉的键值存储开始。</p>
<p>当想到摆在面前的段落和章节的时候，我知道我不能做这样的假设。你要花多少时间来讲解接口，因为对于一些人来说这是一个新概念，而另个一些人已经不需用再了解了。最终，我会感到欣慰如果你让我知道有些部分是太浅或过于详细。考虑一下这本书的价格。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/about/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/about/" class="post-title-link" itemprop="url">Go Little Book - 关于本书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:00:00" itemprop="dateCreated datePublished" datetime="2018-11-22T10:00:00+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-05 10:40:59" itemprop="dateModified" datetime="2018-12-05T10:40:59+08:00">2018-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>289</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h1><h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p>本书使用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享4.0</a>许可。你不需要为本书付费。你可以自由的拷贝、发布、修改或展示本书。但是，我要求本书必须用我本人（Karl Seguin）的署名，同时不能作为经济用途。</p>
<p>你可在以下链接中查看到该许可的所有内容：</p>
<p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">http://creativecommons.org/licenses/by-nc-sa/4.0/</a></p>
<h2 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h2><p>本书最新源码的放在：<a href="http://github.com/karlseguin/the-little-go-book" target="_blank" rel="noopener">http://github.com/karlseguin/the-little-go-book</a></p>
<p>中文译本最新源码的放在：<a href="http://github.com/enderjo/the-little-go-book" target="_blank" rel="noopener">http://github.com/enderjo/the-little-go-book</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/21/frontend/nodejs/yarn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/frontend/nodejs/yarn/" class="post-title-link" itemprop="url">YARN命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-21 17:14:33" itemprop="dateCreated datePublished" datetime="2018-11-21T17:14:33+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-26 11:51:13" itemprop="dateModified" datetime="2019-04-26T11:51:13+08:00">2019-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/frentend/" itemprop="url" rel="index"><span itemprop="name">frentend</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/frentend/nodejs/" itemprop="url" rel="index"><span itemprop="name">nodejs</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>自己用Hexo来做博客而用到了nodejs和npm。但npm生成的<code>node-modules</code>层次过深，时常打开文件夹时会很慢。</p>
<p>后来了解到了yarn，在yarn发布之前，所有Nodejs开发者用的都是npm包管理工具，而npm工具存在挺多难以忍受的诟病，包括安装速度慢、每次都要在线重新安装等问题，而yarn也是为了解决npm当前所存在的问题而出现的。</p>
<p>为了方便自己使用，整理了下安装和基本操作。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>如果原先有npm工具的话，安装yarn很简单，只需要一行命令即可：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有npm工具，安装yarn可参照<a href="https://yarnpkg.com/en/docs/install" target="_blank" rel="noopener">各平台下yarn工具安装方式</a>。</li>
</ul>
<h2 id="更换安装源"><a href="#更换安装源" class="headerlink" title="更换安装源"></a>更换安装源</h2><p>安装yarn之后默认的包安装源是<a href="https://registry.yarnpkg.com，可用查看命令" target="_blank" rel="noopener">https://registry.yarnpkg.com，可用查看命令</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config get registry</span><br></pre></td></tr></table></figure>

<p>若想提高yarn安装的速度，可将包安装源修改为cnpm的安装源，执行以下命令即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry 'https://registry.npm.taobao.org'</span><br></pre></td></tr></table></figure>

<h2 id="操作及对比"><a href="#操作及对比" class="headerlink" title="操作及对比"></a>操作及对比</h2><table>
<thead>
<tr>
<th>操作</th>
<th>npm</th>
<th>yarn</th>
</tr>
</thead>
<tbody><tr>
<td>初始化项目</td>
<td>npm init</td>
<td>yarn init</td>
</tr>
<tr>
<td>安装依赖操作</td>
<td>npm install/link</td>
<td>yarn install/link</td>
</tr>
<tr>
<td>安装某个依赖，并且默认保存到package</td>
<td>npm install xxx —save</td>
<td>yarn add xxx</td>
</tr>
<tr>
<td>移除某个依赖项目</td>
<td>npm uninstall xxx   —save</td>
<td>yarn remove xxx</td>
</tr>
<tr>
<td>安装某个开发时依赖项目</td>
<td>npm install –save   -dev xxx</td>
<td>yarn add xxx —dev</td>
</tr>
<tr>
<td>更新某个依赖项目</td>
<td>npm update –save xxx</td>
<td>yarn upgrade xxx</td>
</tr>
<tr>
<td>安装某个全局依赖项目</td>
<td>npm install -g xxx</td>
<td>yarn global add xxx</td>
</tr>
<tr>
<td>发布/登录/登出，一系列NPM   Registry操作</td>
<td>npm   publish/login/logout</td>
<td>yarn   publish/login/logout</td>
</tr>
<tr>
<td>运行某个命令</td>
<td>npm run/test</td>
<td>yarn run/test</td>
</tr>
<tr>
<td>查看帮助</td>
<td>npm -h</td>
<td>yarn -h</td>
</tr>
</tbody></table>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="yarn-global"><a href="#yarn-global" class="headerlink" title="yarn global"></a>yarn global</h3><p>yarn 的全局安装并不是加 -g 或者 –global 这样的参数，它使用 <a href="https://yarnpkg.com/en/docs/cli/global" target="_blank" rel="noopener">yarn global</a> 命令。用 yarn global –help 可以看到子命令列表</p>
<p>这些子命令的用法和非 global 的同名命令用法差不多。</p>
<h3 id="指定bin目录"><a href="#指定bin目录" class="headerlink" title="指定bin目录"></a>指定bin目录</h3><p>对于一些带 CLI 的模块，通过 yarn global add 可能会出问题，yarn global bin查看目录，并把该目录添加到Path中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000007189426" target="_blank" rel="noopener">yarn —— Nodejs包新管理工具</a></p>
<p><a href="https://segmentfault.com/a/1190000008489881" target="_blank" rel="noopener">使用 yarn global 代替 npm -g</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/02/misc/tunnel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/02/misc/tunnel/" class="post-title-link" itemprop="url">打造自己的HTTPS安全遂道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-02 08:27:18" itemprop="dateCreated datePublished" datetime="2018-11-02T08:27:18+08:00">2018-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-11-22 08:51:48" itemprop="dateModified" datetime="2018-11-22T08:51:48+08:00">2018-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/misc/" itemprop="url" rel="index"><span itemprop="name">misc</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近刚好在做小程序的开发，需要用到本地调试，刚开始时使用<code>Natapp</code>的免费遂道，勉强能开发（域免），后面买了付费遂道，域名不变开发顺畅起来。但要真机调试时还是不行，微信不认三级域名，需要购买他的二级域名服务。转念一想还不如自己搭建一个呢，成本可控，也只要折腾一次就好，反正也能学东西。于是也就有了本文。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>一台云主机，可在购买<a href="https://promotion.aliyun.com/ntms/act/qwbk.html#share_box?spm=5176.11533457.1089570.36.15da77e3g6I8CL&aliyunapp_auto_login=true&userCode=l7irb6oi" target="_blank" rel="noopener">阿里云</a>，开放对应端口。</li>
<li>一个已经备案的域名（备案过程真是个痛苦的过程，各种资料，各种步骤，还可能审不过），并且做了二级域名泛解析。（本文假设你已经会域名解析配置）</li>
<li><code>Go http tunnel</code>，可在这里下载(<a href="https://github.com/mmatczuk/go-http-tunnel/releases" target="_blank" rel="noopener">https://github.com/mmatczuk/go-http-tunnel/releases</a>)</li>
<li>Let’s Encrypt工具。</li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="https证书"><a href="#https证书" class="headerlink" title="https证书"></a>https证书</h2><p>可参看<a href="http://www.infoq.com/cn/news/2018/03/lets-encrypt-wildcard-https" target="_blank" rel="noopener">这里</a>或<a href="https://www.jianshu.com/p/c5c9d071e395" target="_blank" rel="noopener">这里</a><br>此处唯一要注意的就是有个域名解析的交互过程，这个在上述资料中也有说明。</p>
<p>记录下证书的生成位置如上文是<code>/etc/letsencrypt/archive/newyingyong.cn</code>，自动的生成路径可能不现。</p>
<h2 id="http-tunnel服务器"><a href="#http-tunnel服务器" class="headerlink" title="http tunnel服务器"></a>http tunnel服务器</h2><ul>
<li>服务器需要开放80,443,5223端口。</li>
<li>根据自己的服务器系统下载对应版本。</li>
<li>解压就可以了，进入目录。</li>
<li>执行如下命令，以https证书参考资料证书地址为例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tunneld -tlsCrt &#x2F;etc&#x2F;letsencrypt&#x2F;archive&#x2F;newyingyong.cn&#x2F;fullchain.pem -tlsKey &#x2F;etc&#x2F;letsencrypt&#x2F;archive&#x2F;newyingyong.cn&#x2F;privkey.pem</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="http-tunnel客户端"><a href="#http-tunnel客户端" class="headerlink" title="http tunnel客户端"></a>http tunnel客户端</h2><ul>
<li>根据自己的服务器系统下载对应版本</li>
<li>解压就可以了，进入目录。</li>
<li>生成客户端证书<code>openssl req -x509 -nodes -newkey rsa:2048 -sha256 -keyout client.key -out client.crt</code>,并将证书放到解压目录</li>
<li>创建<code>tunnel.yml</code>，默认读当前路径配置。</li>
<li>参考样例：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server_addr:</span> <span class="string">SERVER_IP:5223</span></span><br><span class="line"><span class="attr">tunnels:</span></span><br><span class="line">    <span class="attr">webui:</span></span><br><span class="line">        <span class="attr">proto:</span> <span class="string">http</span></span><br><span class="line">        <span class="attr">addr:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="attr">auth:</span> <span class="string">user:password</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">webui.my-tunnel-host.com</span></span><br></pre></td></tr></table></figure>
其中,<code>server_addr</code>为服务器地址，<code>tunnels</code>为开启的遂道列表，<code>webui</code>为实际的遂道名，正常可去掉<code>auth</code>配置，<code>host</code>中的域名与遂道名无直接关系。更多配置信息参看<a href="https://github.com/mmatczuk/go-http-tunnel" target="_blank" rel="noopener">官网</a>。</li>
<li>启动<code>tunnel start-all</code>。</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在客户端启动最简单http服务，使用客户端配置的域名进行访问，如果正常访问，恭喜你。如果还有问题，请核查服务器或客户端配置。</p>
<h1 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h1><p>如果你觉得以上配置过于复杂。有以下两种方式供你选择，当然你可能有更好的选择。</p>
<ol>
<li>可以使用<a href="https://natapp.cn/" target="_blank" rel="noopener">Natapp</a>，他提供免费的HTTPS的遂道，但提供的免费域名会一直变化。最好购买遂道和域名服务，付费时可以使用我的推广优惠码<code>ADBE2C5C</code>。</li>
<li>如果你恰好刚起步，希望用于本地调试，可以加我微信号，也可提供相关服务支持。申请时请备注<code>https tunnel技术支持</code>。<img src="https://l4qiang.me/images/wechat.png" alt="微信"></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">L4qiang</p>
  <div class="site-description" itemprop="description">记录点滴，注重积累。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/enderjo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;enderjo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:L4qiang@gmail.com" title="E-Mail → mailto:L4qiang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">L4qiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">390k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:54</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
      <div class="footer-inner">
        <a href="https://ri.cms.firesbox.com" target="_blank" rel="noopener">践行群官方情报站</a>
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>
</html>
